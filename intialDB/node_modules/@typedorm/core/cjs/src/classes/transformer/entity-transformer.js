"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EntityTransformer = void 0;
const common_1 = require("@typedorm/common");
const class_transformer_1 = require("class-transformer");
const unparse_key_1 = require("../../helpers/unparse-key");
const base_transformer_1 = require("./base-transformer");
/**
 * Note: To use any of the base transformer methods, this default entity transformer should be used
 */
class EntityTransformer extends base_transformer_1.BaseTransformer {
    constructor(connection) {
        super(connection);
    }
    /**
     * Converts dynamodb entity to model defined in entities
     * @param entityClass - Target class to look metadata off
     * @param dynamoEntity
     */
    fromDynamoEntity(entityClass, dynamoEntity, metadataOptions) {
        var _a;
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
            operation: common_1.TRANSFORM_TYPE.RESPONSE,
            prefix: 'Before',
            entityName: entityMetadata.name,
            primaryKey: null,
            body: dynamoEntity,
        });
        const vanillaAttributesToInclude = entityMetadata.attributes
            .filter(attr => !attr.hidden)
            .map(attr => attr.name);
        const primaryKeyAttributesToInclude = Object.keys(entityMetadata.schema.primaryKey.attributes).filter(attr => !vanillaAttributesToInclude.includes(attr));
        const entityInternalAttributeKeys = entityMetadata.internalAttributes.map(attr => attr.name);
        const entityHiddenAttributeKeys = entityMetadata.attributes
            .filter(attr => attr.hidden)
            .map(attr => attr.name);
        const entityMetadataSchemaIndexes = (_a = entityMetadata.schema.indexes) !== null && _a !== void 0 ? _a : {};
        const indexAttributesToInclude = Object.keys(entityMetadataSchemaIndexes)
            .map(key => {
            var _a;
            return Object.keys((_a = entityMetadataSchemaIndexes[key].attributes) !== null && _a !== void 0 ? _a : {});
        })
            .flat()
            .filter(attr => !vanillaAttributesToInclude.includes(attr));
        const plainEntityAttributes = Object.keys(dynamoEntity).reduce((acc, key) => {
            // if any of the below conditions are true, skip adding given attribute from returning response
            if (primaryKeyAttributesToInclude.includes(key) ||
                indexAttributesToInclude.includes(key) ||
                entityInternalAttributeKeys.includes(key) ||
                entityHiddenAttributeKeys.includes(key)) {
                return acc;
            }
            acc[key] = dynamoEntity[key];
            return acc;
        }, {});
        // get reflected constructor to avoid initialization issues with custom constructor
        const reflectedConstructor = Reflect.construct(Object, [], entityClass);
        // Perform a deep-copy of item returned by Document client to drop all the custom function types
        // Custom types are emitted by the document client in cases where dynamodb item was created outside the js ecosystem.
        // To correctly deserialize the returned values to the relevant Entity, it needs to be in a plain JSON structure.
        // i.e DynamoDB itself supports `StringSet` type but since js doesn't have a `StringSet` as a native type,
        // Therefore, DocumentClient wraps it as a custom `Set` type which must be turned into its JSON form before it can
        // be correctly deserialized by `class-transformer`.
        const deserializedEntityAttributes = JSON.parse(JSON.stringify(plainEntityAttributes));
        const transformedEntity = (0, class_transformer_1.plainToClassFromExist)(reflectedConstructor, deserializedEntityAttributes);
        this.connection.logger.logTransform({
            requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
            operation: common_1.TRANSFORM_TYPE.RESPONSE,
            prefix: 'After',
            entityName: entityMetadata.name,
            primaryKey: null,
            body: transformedEntity,
        });
        return transformedEntity;
    }
    fromDynamoKeyToAttributes(entityClass, dynamoKey) {
        var _a, _b, _c;
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        const primaryKeyAttributes = entityMetadata.schema.primaryKey.attributes;
        const interpolations = (_c = (_b = (_a = entityMetadata.schema.primaryKey) === null || _a === void 0 ? void 0 : _a.metadata) === null || _b === void 0 ? void 0 : _b._interpolations) !== null && _c !== void 0 ? _c : {};
        const rawAttributes = Object.entries(primaryKeyAttributes).reduce((acc, [keyName, keyPattern]) => {
            var _a;
            const unParsed = (0, unparse_key_1.unParseKey)(keyPattern, dynamoKey[keyName], (_a = interpolations[keyName]) !== null && _a !== void 0 ? _a : []);
            acc = Object.assign(Object.assign({}, acc), unParsed);
            return acc;
        }, {});
        // like compare actual key with the schema and pull out variable name an it's values
        // then return those as key value pair
        const attributes = Object.entries(rawAttributes).reduce((acc, [attrName, value]) => {
            const attrMetadata = entityMetadata.attributes.find(attr => attr.name === attrName);
            if (!attrMetadata) {
                throw new Error(`Failed to reverse transform attribute ${attrName}, it was referenced in schema but it is not known to entity ${entityClass.name}`);
            }
            if ((attrMetadata.type === 'Boolean' || attrMetadata.type === 'Number') &&
                value) {
                acc[attrName] = JSON.parse(value);
            }
            else {
                acc[attrName] = value;
            }
            return acc;
        }, {});
        return attributes;
    }
}
exports.EntityTransformer = EntityTransformer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW50aXR5LXRyYW5zZm9ybWVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY2xhc3Nlcy90cmFuc2Zvcm1lci9lbnRpdHktdHJhbnNmb3JtZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNkNBQTRFO0FBQzVFLHlEQUF3RDtBQUN4RCwyREFBcUQ7QUFFckQseURBQW9FO0FBRXBFOztHQUVHO0FBQ0gsTUFBYSxpQkFBa0IsU0FBUSxrQ0FBZTtJQUNwRCxZQUFZLFVBQXNCO1FBQ2hDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUNwQixDQUFDO0lBQ0Q7Ozs7T0FJRztJQUNILGdCQUFnQixDQUNkLFdBQWlDLEVBQ2pDLFlBQWtDLEVBQ2xDLGVBQW9EOztRQUVwRCxNQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3RFLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQztZQUNsQyxTQUFTLEVBQUUsZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFFLFNBQVM7WUFDckMsU0FBUyxFQUFFLHVCQUFjLENBQUMsUUFBUTtZQUNsQyxNQUFNLEVBQUUsUUFBUTtZQUNoQixVQUFVLEVBQUUsY0FBYyxDQUFDLElBQUk7WUFDL0IsVUFBVSxFQUFFLElBQUk7WUFDaEIsSUFBSSxFQUFFLFlBQVk7U0FDbkIsQ0FBQyxDQUFDO1FBRUgsTUFBTSwwQkFBMEIsR0FBRyxjQUFjLENBQUMsVUFBVTthQUN6RCxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDNUIsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTFCLE1BQU0sNkJBQTZCLEdBQUcsTUFBTSxDQUFDLElB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Q25JLENBQUM7YUFDSDtZQUVELElBQ0UsQ0FBQyxZQUFZLENBQUMsSUFBSSxLQUFLLFNBQVMsSUFBSSxZQUFZLENBQUMsSUFBSSxLQUFLLFFBQVEsQ0FBQztnQkFDbkUsS0FBSyxFQUNMO2dCQUNBLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ25DO2lCQUFNO2dCQUNMLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxLQUFLLENBQUM7YUFDdkI7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFDRCxFQUF5QixDQUMxQixDQUFDO1FBQ0YsT0FBTyxVQUFVLENBQUM7SUFDcEIsQ0FBQztDQUNGO0FBbkpELDhDQW1KQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RG9jdW1lbnRDbGllbnRUeXBlc30gZnJvbSAnQHR5cGVkb3JtL2RvY3VtZW50LWNsaWVudCc7XG5pbXBvcnQge0R5bmFtb0VudGl0eSwgRW50aXR5VGFyZ2V0LCBUUkFOU0ZPUk1fVFlQRX0gZnJvbSAnQHR5cGVkb3JtL2NvbW1vbic7XG5pbXBvcnQge3BsYWluVG9DbGFzc0Zyb21FeGlzdH0gZnJvbSAnY2xhc3MtdHJhbnNmb3JtZXInO1xuaW1wb3J0IHt1blBhcnNlS2V5fSBmcm9tICcuLi8uLi9oZWxwZXJzL3VucGFyc2Uta2V5JztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbi9jb25uZWN0aW9uJztcbmltcG9ydCB7QmFzZVRyYW5zZm9ybWVyLCBNZXRhZGF0YU9wdGlvbnN9IGZyb20gJy4vYmFzZS10cmFuc2Zvcm1lcic7XG5cbi8qKlxuICogTm90ZTogVG8gdXNlIGFueSBvZiB0aGUgYmFzZSB0cmFuc2Zvcm1lciBtZXRob2RzLCB0aGlzIGRlZmF1bHQgZW50aXR5IHRyYW5zZm9ybWVyIHNob3VsZCBiZSB1c2VkXG4gKi9cbmV4cG9ydCBjbGFzcyBFbnRpdHlUcmFuc2Zvcm1lciBleHRlbmRzIEJhc2VUcmFuc2Zvcm1lciB7XG4gIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb246IENvbm5lY3Rpb24pIHtcbiAgICBzdXBlcihjb25uZWN0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydHMgZHluYW1vZGIgZW50aXR5IHRvIG1vZGVsIGRlZmluZWQgaW4gZW50aXRpZXNcbiAgICogQHBhcmFtIGVudGl0eUNsYXNzIC0gVGFyZ2V0IGNsYXNzIHRvIGxvb2sgbWV0YWRhdGEgb2ZmXG4gICAqIEBwYXJhbSBkeW5hbW9FbnRpdHlcbiAgICovXG4gIGZyb21EeW5hbW9FbnRpdHk8RW50aXR5PihcbiAgICBlbnRpdHlDbGFzczogRW50aXR5VGFyZ2V0PEVudGl0eT4sXG4gICAgZHluYW1vRW50aXR5OiBEeW5hbW9FbnRpdHk8RW50aXR5PixcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBQaWNrPE1ldGFkYXRhT3B0aW9ucywgJ3JlcXVlc3RJZCc+XG4gICk6IEVudGl0eSB7XG4gICAgY29uc3QgZW50aXR5TWV0YWRhdGEgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0RW50aXR5QnlUYXJnZXQoZW50aXR5Q2xhc3MpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLlJFU1BPTlNFLFxuICAgICAgcHJlZml4OiAnQmVmb3JlJyxcbiAgICAgIGVudGl0eU5hbWU6IGVudGl0eU1ldGFkYXRhLm5hbWUsXG4gICAgICBwcmltYXJ5S2V5OiBudWxsLFxuICAgICAgYm9keTogZHluYW1vRW50aXR5LFxuICAgIH0pO1xuXG4gICAgY29uc3QgdmFuaWxsYUF0dHJpYnV0ZXNUb0luY2x1ZGUgPSBlbnRpdHlNZXRhZGF0YS5hdHRyaWJ1dGVzXG4gICAgICAuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaGlkZGVuKVxuICAgICAgLm1hcChhdHRyID0+IGF0dHIubmFtZSk7XG5cbiAgICBjb25zdCBwcmltYXJ5S2V5QXR0cmlidXRlc1RvSW5jbHVkZSA9IE9iamVjdC5rZXlzKFxuICAgICAgZW50aXR5TWV0YWRhdGEuc2NoZW1hLnByaW1hcnlLZXkuYXR0cmlidXRlc1xuICAgICkuZmlsdGVyKGF0dHIgPT4gIXZhbmlsbGFBdHRyaWJ1dGVzVG9JbmNsdWRlLmluY2x1ZGVzKGF0dHIpKTtcblxuICAgIGNvbnN0IGVudGl0eUludGVybmFsQXR0cmlidXRlS2V5cyA9IGVudGl0eU1ldGFkYXRhLmludGVybmFsQXR0cmlidXRlcy5tYXAoXG4gICAgICBhdHRyID0+IGF0dHIubmFtZVxuICAgICk7XG4gICAgY29uc3QgZW50aXR5SGlkZGVuQXR0cmlidXRlS2V5cyA9IGVudGl0eU1ldGFkYXRhLmF0dHJpYnV0ZXNcbiAgICAgIC5maWx0ZXIoYXR0ciA9PiBhdHRyLmhpZGRlbilcbiAgICAgIC5tYXAoYXR0ciA9PiBhdHRyLm5hbWUpO1xuXG4gICAgY29uc3QgZW50aXR5TWV0YWRhdGFTY2hlbWFJbmRleGVzID0gZW50aXR5TWV0YWRhdGEuc2NoZW1hLmluZGV4ZXMgPz8ge307XG4gICAgY29uc3QgaW5kZXhBdHRyaWJ1dGVzVG9JbmNsdWRlID0gT2JqZWN0LmtleXMoZW50aXR5TWV0YWRhdGFTY2hlbWFJbmRleGVzKVxuICAgICAgLm1hcChrZXkgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZW50aXR5TWV0YWRhdGFTY2hlbWFJbmRleGVzW2tleV0uYXR0cmlidXRlcyA/PyB7fSk7XG4gICAgICB9KVxuICAgICAgLmZsYXQoKVxuICAgICAgLmZpbHRlcihhdHRyID0+ICF2YW5pbGxhQXR0cmlidXRlc1RvSW5jbHVkZS5pbmNsdWRlcyhhdHRyKSk7XG5cbiAgICBjb25zdCBwbGFpbkVudGl0eUF0dHJpYnV0ZXMgPSBPYmplY3Qua2V5cyhkeW5hbW9FbnRpdHkgYXMgb2JqZWN0KS5yZWR1Y2UoXG4gICAgICAoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgLy8gaWYgYW55IG9mIHRoZSBiZWxvdyBjb25kaXRpb25zIGFyZSB0cnVlLCBza2lwIGFkZGluZyBnaXZlbiBhdHRyaWJ1dGUgZnJvbSByZXR1cm5pbmcgcmVzcG9uc2VcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzVG9JbmNsdWRlLmluY2x1ZGVzKGtleSkgfHxcbiAgICAgICAgICBpbmRleEF0dHJpYnV0ZXNUb0luY2x1ZGUuaW5jbHVkZXMoa2V5KSB8fFxuICAgICAgICAgIGVudGl0eUludGVybmFsQXR0cmlidXRlS2V5cy5pbmNsdWRlcyhrZXkpIHx8XG4gICAgICAgICAgZW50aXR5SGlkZGVuQXR0cmlidXRlS2V5cy5pbmNsdWRlcyhrZXkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH1cbiAgICAgICAgKGFjYyBhcyBhbnkpW2tleV0gPSAoZHluYW1vRW50aXR5IGFzIGFueSlba2V5XTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyBPYmplY3RcbiAgICApO1xuXG4gICAgLy8gZ2V0IHJlZmxlY3RlZCBjb25zdHJ1Y3RvciB0byBhdm9pZCBpbml0aWFsaXphdGlvbiBpc3N1ZXMgd2l0aCBjdXN0b20gY29uc3RydWN0b3JcbiAgICBjb25zdCByZWZsZWN0ZWRDb25zdHJ1Y3RvciA9IFJlZmxlY3QuY29uc3RydWN0KE9iamVjdCwgW10sIGVudGl0eUNsYXNzKTtcblxuICAgIC8vIFBlcmZvcm0gYSBkZWVwLWNvcHkgb2YgaXRlbSByZXR1cm5lZCBieSBEb2N1bWVudCBjbGllbnQgdG8gZHJvcCBhbGwgdGhlIGN1c3RvbSBmdW5jdGlvbiB0eXBlc1xuXG4gICAgLy8gQ3VzdG9tIHR5cGVzIGFyZSBlbWl0dGVkIGJ5IHRoZSBkb2N1bWVudCBjbGllbnQgaW4gY2FzZXMgd2hlcmUgZHluYW1vZGIgaXRlbSB3YXMgY3JlYXRlZCBvdXRzaWRlIHRoZSBqcyBlY29zeXN0ZW0uXG4gICAgLy8gVG8gY29ycmVjdGx5IGRlc2VyaWFsaXplIHRoZSByZXR1cm5lZCB2YWx1ZXMgdG8gdGhlIHJlbGV2YW50IEVudGl0eSwgaXQgbmVlZHMgdG8gYmUgaW4gYSBwbGFpbiBKU09OIHN0cnVjdHVyZS5cbiAgICAvLyBpLmUgRHluYW1vREIgaXRzZWxmIHN1cHBvcnRzIGBTdHJpbmdTZXRgIHR5cGUgYnV0IHNpbmNlIGpzIGRvZXNuJ3QgaGF2ZSBhIGBTdHJpbmdTZXRgIGFzIGEgbmF0aXZlIHR5cGUsXG4gICAgLy8gVGhlcmVmb3JlLCBEb2N1bWVudENsaWVudCB3cmFwcyBpdCBhcyBhIGN1c3RvbSBgU2V0YCB0eXBlIHdoaWNoIG11c3QgYmUgdHVybmVkIGludG8gaXRzIEpTT04gZm9ybSBiZWZvcmUgaXQgY2FuXG4gICAgLy8gYmUgY29ycmVjdGx5IGRlc2VyaWFsaXplZCBieSBgY2xhc3MtdHJhbnNmb3JtZXJgLlxuXG4gICAgY29uc3QgZGVzZXJpYWxpemVkRW50aXR5QXR0cmlidXRlcyA9IEpTT04ucGFyc2UoXG4gICAgICBKU09OLnN0cmluZ2lmeShwbGFpbkVudGl0eUF0dHJpYnV0ZXMpXG4gICAgKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybWVkRW50aXR5ID0gcGxhaW5Ub0NsYXNzRnJvbUV4aXN0KFxuICAgICAgcmVmbGVjdGVkQ29uc3RydWN0b3IsXG4gICAgICBkZXNlcmlhbGl6ZWRFbnRpdHlBdHRyaWJ1dGVzXG4gICAgKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLlJFU1BPTlNFLFxuICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgZW50aXR5TmFtZTogZW50aXR5TWV0YWRhdGEubmFtZSxcbiAgICAgIHByaW1hcnlLZXk6IG51bGwsXG4gICAgICBib2R5OiB0cmFuc2Zvcm1lZEVudGl0eSxcbiAgICB9KTtcblxuICAgIHJldHVybiB0cmFuc2Zvcm1lZEVudGl0eTtcbiAgfVxuXG4gIGZyb21EeW5hbW9LZXlUb0F0dHJpYnV0ZXM8RW50aXR5PihcbiAgICBlbnRpdHlDbGFzczogRW50aXR5VGFyZ2V0PEVudGl0eT4sXG4gICAgZHluYW1vS2V5OiBEb2N1bWVudENsaWVudFR5cGVzLktleVxuICApIHtcbiAgICBjb25zdCBlbnRpdHlNZXRhZGF0YSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG4gICAgY29uc3QgcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSBlbnRpdHlNZXRhZGF0YS5zY2hlbWEucHJpbWFyeUtleS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IGludGVycG9sYXRpb25zID1cbiAgICAgIGVudGl0eU1ldGFkYXRhLnNjaGVtYS5wcmltYXJ5S2V5Py5tZXRhZGF0YT8uX2ludGVycG9sYXRpb25zID8/IHt9O1xuXG4gICAgY29uc3QgcmF3QXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKHByaW1hcnlLZXlBdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBba2V5TmFtZSwga2V5UGF0dGVybl0pID0+IHtcbiAgICAgICAgY29uc3QgdW5QYXJzZWQgPSB1blBhcnNlS2V5KFxuICAgICAgICAgIGtleVBhdHRlcm4sXG4gICAgICAgICAgZHluYW1vS2V5W2tleU5hbWVdLFxuICAgICAgICAgIGludGVycG9sYXRpb25zW2tleU5hbWVdID8/IFtdXG4gICAgICAgICk7XG4gICAgICAgIGFjYyA9IHsuLi5hY2MsIC4uLnVuUGFyc2VkfTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG5cbiAgICAvLyBsaWtlIGNvbXBhcmUgYWN0dWFsIGtleSB3aXRoIHRoZSBzY2hlbWEgYW5kIHB1bGwgb3V0IHZhcmlhYmxlIG5hbWUgYW4gaXQncyB2YWx1ZXNcbiAgICAvLyB0aGVuIHJldHVybiB0aG9zZSBhcyBrZXkgdmFsdWUgcGFpclxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IE9iamVjdC5lbnRyaWVzKHJhd0F0dHJpYnV0ZXMpLnJlZHVjZShcbiAgICAgIChhY2MsIFthdHRyTmFtZSwgdmFsdWVdOiBbc3RyaW5nLCBhbnldKSA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJNZXRhZGF0YSA9IGVudGl0eU1ldGFkYXRhLmF0dHJpYnV0ZXMuZmluZChcbiAgICAgICAgICBhdHRyID0+IGF0dHIubmFtZSA9PT0gYXR0ck5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWF0dHJNZXRhZGF0YSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gcmV2ZXJzZSB0cmFuc2Zvcm0gYXR0cmlidXRlICR7YXR0ck5hbWV9LCBpdCB3YXMgcmVmZXJlbmNlZCBpbiBzY2hlbWEgYnV0IGl0IGlzIG5vdCBrbm93biB0byBlbnRpdHkgJHtlbnRpdHlDbGFzcy5uYW1lfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgIChhdHRyTWV0YWRhdGEudHlwZSA9PT0gJ0Jvb2xlYW4nIHx8IGF0dHJNZXRhZGF0YS50eXBlID09PSAnTnVtYmVyJykgJiZcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICApIHtcbiAgICAgICAgICBhY2NbYXR0ck5hbWVdID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWNjW2F0dHJOYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMgUmVjb3JkPHN0cmluZywgYW55PlxuICAgICk7XG4gICAgcmV0dXJuIGF0dHJpYnV0ZXM7XG4gIH1cbn1cbiJdfQ==