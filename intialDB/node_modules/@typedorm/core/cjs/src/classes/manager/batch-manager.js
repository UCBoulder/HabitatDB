"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BatchManager = exports.REQUEST_TYPE = void 0;
const document_client_batch_transformer_1 = require("../transformer/document-client-batch-transformer");
const p_limit_1 = __importDefault(require("p-limit"));
const common_1 = require("@typedorm/common");
const is_empty_object_1 = require("../../helpers/is-empty-object");
const get_unique_request_id_1 = require("../../helpers/get-unique-request-id");
var REQUEST_TYPE;
(function (REQUEST_TYPE) {
    REQUEST_TYPE["TRANSACT_WRITE"] = "TRANSACT_WRITE";
    REQUEST_TYPE["BATCH_WRITE"] = "BATCH_WRITE";
    REQUEST_TYPE["BATCH_READ"] = "BATCH_READ";
})(REQUEST_TYPE = exports.REQUEST_TYPE || (exports.REQUEST_TYPE = {}));
class BatchManager {
    constructor(connection) {
        this.connection = connection;
        this.limit = (0, p_limit_1.default)(common_1.BATCH_WRITE_CONCURRENCY_LIMIT);
        this._dcBatchTransformer = new document_client_batch_transformer_1.DocumentClientBatchTransformer(connection);
        this.resetErrorQueue();
    }
    /**
     * Writes all given items to dynamodb using either batch or transaction api.
     * _Note_: Transaction api is always used when item being written is using a unique attribute
     * @param batch
     */
    write(batch, options, metadataOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.resetErrorQueue();
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            if (options === null || options === void 0 ? void 0 : options.requestsConcurrencyLimit) {
                this.limit = (0, p_limit_1.default)(options === null || options === void 0 ? void 0 : options.requestsConcurrencyLimit);
            }
            this.connection.logger.logInfo({
                requestId,
                scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                log: `Running a batch write request for ${batch.items.length} items`,
            });
            // 0. transform batch request
            const { batchWriteRequestMapItems, lazyTransactionWriteItemListLoaderItems, transactionListItems, metadata, } = this._dcBatchTransformer.toDynamoWriteBatchItems(batch, {
                requestId,
            });
            // 1.1. get transaction write items limits
            const transactionRequests = transactionListItems.map(({ rawInput, transformedInput }) => {
                // make all promises in pLimitable so their concurrency can be controlled properly
                return this.toLimited(() => this.connection.transactionManger.writeRaw(transformedInput, {
                    requestId,
                    returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                }), 
                // return original item when failed to process
                rawInput, REQUEST_TYPE.TRANSACT_WRITE);
            });
            // 1.2. get all the lazy loaded promises
            // these are basically all the delete requests that uses unique keys
            const lazyTransactionRequests = lazyTransactionWriteItemListLoaderItems.map(({ rawInput, transformedInput }) => {
                return this.toLimited(() => __awaiter(this, void 0, void 0, function* () {
                    const existingItem = yield this.connection.entityManager.findOne(transformedInput.entityClass, transformedInput.primaryKeyAttributes, undefined, {
                        requestId,
                        returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                    const deleteTransactionItemList = transformedInput.lazyLoadTransactionWriteItems(existingItem);
                    return this.connection.transactionManger.writeRaw(deleteTransactionItemList, {
                        requestId,
                        returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                }), 
                // default item to return if failed to process
                rawInput, REQUEST_TYPE.TRANSACT_WRITE);
            });
            // 1.3. get all batch toLimited promises
            const batchRequests = batchWriteRequestMapItems.map(batchRequestMap => {
                return this.toLimited(() => __awaiter(this, void 0, void 0, function* () {
                    return this.connection.documentClient.batchWrite({
                        RequestItems: Object.assign({}, batchRequestMap),
                        ReturnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                }), 
                // for batch requests this returning item will be transformed to
                // original input items later
                batchRequestMap, REQUEST_TYPE.BATCH_WRITE);
            });
            const allRequests = [
                ...transactionRequests,
                ...lazyTransactionRequests,
                ...batchRequests,
            ];
            // 2. wait for all promises to finish
            const responses = yield Promise.all(allRequests);
            // log stats
            responses.forEach((response, index) => {
                if (response.ConsumedCapacity) {
                    this.connection.logger.logStats({
                        scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                        requestId,
                        requestSegment: index,
                        statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                        consumedCapacityData: response.ConsumedCapacity,
                    });
                }
            });
            // 3. run retry attempts
            // process all unprocessed items recursively until all are either done
            // or reached the retry limit
            const unprocessedItems = yield this.recursiveHandleBatchWriteItemsResponse(responses, 0, // initially set the attempts counter to 0,
            options, {
                requestId,
                returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
            });
            // 4.1. reverse parse all failed inputs to original user inputs
            // filter or drop any empty values
            const transformedUnprocessedItems = unprocessedItems.flatMap((unprocessedItemInput) => this._dcBatchTransformer.toWriteBatchInputList(unprocessedItemInput, metadata));
            // 4.2. reverse parse all unprocessed inputs to original user inputs
            // parse failed items to original input
            const failedItemsOriginalInput = this._errorQueue.flatMap(item => {
                if (item.requestType === REQUEST_TYPE.BATCH_WRITE) {
                    return this._dcBatchTransformer.toWriteBatchInputList(item.requestInput, metadata);
                }
                else if (item.requestType === REQUEST_TYPE.TRANSACT_WRITE) {
                    return item.requestInput;
                }
                else {
                    throw new Error('Unsupported request type, if this continues please file an issue on github');
                }
            });
            // 5. return unProcessable or failed items to user
            return {
                unprocessedItems: transformedUnprocessedItems,
                failedItems: failedItemsOriginalInput,
            };
        });
    }
    /**
     * Reads all items given in batch with default eventually consistent read type
     * _Note_: Returned items are not guaranteed to be in the same sequence as requested
     */
    read(batch, options, metadataOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.resetErrorQueue();
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            if (options === null || options === void 0 ? void 0 : options.requestsConcurrencyLimit) {
                this.limit = (0, p_limit_1.default)(options === null || options === void 0 ? void 0 : options.requestsConcurrencyLimit);
            }
            this.connection.logger.logInfo({
                requestId,
                scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                log: `Running a batch read request for ${batch.items.length} items`,
            });
            // 0. transform batch request
            const { batchRequestItemsList, metadata } = this._dcBatchTransformer.toDynamoReadBatchItems(batch, {
                requestId,
            });
            // 1. get items requests with concurrency applied
            const batchRequests = batchRequestItemsList.map(batchRequestItems => {
                return this.toLimited(() => __awaiter(this, void 0, void 0, function* () {
                    return this.connection.documentClient.batchGet({
                        RequestItems: Object.assign({}, batchRequestItems),
                        ReturnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                }), batchRequestItems, REQUEST_TYPE.BATCH_READ);
            });
            // 2. wait for all promises to finish, either failed or hit the limit
            const initialResponses = yield Promise.all(batchRequests);
            // log stats
            initialResponses.forEach((response, index) => {
                if (response.ConsumedCapacity) {
                    this.connection.logger.logStats({
                        scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                        requestId,
                        requestSegment: index,
                        statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                        consumedCapacityData: response.ConsumedCapacity,
                    });
                }
            });
            // 3. run retries
            const { items, unprocessedItemsList } = yield this.recursiveHandleBatchReadItemsResponse(initialResponses, 0, options, [], {
                requestId,
                returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
            });
            // 4.1 transform responses to look like model
            const transformedItems = items.map(item => {
                const entityPhysicalName = item[common_1.INTERNAL_ENTITY_ATTRIBUTE.ENTITY_NAME];
                if (!entityPhysicalName) {
                    this.connection.logger.logWarn({
                        requestId,
                        scope: common_1.MANAGER_NAME.ENTITY_MANAGER,
                        log: `Item ${JSON.stringify(item)} is not known to TypeDORM there for transform was not run`,
                    });
                    return item;
                }
                const { target } = this.connection.getEntityByPhysicalName(entityPhysicalName);
                return this._dcBatchTransformer.fromDynamoEntity(target, item, {
                    requestId,
                });
            });
            // 4.2 transform unprocessed items
            const unprocessedTransformedItems = unprocessedItemsList === null || unprocessedItemsList === void 0 ? void 0 : unprocessedItemsList.flatMap((item) => this._dcBatchTransformer.toReadBatchInputList(item, metadata));
            // 4.3 transform failed items
            const failedTransformedItems = this._errorQueue.flatMap(item => {
                this.connection.logger.logError({
                    requestId,
                    scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                    log: item.error,
                });
                return this._dcBatchTransformer.toReadBatchInputList(item.requestInput, metadata);
            });
            // 5. return all items
            return {
                items: transformedItems !== null && transformedItems !== void 0 ? transformedItems : [],
                unprocessedItems: unprocessedTransformedItems !== null && unprocessedTransformedItems !== void 0 ? unprocessedTransformedItems : [],
                failedItems: failedTransformedItems !== null && failedTransformedItems !== void 0 ? failedTransformedItems : [],
            };
        });
    }
    /**
     * Recursively parse batch requests until either all items are in or has reached retry limit
     * @param batchWriteItemOutputItems
     */
    recursiveHandleBatchWriteItemsResponse(batchWriteItemOutputItems, totalAttemptsSoFar, options, metadataOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const unProcessedListItems = batchWriteItemOutputItems
                .filter((response) => response.UnprocessedItems && !(0, is_empty_object_1.isEmptyObject)(response.UnprocessedItems))
                .map(item => item.UnprocessedItems);
            // if there are no unprocessed items, return
            if (!unProcessedListItems.length) {
                return unProcessedListItems;
            }
            // abort when reached max attempts count
            // if no retry attempts are given, use default attempts limit
            if (totalAttemptsSoFar ===
                ((_a = options === null || options === void 0 ? void 0 : options.maxRetryAttempts) !== null && _a !== void 0 ? _a : common_1.BATCH_WRITE_MAX_ALLOWED_ATTEMPTS)) {
                this.connection.logger.logInfo({
                    scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                    log: `Reached max allowed attempts ${totalAttemptsSoFar}, aborting...`,
                    requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                });
                return unProcessedListItems;
            }
            // backoff for x ms before retrying for unprocessed items
            yield this.waitForExponentialBackoff(totalAttemptsSoFar, undefined, metadataOptions);
            // organize unprocessed items into single "tableName-item" map
            const sortedUnprocessedItems = unProcessedListItems.reduce((acc, unprocessedItems) => {
                Object.entries(unprocessedItems).forEach(([tableName, unprocessedRequests]) => {
                    if (!acc[tableName]) {
                        acc[tableName] = [];
                    }
                    // merge all items by tableName
                    acc[tableName] = [...acc[tableName], ...unprocessedRequests];
                });
                return acc;
            }, {});
            const batchRequestsItems = this._dcBatchTransformer.mapTableWriteItemsToBatchWriteItems(sortedUnprocessedItems);
            // apply limit on all parallel requests
            const batchRequests = batchRequestsItems.map(batchRequestMap => {
                return this.toLimited(() => __awaiter(this, void 0, void 0, function* () {
                    return this.connection.documentClient.batchWrite({
                        RequestItems: Object.assign({}, batchRequestMap),
                        ReturnItemCollectionMetrics: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                }), batchRequestMap, REQUEST_TYPE.BATCH_WRITE);
            });
            const batchRequestsResponses = (yield Promise.all(batchRequests));
            // log stats
            batchRequestsResponses.forEach((response, index) => {
                if (response.ConsumedCapacity) {
                    this.connection.logger.logStats({
                        requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                        scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                        requestSegment: index,
                        statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                        consumedCapacityData: response.ConsumedCapacity,
                    });
                }
            });
            return this.recursiveHandleBatchWriteItemsResponse(batchRequestsResponses, ++totalAttemptsSoFar, options, metadataOptions);
        });
    }
    recursiveHandleBatchReadItemsResponse(batchReadItemOutputList, totalAttemptsSoFar, options, responsesStore = [], metadataOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // save all responses from api to responses store
            const batchReadResponses = batchReadItemOutputList
                .filter((response) => response.Responses && !(0, is_empty_object_1.isEmptyObject)(response.Responses))
                .map((response) => response.Responses);
            if (batchReadResponses.length) {
                const mappedResponsesItemList = batchReadResponses.flatMap(batchGetResponse => this.mapBatchGetResponseToItemList(batchGetResponse));
                responsesStore.push(...mappedResponsesItemList);
            }
            // recursively process all unprocessed items
            const unprocessedItemsList = batchReadItemOutputList.filter((response) => response.UnprocessedKeys && !(0, is_empty_object_1.isEmptyObject)(response.UnprocessedKeys));
            // if all items were successfully processed, return
            if (!unprocessedItemsList.length) {
                return {
                    items: responsesStore,
                };
            }
            // abort when reached max attempt count
            // if no retries provided use default BATCH_READ_MAX_ALLOWED_ATTEMPTS
            if (totalAttemptsSoFar ===
                ((_a = options === null || options === void 0 ? void 0 : options.maxRetryAttempts) !== null && _a !== void 0 ? _a : common_1.BATCH_READ_MAX_ALLOWED_ATTEMPTS)) {
                this.connection.logger.logInfo({
                    requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                    scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                    log: `Reached max allowed attempts ${totalAttemptsSoFar}, aborting...`,
                });
                return {
                    items: responsesStore,
                    unprocessedItemsList: unprocessedItemsList.map(item => item.UnprocessedKeys),
                };
            }
            // backoff before retrying
            yield this.waitForExponentialBackoff(totalAttemptsSoFar, undefined, metadataOptions);
            // aggregate all requests by table name
            const sortedUnprocessedItems = unprocessedItemsList.reduce((acc, { UnprocessedKeys }) => {
                Object.entries(UnprocessedKeys).forEach(([tableName, unprocessedRequests]) => {
                    var _a;
                    if (!acc[tableName]) {
                        acc[tableName] = {
                            Keys: [],
                        };
                    }
                    (_a = acc[tableName].Keys) === null || _a === void 0 ? void 0 : _a.push(...unprocessedRequests.Keys);
                });
                return acc;
            }, {});
            const batchRequestsItemsList = this._dcBatchTransformer.mapTableReadItemsToBatchReadItems(sortedUnprocessedItems);
            // apply limit
            const batchRequests = batchRequestsItemsList.map(batchRequestMap => {
                return this.toLimited(() => __awaiter(this, void 0, void 0, function* () {
                    return this.connection.documentClient.batchGet({
                        RequestItems: Object.assign({}, batchRequestMap),
                        ReturnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    });
                }), batchRequestMap, REQUEST_TYPE.BATCH_READ);
            });
            const batchRequestsResponses = (yield Promise.all(batchRequests));
            // log stats
            batchRequestsResponses.forEach((response, index) => {
                if (response.ConsumedCapacity) {
                    this.connection.logger.logStats({
                        requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                        scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                        requestSegment: index,
                        statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                        consumedCapacityData: response.ConsumedCapacity,
                    });
                }
            });
            return this.recursiveHandleBatchReadItemsResponse(batchRequestsResponses, ++totalAttemptsSoFar, options, 
            // responses store containing responses from all requests
            responsesStore, metadataOptions);
        });
    }
    resetErrorQueue() {
        this._errorQueue = [];
    }
    mapBatchGetResponseToItemList(batchGetResponse) {
        return Object.entries(batchGetResponse).flatMap(([, batchResponse]) => batchResponse);
    }
    /**
     * Returns promise that is Promise.all safe and also can be managed by p-limit
     * @param anyPromiseFactory
     * @param requestItem // request item input
     * @param requestType // request type
     */
    toLimited(anyPromiseFactory, requestItem, requestType) {
        return this.limit(() => __awaiter(this, void 0, void 0, function* () {
            try {
                const response = yield anyPromiseFactory();
                return response;
            }
            catch (err) {
                this._errorQueue.push({
                    requestInput: requestItem,
                    error: err,
                    requestType,
                });
                // when any error is thrown while promises are running, return it
                // instead of throwing it to have other requests run as is without
                // interruptions
                return err;
            }
        }));
    }
    waitForExponentialBackoff(attempts, multiplicationFactor = 1, metadataOptions) {
        multiplicationFactor = multiplicationFactor < 1 ? 1 : multiplicationFactor;
        return new Promise(resolve => {
            const backoffTime = this.exponentialBackoff(attempts, multiplicationFactor);
            this.connection.logger.logInfo({
                requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                scope: common_1.MANAGER_NAME.BATCH_MANAGER,
                log: `${attempts} attempts so far, sleeping ${backoffTime}ms before retrying...`,
            });
            setTimeout(resolve, backoffTime);
        });
    }
    /**
     * @param attempts
     */
    exponentialBackoff(attempts, multiplicationFactor) {
        return Math.floor(Math.random() * 10 * Math.pow(2, attempts || 1) * multiplicationFactor);
    }
}
exports.BatchManager = BatchManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmF0Y2gtbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2NsYXNzZXMvbWFuYWdlci9iYXRjaC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUdBLHdHQUFnRztBQUNoRyxzREFBNkI7QUFDN0IsNkNBTzBCO0FBQzFCLG1FQUE0RDtBQUc1RCwrRUFBdUU7QUFFdkUsSUFBWSxZQUlYO0FBSkQsV0FBWSxZQUFZO0lBQ3RCLGlEQUFpQyxDQUFBO0lBQ2pDLDJDQUEyQixDQUFBO0lBQzNCLHlDQUF5QixDQUFBO0FBQzNCLENBQUMsRUFKVyxZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQUl2QjtBQWdDRCxNQUFhLFlBQVk7SUFTdkIsWUFBb0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUZsQyxVQUFLLEdBQUcsSUFBQSxpQkFBTSxFQUFDLHNDQUE2QixDQUFDLENBQUM7UUFHcEQsSUFBSSxDQUFDLG1CQUFtQixHQUFHLElBQUksa0VBQThCLENBQUMsVUFBVSxDQUFDLENBQUM7UUFDMUUsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0csS0FBSyxDQUNULEtBQWlCLEVBQ2pCLE9BQWtDLEVBQ2xDLGVBQWlDOztZQUVqQyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDdkIsTUFBTSxTQUFTLEdBQUcsSUFBQSwwQ0FBa0IsRUFBQyxlQUFlLGFBQWYsZUFBZSx1QkFBZixlQUFlLENBQUUsU0FBUyxDQUFDLENBQUM7WUFFakUsSUFBSSxPQUFPLGFBQVAsT0FBTyx1QkFBUCxPQUFPLENBQUUsd0JBQXdCLEVBQUU7Z0JBQ3JDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBQSxpQkFBTSxFQUFDLE9BQU8sYUFBUCxPQUFPLHVCQUFQLE9BQU8sQ0FBRSx3QkFB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QyxrQkFBa0IsQ0FDekMsUUFBUSxFQUNSLG9CQUFvQixDQUNyQixDQUFDO1lBQ0YsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDO2dCQUM3QixTQUFTLEVBQUUsZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFFLFNBQVM7Z0JBQ3JDLEtBQUssRUFBRSxxQkFBWSxDQUFDLGFBQWE7Z0JBQ2pDLEdBQUcsRUFBRSxHQUFHLFFBQVEsOEJBQThCLFdBQVcsdUJBQXVCO2FBQ2pGLENBQUMsQ0FBQztZQUNILFVBQVUsQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLENBQUM7UUFDbkMsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxrQkFBa0IsQ0FBQyxRQUFnQixFQUFFLG9CQUE0QjtRQUN2RSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQ2YsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxRQUFRLElBQUksQ0FBQyxDQUFDLEdBQUcsb0JBQW9CLENBQ3ZFLENBQUM7SUFDSixDQUFDO0NBQ0Y7QUEvbEJELG9DQStsQkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RvY3VtZW50Q2xpZW50VHlwZXN9IGZyb20gJ0B0eXBlZG9ybS9kb2N1bWVudC1jbGllbnQnO1xuaW1wb3J0IHtXcml0ZUJhdGNofSBmcm9tICcuLi9iYXRjaC93cml0ZS1iYXRjaCc7XG5pbXBvcnQge0Nvbm5lY3Rpb259IGZyb20gJy4uL2Nvbm5lY3Rpb24vY29ubmVjdGlvbic7XG5pbXBvcnQge0RvY3VtZW50Q2xpZW50QmF0Y2hUcmFuc2Zvcm1lcn0gZnJvbSAnLi4vdHJhbnNmb3JtZXIvZG9jdW1lbnQtY2xpZW50LWJhdGNoLXRyYW5zZm9ybWVyJztcbmltcG9ydCBwTGltaXQgZnJvbSAncC1saW1pdCc7XG5pbXBvcnQge1xuICBCQVRDSF9SRUFEX01BWF9BTExPV0VEX0FUVEVNUFRTLFxuICBCQVRDSF9XUklURV9DT05DVVJSRU5DWV9MSU1JVCxcbiAgQkFUQ0hfV1JJVEVfTUFYX0FMTE9XRURfQVRURU1QVFMsXG4gIElOVEVSTkFMX0VOVElUWV9BVFRSSUJVVEUsXG4gIE1BTkFHRVJfTkFNRSxcbiAgU1RBVFNfVFlQRSxcbn0gZnJvbSAnQHR5cGVkb3JtL2NvbW1vbic7XG5pbXBvcnQge2lzRW1wdHlPYmplY3R9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtZW1wdHktb2JqZWN0JztcbmltcG9ydCB7UmVhZEJhdGNofSBmcm9tICcuLi9iYXRjaC9yZWFkLWJhdGNoJztcbmltcG9ydCB7TWV0YWRhdGFPcHRpb25zfSBmcm9tICcuLi90cmFuc2Zvcm1lci9iYXNlLXRyYW5zZm9ybWVyJztcbmltcG9ydCB7Z2V0VW5pcXVlUmVxdWVzdElkfSBmcm9tICcuLi8uLi9oZWxwZXJzL2dldC11bmlxdWUtcmVxdWVzdC1pZCc7XG5cbmV4cG9ydCBlbnVtIFJFUVVFU1RfVFlQRSB7XG4gIFRSQU5TQUNUX1dSSVRFID0gJ1RSQU5TQUNUX1dSSVRFJyxcbiAgQkFUQ0hfV1JJVEUgPSAnQkFUQ0hfV1JJVEUnLFxuICBCQVRDSF9SRUFEID0gJ0JBVENIX1JFQUQnLFxufVxuXG4vKipcbiAqIEJhdGNoIG1hbmFnZXIgd3JpdGUgb3B0aW9uc1xuICovXG5leHBvcnQgdHlwZSBCYXRjaE1hbmFnZXJXcml0ZU9wdGlvbnMgPSBCYXRjaE1hbmFnZUJhc2VPcHRpb25zO1xuXG4vKipcbiAqIEJhdGNoIG1hbmFnZXIgcmVhZCBvcHRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIEJhdGNoTWFuYWdlclJlYWRPcHRpb25zID0gQmF0Y2hNYW5hZ2VCYXNlT3B0aW9ucztcblxuZXhwb3J0IGludGVyZmFjZSBCYXRjaE1hbmFnZUJhc2VPcHRpb25zIHtcbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgcmV0cmllcyB0byBwZXJmb3JtIGJlZm9yZSByZXR1cm5pbmcgdG8gY2xpZW50XG4gICAqIEBkZWZhdWx0IEJBVENIX1dSSVRFX01BWF9BTExPV0VEX0FUVEVNUFRTXG4gICAqL1xuICBtYXhSZXRyeUF0dGVtcHRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNYXggbnVtYmVyIG9mIHJlcXVlc3RzIHRvIHJ1biBpbiBwYXJhbGxlbFxuICAgKiBAZGVmYXVsdCBCQVRDSF9XUklURV9DT05DVVJSRU5DWV9MSU1JVFxuICAgKi9cbiAgcmVxdWVzdHNDb25jdXJyZW5jeUxpbWl0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBFeHBvbmVudGlhbCBiYWNrb2ZmIG11bHRpcGxpY2F0aW9uIGZhY3RvciB0byBhcHBseSBvbiBiYWNrIG9mZiBhbGdvcml0aG1cbiAgICogQGRlZmF1bHQgMVxuICAgKi9cbiAgYmFja29mZk11bHRpcGxpY2F0aW9uRmFjdG9yPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgQmF0Y2hNYW5hZ2VyIHtcbiAgcHJpdmF0ZSBfZGNCYXRjaFRyYW5zZm9ybWVyOiBEb2N1bWVudENsaWVudEJhdGNoVHJhbnNmb3JtZXI7XG4gIHByaXZhdGUgX2Vycm9yUXVldWU6IHtcbiAgICByZXF1ZXN0SW5wdXQ6IGFueTtcbiAgICBlcnJvcjogRXJyb3I7XG4gICAgcmVxdWVzdFR5cGU6IFJFUVVFU1RfVFlQRTtcbiAgfVtdO1xuICBwcml2YXRlIGxpbWl0ID0gcExpbWl0KEJBVENIX1dSSVRFX0NPTkNVUlJFTkNZX0xJTUlUKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbm5lY3Rpb246IENvbm5lY3Rpb24pIHtcbiAgICB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIgPSBuZXcgRG9jdW1lbnRDbGllbnRCYXRjaFRyYW5zZm9ybWVyKGNvbm5lY3Rpb24pO1xuICAgIHRoaXMucmVzZXRFcnJvclF1ZXVlKCk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIGFsbCBnaXZlbiBpdGVtcyB0byBkeW5hbW9kYiB1c2luZyBlaXRoZXIgYmF0Y2ggb3IgdHJhbnNhY3Rpb24gYXBpLlxuICAgKiBfTm90ZV86IFRyYW5zYWN0aW9uIGFwaSBpcyBhbHdheXMgdXNlZCB3aGVuIGl0ZW0gYmVpbmcgd3JpdHRlbiBpcyB1c2luZyBhIHVuaXF1ZSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIGJhdGNoXG4gICAqL1xuICBhc3luYyB3cml0ZShcbiAgICBiYXRjaDogV3JpdGVCYXRjaCxcbiAgICBvcHRpb25zPzogQmF0Y2hNYW5hZ2VyV3JpdGVPcHRpb25zLFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApIHtcbiAgICB0aGlzLnJlc2V0RXJyb3JRdWV1ZSgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IGdldFVuaXF1ZVJlcXVlc3RJZChtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCk7XG5cbiAgICBpZiAob3B0aW9ucz8ucmVxdWVzdHNDb25jdXJyZW5jeUxpbWl0KSB7XG4gICAgICB0aGlzLmxpbWl0ID0gcExpbWl0KG9wdGlvbnM/LnJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgIGxvZzogYFJ1bm5pbmcgYSBiYXRjaCB3cml0ZSByZXF1ZXN0IGZvciAke2JhdGNoLml0ZW1zLmxlbmd0aH0gaXRlbXNgLFxuICAgIH0pO1xuXG4gICAgLy8gMC4gdHJhbnNmb3JtIGJhdGNoIHJlcXVlc3RcbiAgICBjb25zdCB7XG4gICAgICBiYXRjaFdyaXRlUmVxdWVzdE1hcEl0ZW1zLFxuICAgICAgbGF6eVRyYW5zYWN0aW9uV3JpdGVJdGVtTGlzdExvYWRlckl0ZW1zLFxuICAgICAgdHJhbnNhY3Rpb25MaXN0SXRlbXMsXG4gICAgICBtZXRhZGF0YSxcbiAgICB9ID0gdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLnRvRHluYW1vV3JpdGVCYXRjaEl0ZW1zKGJhdGNoLCB7XG4gICAgICByZXF1ZXN0SWQsXG4gICAgfSk7XG5cbiAgICAvLyAxLjEuIGdldCB0cmFuc2FjdGlvbiB3cml0ZSBpdGVtcyBsaW1pdHNcbiAgICBjb25zdCB0cmFuc2FjdGlvblJlcXVlc3RzID0gdHJhbnNhY3Rpb25MaXN0SXRlbXMubWFwKFxuICAgICAgKHtyYXdJbnB1dCwgdHJhbnNmb3JtZWRJbnB1dH0pID0+IHtcbiAgICAgICAgLy8gbWFrZSBhbGwgcHJvbWlzZXMgaW4gcExpbWl0YWJsZSBzbyB0aGVpciBjb25jdXJyZW5jeSBjYW4gYmUgY29udHJvbGxlZCBwcm9wZXJseVxuICAgICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgICAgKCkgPT5cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi50cmFuc2FjdGlvbk1hbmdlci53cml0ZVJhdyh0cmFuc2Zvcm1lZElucHV0LCB7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgLy8gcmV0dXJuIG9yaWdpbmFsIGl0ZW0gd2hlbiBmYWlsZWQgdG8gcHJvY2Vzc1xuICAgICAgICAgIHJhd0lucHV0LFxuICAgICAgICAgIFJFUVVFU1RfVFlQRS5UUkFOU0FDVF9XUklURVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyAxLjIuIGdldCBhbGwgdGhlIGxhenkgbG9hZGVkIHByb21pc2VzXG4gICAgLy8gdGhlc2UgYXJlIGJhc2ljYWxseSBhbGwgdGhlIGRlbGV0ZSByZXF1ZXN0cyB0aGF0IHVzZXMgdW5pcXVlIGtleXNcbiAgICBjb25zdCBsYXp5VHJhbnNhY3Rpb25SZXF1ZXN0cyA9IGxhenlUcmFuc2FjdGlvbldyaXRlSXRlbUxpc3RMb2FkZXJJdGVtcy5tYXAoXG4gICAgICAoe3Jhd0lucHV0LCB0cmFuc2Zvcm1lZElucHV0fSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdJdGVtID0gYXdhaXQgdGhpcy5jb25uZWN0aW9uLmVudGl0eU1hbmFnZXIuZmluZE9uZShcbiAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJbnB1dC5lbnRpdHlDbGFzcyxcbiAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJbnB1dC5wcmltYXJ5S2V5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgZGVsZXRlVHJhbnNhY3Rpb25JdGVtTGlzdCA9XG4gICAgICAgICAgICAgIHRyYW5zZm9ybWVkSW5wdXQubGF6eUxvYWRUcmFuc2FjdGlvbldyaXRlSXRlbXMoZXhpc3RpbmdJdGVtKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdGlvbi50cmFuc2FjdGlvbk1hbmdlci53cml0ZVJhdyhcbiAgICAgICAgICAgICAgZGVsZXRlVHJhbnNhY3Rpb25JdGVtTGlzdCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICByZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIC8vIGRlZmF1bHQgaXRlbSB0byByZXR1cm4gaWYgZmFpbGVkIHRvIHByb2Nlc3NcbiAgICAgICAgICByYXdJbnB1dCxcbiAgICAgICAgICBSRVFVRVNUX1RZUEUuVFJBTlNBQ1RfV1JJVEVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gMS4zLiBnZXQgYWxsIGJhdGNoIHRvTGltaXRlZCBwcm9taXNlc1xuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHMgPSBiYXRjaFdyaXRlUmVxdWVzdE1hcEl0ZW1zLm1hcChiYXRjaFJlcXVlc3RNYXAgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudG9MaW1pdGVkKFxuICAgICAgICBhc3luYyAoKSA9PlxuICAgICAgICAgIHRoaXMuY29ubmVjdGlvbi5kb2N1bWVudENsaWVudC5iYXRjaFdyaXRlKHtcbiAgICAgICAgICAgIFJlcXVlc3RJdGVtczogey4uLmJhdGNoUmVxdWVzdE1hcH0sXG4gICAgICAgICAgICBSZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgfSksXG4gICAgICAgIC8vIGZvciBiYXRjaCByZXF1ZXN0cyB0aGlzIHJldHVybmluZyBpdGVtIHdpbGwgYmUgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gb3JpZ2luYWwgaW5wdXQgaXRlbXMgbGF0ZXJcbiAgICAgICAgYmF0Y2hSZXF1ZXN0TWFwLFxuICAgICAgICBSRVFVRVNUX1RZUEUuQkFUQ0hfV1JJVEVcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhbGxSZXF1ZXN0cyA9IFtcbiAgICAgIC4uLnRyYW5zYWN0aW9uUmVxdWVzdHMsXG4gICAgICAuLi5sYXp5VHJhbnNhY3Rpb25SZXF1ZXN0cyxcbiAgICAgIC4uLmJhdGNoUmVxdWVzdHMsXG4gICAgXSBhc1xuICAgICAgfCBQcm9taXNlPERvY3VtZW50Q2xpZW50VHlwZXMuVHJhbnNhY3RXcml0ZUl0ZW1PdXRwdXQ+W11cbiAgICAgIHwgUHJvbWlzZTxEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtT3V0cHV0PltdO1xuXG4gICAgLy8gMi4gd2FpdCBmb3IgYWxsIHByb21pc2VzIHRvIGZpbmlzaFxuICAgIGNvbnN0IHJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGFsbFJlcXVlc3RzKTtcblxuICAgIC8vIGxvZyBzdGF0c1xuICAgIHJlc3BvbnNlcy5mb3JFYWNoKChyZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5Db25zdW1lZENhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nU3RhdHMoe1xuICAgICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmVxdWVzdFNlZ21lbnQ6IGluZGV4LFxuICAgICAgICAgIHN0YXRzVHlwZTogU1RBVFNfVFlQRS5DT05TVU1FRF9DQVBBQ0lUWSxcbiAgICAgICAgICBjb25zdW1lZENhcGFjaXR5RGF0YTogcmVzcG9uc2UuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAzLiBydW4gcmV0cnkgYXR0ZW1wdHNcbiAgICAvLyBwcm9jZXNzIGFsbCB1bnByb2Nlc3NlZCBpdGVtcyByZWN1cnNpdmVseSB1bnRpbCBhbGwgYXJlIGVpdGhlciBkb25lXG4gICAgLy8gb3IgcmVhY2hlZCB0aGUgcmV0cnkgbGltaXRcbiAgICBjb25zdCB1bnByb2Nlc3NlZEl0ZW1zID0gYXdhaXQgdGhpcy5yZWN1cnNpdmVIYW5kbGVCYXRjaFdyaXRlSXRlbXNSZXNwb25zZShcbiAgICAgIHJlc3BvbnNlcyxcbiAgICAgIDAsIC8vIGluaXRpYWxseSBzZXQgdGhlIGF0dGVtcHRzIGNvdW50ZXIgdG8gMCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyA0LjEuIHJldmVyc2UgcGFyc2UgYWxsIGZhaWxlZCBpbnB1dHMgdG8gb3JpZ2luYWwgdXNlciBpbnB1dHNcbiAgICAvLyBmaWx0ZXIgb3IgZHJvcCBhbnkgZW1wdHkgdmFsdWVzXG4gICAgY29uc3QgdHJhbnNmb3JtZWRVbnByb2Nlc3NlZEl0ZW1zID0gdW5wcm9jZXNzZWRJdGVtcy5mbGF0TWFwKFxuICAgICAgKHVucHJvY2Vzc2VkSXRlbUlucHV0OiBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtUmVxdWVzdE1hcCkgPT5cbiAgICAgICAgdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLnRvV3JpdGVCYXRjaElucHV0TGlzdChcbiAgICAgICAgICB1bnByb2Nlc3NlZEl0ZW1JbnB1dCxcbiAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICApXG4gICAgKTtcblxuICAgIC8vIDQuMi4gcmV2ZXJzZSBwYXJzZSBhbGwgdW5wcm9jZXNzZWQgaW5wdXRzIHRvIG9yaWdpbmFsIHVzZXIgaW5wdXRzXG4gICAgLy8gcGFyc2UgZmFpbGVkIGl0ZW1zIHRvIG9yaWdpbmFsIGlucHV0XG4gICAgY29uc3QgZmFpbGVkSXRlbXNPcmlnaW5hbElucHV0ID0gdGhpcy5fZXJyb3JRdWV1ZS5mbGF0TWFwKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0ucmVxdWVzdFR5cGUgPT09IFJFUVVFU1RfVFlQRS5CQVRDSF9XUklURSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLnRvV3JpdGVCYXRjaElucHV0TGlzdChcbiAgICAgICAgICBpdGVtLnJlcXVlc3RJbnB1dCxcbiAgICAgICAgICBtZXRhZGF0YVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChpdGVtLnJlcXVlc3RUeXBlID09PSBSRVFVRVNUX1RZUEUuVFJBTlNBQ1RfV1JJVEUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW0ucmVxdWVzdElucHV0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdVbnN1cHBvcnRlZCByZXF1ZXN0IHR5cGUsIGlmIHRoaXMgY29udGludWVzIHBsZWFzZSBmaWxlIGFuIGlzc3VlIG9uIGdpdGh1YidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDUuIHJldHVybiB1blByb2Nlc3NhYmxlIG9yIGZhaWxlZCBpdGVtcyB0byB1c2VyXG4gICAgcmV0dXJuIHtcbiAgICAgIHVucHJvY2Vzc2VkSXRlbXM6IHRyYW5zZm9ybWVkVW5wcm9jZXNzZWRJdGVtcyxcbiAgICAgIGZhaWxlZEl0ZW1zOiBmYWlsZWRJdGVtc09yaWdpbmFsSW5wdXQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgaXRlbXMgZ2l2ZW4gaW4gYmF0Y2ggd2l0aCBkZWZhdWx0IGV2ZW50dWFsbHkgY29uc2lzdGVudCByZWFkIHR5cGVcbiAgICogX05vdGVfOiBSZXR1cm5lZCBpdGVtcyBhcmUgbm90IGd1YXJhbnRlZWQgdG8gYmUgaW4gdGhlIHNhbWUgc2VxdWVuY2UgYXMgcmVxdWVzdGVkXG4gICAqL1xuICBhc3luYyByZWFkKFxuICAgIGJhdGNoOiBSZWFkQmF0Y2gsXG4gICAgb3B0aW9ucz86IEJhdGNoTWFuYWdlclJlYWRPcHRpb25zLFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApIHtcbiAgICB0aGlzLnJlc2V0RXJyb3JRdWV1ZSgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IGdldFVuaXF1ZVJlcXVlc3RJZChtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCk7XG5cbiAgICBpZiAob3B0aW9ucz8ucmVxdWVzdHNDb25jdXJyZW5jeUxpbWl0KSB7XG4gICAgICB0aGlzLmxpbWl0ID0gcExpbWl0KG9wdGlvbnM/LnJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgIHJlcXVlc3RJZCxcbiAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgIGxvZzogYFJ1bm5pbmcgYSBiYXRjaCByZWFkIHJlcXVlc3QgZm9yICR7YmF0Y2guaXRlbXMubGVuZ3RofSBpdGVtc2AsXG4gICAgfSk7XG5cbiAgICAvLyAwLiB0cmFuc2Zvcm0gYmF0Y2ggcmVxdWVzdFxuICAgIGNvbnN0IHtiYXRjaFJlcXVlc3RJdGVtc0xpc3QsIG1ldGFkYXRhfSA9XG4gICAgICB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9EeW5hbW9SZWFkQmF0Y2hJdGVtcyhiYXRjaCwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICB9KTtcblxuICAgIC8vIDEuIGdldCBpdGVtcyByZXF1ZXN0cyB3aXRoIGNvbmN1cnJlbmN5IGFwcGxpZWRcbiAgICBjb25zdCBiYXRjaFJlcXVlc3RzID0gYmF0Y2hSZXF1ZXN0SXRlbXNMaXN0Lm1hcChiYXRjaFJlcXVlc3RJdGVtcyA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgIGFzeW5jICgpID0+XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmRvY3VtZW50Q2xpZW50LmJhdGNoR2V0KHtcbiAgICAgICAgICAgIFJlcXVlc3RJdGVtczogey4uLmJhdGNoUmVxdWVzdEl0ZW1zfSxcbiAgICAgICAgICAgIFJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgYmF0Y2hSZXF1ZXN0SXRlbXMsXG4gICAgICAgIFJFUVVFU1RfVFlQRS5CQVRDSF9SRUFEXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgLy8gMi4gd2FpdCBmb3IgYWxsIHByb21pc2VzIHRvIGZpbmlzaCwgZWl0aGVyIGZhaWxlZCBvciBoaXQgdGhlIGxpbWl0XG4gICAgY29uc3QgaW5pdGlhbFJlc3BvbnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKGJhdGNoUmVxdWVzdHMpO1xuXG4gICAgLy8gbG9nIHN0YXRzXG4gICAgaW5pdGlhbFJlc3BvbnNlcy5mb3JFYWNoKChyZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5Db25zdW1lZENhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nU3RhdHMoe1xuICAgICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmVxdWVzdFNlZ21lbnQ6IGluZGV4LFxuICAgICAgICAgIHN0YXRzVHlwZTogU1RBVFNfVFlQRS5DT05TVU1FRF9DQVBBQ0lUWSxcbiAgICAgICAgICBjb25zdW1lZENhcGFjaXR5RGF0YTogcmVzcG9uc2UuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyAzLiBydW4gcmV0cmllc1xuICAgIGNvbnN0IHtpdGVtcywgdW5wcm9jZXNzZWRJdGVtc0xpc3R9ID1cbiAgICAgIGF3YWl0IHRoaXMucmVjdXJzaXZlSGFuZGxlQmF0Y2hSZWFkSXRlbXNSZXNwb25zZShcbiAgICAgICAgaW5pdGlhbFJlc3BvbnNlcyxcbiAgICAgICAgMCxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgW10sXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgLy8gNC4xIHRyYW5zZm9ybSByZXNwb25zZXMgdG8gbG9vayBsaWtlIG1vZGVsXG4gICAgY29uc3QgdHJhbnNmb3JtZWRJdGVtcyA9IGl0ZW1zLm1hcChpdGVtID0+IHtcbiAgICAgIGNvbnN0IGVudGl0eVBoeXNpY2FsTmFtZSA9IGl0ZW1bSU5URVJOQUxfRU5USVRZX0FUVFJJQlVURS5FTlRJVFlfTkFNRV07XG4gICAgICBpZiAoIWVudGl0eVBoeXNpY2FsTmFtZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1dhcm4oe1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLkVOVElUWV9NQU5BR0VSLFxuICAgICAgICAgIGxvZzogYEl0ZW0gJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIGl0ZW1cbiAgICAgICAgICApfSBpcyBub3Qga25vd24gdG8gVHlwZURPUk0gdGhlcmUgZm9yIHRyYW5zZm9ybSB3YXMgbm90IHJ1bmAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge3RhcmdldH0gPVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZ2V0RW50aXR5QnlQaHlzaWNhbE5hbWUoZW50aXR5UGh5c2ljYWxOYW1lKTtcbiAgICAgIHJldHVybiB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIuZnJvbUR5bmFtb0VudGl0eSh0YXJnZXQsIGl0ZW0sIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgfSk7XG4gICAgfSkgYXMgdW5rbm93bltdO1xuXG4gICAgLy8gNC4yIHRyYW5zZm9ybSB1bnByb2Nlc3NlZCBpdGVtc1xuICAgIGNvbnN0IHVucHJvY2Vzc2VkVHJhbnNmb3JtZWRJdGVtcyA9IHVucHJvY2Vzc2VkSXRlbXNMaXN0Py5mbGF0TWFwKFxuICAgICAgKGl0ZW06IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRSZXF1ZXN0TWFwKSA9PlxuICAgICAgICB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9SZWFkQmF0Y2hJbnB1dExpc3QoaXRlbSwgbWV0YWRhdGEpXG4gICAgKTtcblxuICAgIC8vIDQuMyB0cmFuc2Zvcm0gZmFpbGVkIGl0ZW1zXG4gICAgY29uc3QgZmFpbGVkVHJhbnNmb3JtZWRJdGVtcyA9IHRoaXMuX2Vycm9yUXVldWUuZmxhdE1hcChpdGVtID0+IHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nRXJyb3Ioe1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgbG9nOiBpdGVtLmVycm9yLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLnRvUmVhZEJhdGNoSW5wdXRMaXN0KFxuICAgICAgICBpdGVtLnJlcXVlc3RJbnB1dCxcbiAgICAgICAgbWV0YWRhdGFcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyA1LiByZXR1cm4gYWxsIGl0ZW1zXG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1zOiB0cmFuc2Zvcm1lZEl0ZW1zID8/IFtdLFxuICAgICAgdW5wcm9jZXNzZWRJdGVtczogdW5wcm9jZXNzZWRUcmFuc2Zvcm1lZEl0ZW1zID8/IFtdLFxuICAgICAgZmFpbGVkSXRlbXM6IGZhaWxlZFRyYW5zZm9ybWVkSXRlbXMgPz8gW10sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWN1cnNpdmVseSBwYXJzZSBiYXRjaCByZXF1ZXN0cyB1bnRpbCBlaXRoZXIgYWxsIGl0ZW1zIGFyZSBpbiBvciBoYXMgcmVhY2hlZCByZXRyeSBsaW1pdFxuICAgKiBAcGFyYW0gYmF0Y2hXcml0ZUl0ZW1PdXRwdXRJdGVtc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWN1cnNpdmVIYW5kbGVCYXRjaFdyaXRlSXRlbXNSZXNwb25zZShcbiAgICBiYXRjaFdyaXRlSXRlbU91dHB1dEl0ZW1zOiBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtT3V0cHV0TGlzdCxcbiAgICB0b3RhbEF0dGVtcHRzU29GYXI6IG51bWJlcixcbiAgICBvcHRpb25zPzogQmF0Y2hNYW5hZ2VyV3JpdGVPcHRpb25zLFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApOiBQcm9taXNlPERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hXcml0ZUl0ZW1SZXF1ZXN0TWFwTGlzdD4ge1xuICAgIGNvbnN0IHVuUHJvY2Vzc2VkTGlzdEl0ZW1zID0gYmF0Y2hXcml0ZUl0ZW1PdXRwdXRJdGVtc1xuICAgICAgLmZpbHRlcihcbiAgICAgICAgKHJlc3BvbnNlOiBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtT3V0cHV0KSA9PlxuICAgICAgICAgIHJlc3BvbnNlLlVucHJvY2Vzc2VkSXRlbXMgJiYgIWlzRW1wdHlPYmplY3QocmVzcG9uc2UuVW5wcm9jZXNzZWRJdGVtcylcbiAgICAgIClcbiAgICAgIC5tYXAoaXRlbSA9PiBpdGVtLlVucHJvY2Vzc2VkSXRlbXMhKTtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyB1bnByb2Nlc3NlZCBpdGVtcywgcmV0dXJuXG4gICAgaWYgKCF1blByb2Nlc3NlZExpc3RJdGVtcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1blByb2Nlc3NlZExpc3RJdGVtcztcbiAgICB9XG5cbiAgICAvLyBhYm9ydCB3aGVuIHJlYWNoZWQgbWF4IGF0dGVtcHRzIGNvdW50XG4gICAgLy8gaWYgbm8gcmV0cnkgYXR0ZW1wdHMgYXJlIGdpdmVuLCB1c2UgZGVmYXVsdCBhdHRlbXB0cyBsaW1pdFxuICAgIGlmIChcbiAgICAgIHRvdGFsQXR0ZW1wdHNTb0ZhciA9PT1cbiAgICAgIChvcHRpb25zPy5tYXhSZXRyeUF0dGVtcHRzID8/IEJBVENIX1dSSVRFX01BWF9BTExPV0VEX0FUVEVNUFRTKVxuICAgICkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICBsb2c6IGBSZWFjaGVkIG1heCBhbGxvd2VkIGF0dGVtcHRzICR7dG90YWxBdHRlbXB0c1NvRmFyfSwgYWJvcnRpbmcuLi5gLFxuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdW5Qcm9jZXNzZWRMaXN0SXRlbXM7XG4gICAgfVxuXG4gICAgLy8gYmFja29mZiBmb3IgeCBtcyBiZWZvcmUgcmV0cnlpbmcgZm9yIHVucHJvY2Vzc2VkIGl0ZW1zXG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgdG90YWxBdHRlbXB0c1NvRmFyLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgbWV0YWRhdGFPcHRpb25zXG4gICAgKTtcblxuICAgIC8vIG9yZ2FuaXplIHVucHJvY2Vzc2VkIGl0ZW1zIGludG8gc2luZ2xlIFwidGFibGVOYW1lLWl0ZW1cIiBtYXBcbiAgICBjb25zdCBzb3J0ZWRVbnByb2Nlc3NlZEl0ZW1zID0gdW5Qcm9jZXNzZWRMaXN0SXRlbXMucmVkdWNlKFxuICAgICAgKGFjYywgdW5wcm9jZXNzZWRJdGVtcykgPT4ge1xuICAgICAgICBPYmplY3QuZW50cmllcyh1bnByb2Nlc3NlZEl0ZW1zISkuZm9yRWFjaChcbiAgICAgICAgICAoW3RhYmxlTmFtZSwgdW5wcm9jZXNzZWRSZXF1ZXN0c10pID0+IHtcbiAgICAgICAgICAgIGlmICghYWNjW3RhYmxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgYWNjW3RhYmxlTmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1lcmdlIGFsbCBpdGVtcyBieSB0YWJsZU5hbWVcbiAgICAgICAgICAgIGFjY1t0YWJsZU5hbWVdID0gWy4uLmFjY1t0YWJsZU5hbWVdLCAuLi51bnByb2Nlc3NlZFJlcXVlc3RzXTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaFdyaXRlSXRlbVJlcXVlc3RNYXBcbiAgICApO1xuXG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0c0l0ZW1zID1cbiAgICAgIHRoaXMuX2RjQmF0Y2hUcmFuc2Zvcm1lci5tYXBUYWJsZVdyaXRlSXRlbXNUb0JhdGNoV3JpdGVJdGVtcyhcbiAgICAgICAgc29ydGVkVW5wcm9jZXNzZWRJdGVtc1xuICAgICAgKTtcblxuICAgIC8vIGFwcGx5IGxpbWl0IG9uIGFsbCBwYXJhbGxlbCByZXF1ZXN0c1xuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHMgPSBiYXRjaFJlcXVlc3RzSXRlbXMubWFwKGJhdGNoUmVxdWVzdE1hcCA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgIGFzeW5jICgpID0+XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmRvY3VtZW50Q2xpZW50LmJhdGNoV3JpdGUoe1xuICAgICAgICAgICAgUmVxdWVzdEl0ZW1zOiB7Li4uYmF0Y2hSZXF1ZXN0TWFwfSxcbiAgICAgICAgICAgIFJldHVybkl0ZW1Db2xsZWN0aW9uTWV0cmljczpcbiAgICAgICAgICAgICAgbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICAgIH0pLFxuICAgICAgICBiYXRjaFJlcXVlc3RNYXAsXG4gICAgICAgIFJFUVVFU1RfVFlQRS5CQVRDSF9XUklURVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHNSZXNwb25zZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBiYXRjaFJlcXVlc3RzXG4gICAgKSkgYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaFdyaXRlSXRlbU91dHB1dExpc3Q7XG5cbiAgICAvLyBsb2cgc3RhdHNcbiAgICBiYXRjaFJlcXVlc3RzUmVzcG9uc2VzLmZvckVhY2goKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLkNvbnN1bWVkQ2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dTdGF0cyh7XG4gICAgICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLkJBVENIX01BTkFHRVIsXG4gICAgICAgICAgcmVxdWVzdFNlZ21lbnQ6IGluZGV4LFxuICAgICAgICAgIHN0YXRzVHlwZTogU1RBVFNfVFlQRS5DT05TVU1FRF9DQVBBQ0lUWSxcbiAgICAgICAgICBjb25zdW1lZENhcGFjaXR5RGF0YTogcmVzcG9uc2UuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVIYW5kbGVCYXRjaFdyaXRlSXRlbXNSZXNwb25zZShcbiAgICAgIGJhdGNoUmVxdWVzdHNSZXNwb25zZXMsXG4gICAgICArK3RvdGFsQXR0ZW1wdHNTb0ZhcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBtZXRhZGF0YU9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyByZWN1cnNpdmVIYW5kbGVCYXRjaFJlYWRJdGVtc1Jlc3BvbnNlKFxuICAgIGJhdGNoUmVhZEl0ZW1PdXRwdXRMaXN0OiBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoR2V0SXRlbU91dHB1dExpc3QsXG4gICAgdG90YWxBdHRlbXB0c1NvRmFyOiBudW1iZXIsXG4gICAgb3B0aW9ucz86IEJhdGNoTWFuYWdlclJlYWRPcHRpb25zLFxuICAgIHJlc3BvbnNlc1N0b3JlOiBEb2N1bWVudENsaWVudFR5cGVzLkl0ZW1MaXN0ID0gW10sXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6IFByb21pc2U8e1xuICAgIGl0ZW1zOiBEb2N1bWVudENsaWVudFR5cGVzLkl0ZW1MaXN0O1xuICAgIHVucHJvY2Vzc2VkSXRlbXNMaXN0PzogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldFJlcXVlc3RNYXBMaXN0O1xuICB9PiB7XG4gICAgLy8gc2F2ZSBhbGwgcmVzcG9uc2VzIGZyb20gYXBpIHRvIHJlc3BvbnNlcyBzdG9yZVxuICAgIGNvbnN0IGJhdGNoUmVhZFJlc3BvbnNlcyA9IGJhdGNoUmVhZEl0ZW1PdXRwdXRMaXN0XG4gICAgICAuZmlsdGVyKFxuICAgICAgICAocmVzcG9uc2U6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0KSA9PlxuICAgICAgICAgIHJlc3BvbnNlLlJlc3BvbnNlcyAmJiAhaXNFbXB0eU9iamVjdChyZXNwb25zZS5SZXNwb25zZXMpXG4gICAgICApXG4gICAgICAubWFwKFxuICAgICAgICAocmVzcG9uc2U6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0KSA9PlxuICAgICAgICAgIHJlc3BvbnNlLlJlc3BvbnNlcyFcbiAgICAgICk7XG4gICAgaWYgKGJhdGNoUmVhZFJlc3BvbnNlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1hcHBlZFJlc3BvbnNlc0l0ZW1MaXN0ID0gYmF0Y2hSZWFkUmVzcG9uc2VzLmZsYXRNYXAoXG4gICAgICAgIGJhdGNoR2V0UmVzcG9uc2UgPT4gdGhpcy5tYXBCYXRjaEdldFJlc3BvbnNlVG9JdGVtTGlzdChiYXRjaEdldFJlc3BvbnNlKVxuICAgICAgKTtcbiAgICAgIHJlc3BvbnNlc1N0b3JlLnB1c2goLi4ubWFwcGVkUmVzcG9uc2VzSXRlbUxpc3QpO1xuICAgIH1cblxuICAgIC8vIHJlY3Vyc2l2ZWx5IHByb2Nlc3MgYWxsIHVucHJvY2Vzc2VkIGl0ZW1zXG4gICAgY29uc3QgdW5wcm9jZXNzZWRJdGVtc0xpc3QgPSBiYXRjaFJlYWRJdGVtT3V0cHV0TGlzdC5maWx0ZXIoXG4gICAgICAocmVzcG9uc2U6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0KSA9PlxuICAgICAgICByZXNwb25zZS5VbnByb2Nlc3NlZEtleXMgJiYgIWlzRW1wdHlPYmplY3QocmVzcG9uc2UuVW5wcm9jZXNzZWRLZXlzKVxuICAgICk7XG5cbiAgICAvLyBpZiBhbGwgaXRlbXMgd2VyZSBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkLCByZXR1cm5cbiAgICBpZiAoIXVucHJvY2Vzc2VkSXRlbXNMaXN0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IHJlc3BvbnNlc1N0b3JlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBhYm9ydCB3aGVuIHJlYWNoZWQgbWF4IGF0dGVtcHQgY291bnRcbiAgICAvLyBpZiBubyByZXRyaWVzIHByb3ZpZGVkIHVzZSBkZWZhdWx0IEJBVENIX1JFQURfTUFYX0FMTE9XRURfQVRURU1QVFNcbiAgICBpZiAoXG4gICAgICB0b3RhbEF0dGVtcHRzU29GYXIgPT09XG4gICAgICAob3B0aW9ucz8ubWF4UmV0cnlBdHRlbXB0cyA/PyBCQVRDSF9SRUFEX01BWF9BTExPV0VEX0FUVEVNUFRTKVxuICAgICkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICBsb2c6IGBSZWFjaGVkIG1heCBhbGxvd2VkIGF0dGVtcHRzICR7dG90YWxBdHRlbXB0c1NvRmFyfSwgYWJvcnRpbmcuLi5gLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGl0ZW1zOiByZXNwb25zZXNTdG9yZSxcbiAgICAgICAgdW5wcm9jZXNzZWRJdGVtc0xpc3Q6IHVucHJvY2Vzc2VkSXRlbXNMaXN0Lm1hcChcbiAgICAgICAgICBpdGVtID0+IGl0ZW0uVW5wcm9jZXNzZWRLZXlzIVxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBiYWNrb2ZmIGJlZm9yZSByZXRyeWluZ1xuICAgIGF3YWl0IHRoaXMud2FpdEZvckV4cG9uZW50aWFsQmFja29mZihcbiAgICAgIHRvdGFsQXR0ZW1wdHNTb0ZhcixcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIG1ldGFkYXRhT3B0aW9uc1xuICAgICk7XG5cbiAgICAvLyBhZ2dyZWdhdGUgYWxsIHJlcXVlc3RzIGJ5IHRhYmxlIG5hbWVcbiAgICBjb25zdCBzb3J0ZWRVbnByb2Nlc3NlZEl0ZW1zID0gdW5wcm9jZXNzZWRJdGVtc0xpc3QucmVkdWNlKFxuICAgICAgKGFjYywge1VucHJvY2Vzc2VkS2V5c306IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0KSA9PiB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKFVucHJvY2Vzc2VkS2V5cyEpLmZvckVhY2goXG4gICAgICAgICAgKFt0YWJsZU5hbWUsIHVucHJvY2Vzc2VkUmVxdWVzdHNdKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWFjY1t0YWJsZU5hbWVdKSB7XG4gICAgICAgICAgICAgIGFjY1t0YWJsZU5hbWVdID0ge1xuICAgICAgICAgICAgICAgIEtleXM6IFtdLFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhY2NbdGFibGVOYW1lXS5LZXlzPy5wdXNoKC4uLnVucHJvY2Vzc2VkUmVxdWVzdHMuS2V5cyk7XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRSZXF1ZXN0TWFwXG4gICAgKTtcblxuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHNJdGVtc0xpc3QgPVxuICAgICAgdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLm1hcFRhYmxlUmVhZEl0ZW1zVG9CYXRjaFJlYWRJdGVtcyhcbiAgICAgICAgc29ydGVkVW5wcm9jZXNzZWRJdGVtc1xuICAgICAgKTtcblxuICAgIC8vIGFwcGx5IGxpbWl0XG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0cyA9IGJhdGNoUmVxdWVzdHNJdGVtc0xpc3QubWFwKGJhdGNoUmVxdWVzdE1hcCA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgIGFzeW5jICgpID0+XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmRvY3VtZW50Q2xpZW50LmJhdGNoR2V0KHtcbiAgICAgICAgICAgIFJlcXVlc3RJdGVtczogey4uLmJhdGNoUmVxdWVzdE1hcH0sXG4gICAgICAgICAgICBSZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgfSksXG4gICAgICAgIGJhdGNoUmVxdWVzdE1hcCxcbiAgICAgICAgUkVRVUVTVF9UWVBFLkJBVENIX1JFQURcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBiYXRjaFJlcXVlc3RzUmVzcG9uc2VzID0gKGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgYmF0Y2hSZXF1ZXN0c1xuICAgICkpIGFzIERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0TGlzdDtcblxuICAgIC8vIGxvZyBzdGF0c1xuICAgIGJhdGNoUmVxdWVzdHNSZXNwb25zZXMuZm9yRWFjaCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuQ29uc3VtZWRDYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1N0YXRzKHtcbiAgICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgICByZXF1ZXN0U2VnbWVudDogaW5kZXgsXG4gICAgICAgICAgc3RhdHNUeXBlOiBTVEFUU19UWVBFLkNPTlNVTUVEX0NBUEFDSVRZLFxuICAgICAgICAgIGNvbnN1bWVkQ2FwYWNpdHlEYXRhOiByZXNwb25zZS5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZUhhbmRsZUJhdGNoUmVhZEl0ZW1zUmVzcG9uc2UoXG4gICAgICBiYXRjaFJlcXVlc3RzUmVzcG9uc2VzLFxuICAgICAgKyt0b3RhbEF0dGVtcHRzU29GYXIsXG4gICAgICBvcHRpb25zLFxuICAgICAgLy8gcmVzcG9uc2VzIHN0b3JlIGNvbnRhaW5pbmcgcmVzcG9uc2VzIGZyb20gYWxsIHJlcXVlc3RzXG4gICAgICByZXNwb25zZXNTdG9yZSxcbiAgICAgIG1ldGFkYXRhT3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHJlc2V0RXJyb3JRdWV1ZSgpIHtcbiAgICB0aGlzLl9lcnJvclF1ZXVlID0gW107XG4gIH1cblxuICBwcml2YXRlIG1hcEJhdGNoR2V0UmVzcG9uc2VUb0l0ZW1MaXN0KFxuICAgIGJhdGNoR2V0UmVzcG9uc2U6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRSZXNwb25zZU1hcFxuICApIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoYmF0Y2hHZXRSZXNwb25zZSkuZmxhdE1hcChcbiAgICAgIChbLCBiYXRjaFJlc3BvbnNlXSkgPT4gYmF0Y2hSZXNwb25zZVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwcm9taXNlIHRoYXQgaXMgUHJvbWlzZS5hbGwgc2FmZSBhbmQgYWxzbyBjYW4gYmUgbWFuYWdlZCBieSBwLWxpbWl0XG4gICAqIEBwYXJhbSBhbnlQcm9taXNlRmFjdG9yeVxuICAgKiBAcGFyYW0gcmVxdWVzdEl0ZW0gLy8gcmVxdWVzdCBpdGVtIGlucHV0XG4gICAqIEBwYXJhbSByZXF1ZXN0VHlwZSAvLyByZXF1ZXN0IHR5cGVcbiAgICovXG4gIHByaXZhdGUgdG9MaW1pdGVkPFQ+KFxuICAgIGFueVByb21pc2VGYWN0b3J5OiAoKSA9PiBQcm9taXNlPFQ+LFxuICAgIHJlcXVlc3RJdGVtOiBhbnksXG4gICAgcmVxdWVzdFR5cGU6IFJFUVVFU1RfVFlQRVxuICApIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFueVByb21pc2VGYWN0b3J5KCk7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLl9lcnJvclF1ZXVlLnB1c2goe1xuICAgICAgICAgIHJlcXVlc3RJbnB1dDogcmVxdWVzdEl0ZW0sXG4gICAgICAgICAgZXJyb3I6IGVyciBhcyBhbnksXG4gICAgICAgICAgcmVxdWVzdFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyB3aGVuIGFueSBlcnJvciBpcyB0aHJvd24gd2hpbGUgcHJvbWlzZXMgYXJlIHJ1bm5pbmcsIHJldHVybiBpdFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIHRocm93aW5nIGl0IHRvIGhhdmUgb3RoZXIgcmVxdWVzdHMgcnVuIGFzIGlzIHdpdGhvdXRcbiAgICAgICAgLy8gaW50ZXJydXB0aW9uc1xuICAgICAgICByZXR1cm4gZXJyIGFzIFQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHdhaXRGb3JFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgYXR0ZW1wdHM6IG51bWJlcixcbiAgICBtdWx0aXBsaWNhdGlvbkZhY3RvciA9IDEsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICkge1xuICAgIG11bHRpcGxpY2F0aW9uRmFjdG9yID0gbXVsdGlwbGljYXRpb25GYWN0b3IgPCAxID8gMSA6IG11bHRpcGxpY2F0aW9uRmFjdG9yO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGJhY2tvZmZUaW1lID0gdGhpcy5leHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGF0dGVtcHRzLFxuICAgICAgICBtdWx0aXBsaWNhdGlvbkZhY3RvclxuICAgICAgKTtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nSW5mbyh7XG4gICAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgbG9nOiBgJHthdHRlbXB0c30gYXR0ZW1wdHMgc28gZmFyLCBzbGVlcGluZyAke2JhY2tvZmZUaW1lfW1zIGJlZm9yZSByZXRyeWluZy4uLmAsXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZlRpbWUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBhdHRlbXB0c1xuICAgKi9cbiAgcHJpdmF0ZSBleHBvbmVudGlhbEJhY2tvZmYoYXR0ZW1wdHM6IG51bWJlciwgbXVsdGlwbGljYXRpb25GYWN0b3I6IG51bWJlcikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgTWF0aC5yYW5kb20oKSAqIDEwICogTWF0aC5wb3coMiwgYXR0ZW1wdHMgfHwgMSkgKiBtdWx0aXBsaWNhdGlvbkZhY3RvclxuICAgICk7XG4gIH1cbn1cbiJdfQ==