"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScanManager = void 0;
const common_1 = require("@typedorm/common");
const p_limit_1 = __importDefault(require("p-limit"));
const get_unique_request_id_1 = require("../../helpers/get-unique-request-id");
const document_client_scan_transformer_1 = require("../transformer/document-client-scan-transformer");
class ScanManager {
    constructor(connection) {
        this.connection = connection;
        this.limit = (0, p_limit_1.default)(common_1.PARALLEL_SCAN_CONCURRENCY_LIMIT);
        this._dcScanTransformer = new document_client_scan_transformer_1.DocumentClientScanTransformer(connection);
        this.itemsFetchedSoFarTotalParallelCount = 0;
    }
    /**
     * Finds all the matching entity over document client scan operation
     * @param entityClass Entity to find
     * @param findOptions find query options
     * @param metadataOptions Other metadata options
     */
    find(entityClass, findOptions, metadataOptions) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            let response;
            if (findOptions === null || findOptions === void 0 ? void 0 : findOptions.totalSegments) {
                (response = yield this.parallelScan(Object.assign(Object.assign({}, findOptions), { entity: entityClass }))),
                    {
                        requestId,
                        returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                    };
            }
            else {
                response = yield this.scan(Object.assign(Object.assign({}, findOptions), { entity: entityClass }), {
                    requestId,
                    returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                });
            }
            if ((_a = response.unknownItems) === null || _a === void 0 ? void 0 : _a.length) {
                // log warning for items that were skipped form the response
                // These are items that had __en attribute on them but TypeDORM does no longer know about them
                this.connection.logger.logWarn({
                    requestId,
                    scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                    log: `"${response.unknownItems.length}" items were skipped from the response because TypDORM failed to resolve them.`,
                });
            }
            return {
                items: response.items,
                cursor: response.cursor,
            };
        });
    }
    /**
     * Returns total count of all matching items for current entity
     * @param entityClass Entity to count
     * @param scanOptions Extra scan options
     * @param metadataOptions Other metadata options
     */
    count(entityClass, scanOptions, metadataOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            const dynamoScanInput = this._dcScanTransformer.toDynamoScanItem(Object.assign(Object.assign({}, scanOptions), { entity: entityClass, onlyCount: true, select: undefined }), // select projection and count can not be used together
            {
                requestId,
                returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
            });
            const count = yield this._internalRecursiveCount({
                scanInput: dynamoScanInput,
                metadataOptions: {
                    requestId,
                    returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                },
            });
            return count;
        });
    }
    /**
     * Scans all items from dynamo table in parallel while also respecting the max provisioned concurrency
     * @param scanOptions Options for parallel scan
     * @param metadataOptions Additional metadata options
     */
    parallelScan(scanOptions, metadataOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            // start with 0
            this.itemsFetchedSoFarTotalParallelCount = 0;
            const concurrencyLimit = common_1.PARALLEL_SCAN_CONCURRENCY_LIMIT || scanOptions.requestsConcurrencyLimit;
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            if (scanOptions.requestsConcurrencyLimit) {
                this.limit = (0, p_limit_1.default)(scanOptions.requestsConcurrencyLimit);
            }
            const parallelScanOptions = [];
            if ((scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limit) &&
                (scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limitPerSegment) &&
                (scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limit) < (scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limitPerSegment)) {
                throw new common_1.InvalidParallelScanLimitOptionError(scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limit, scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limitPerSegment);
            }
            for (let index = 0; index < scanOptions.totalSegments; index++) {
                // only the cursor for same segment can be applied
                const cursorForSegment = scanOptions.cursor
                    ? scanOptions.cursor[index]
                    : undefined;
                parallelScanOptions.push(Object.assign(Object.assign({}, scanOptions), { cursor: cursorForSegment, segment: index }));
            }
            this.connection.logger.logInfo({
                requestId,
                scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                log: `Running scan in parallel with ${scanOptions.totalSegments} segments.`,
            });
            if (concurrencyLimit < scanOptions.totalSegments) {
                this.connection.logger.logInfo({
                    requestId,
                    scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                    log: `Current request concurrency limit ${concurrencyLimit} is lower than requested segments count ${scanOptions.totalSegments}
        So requests will be run in a batch of ${concurrencyLimit} at a time until all segments ${scanOptions.totalSegments} have processed.`,
                });
            }
            const allPromisesResponse = yield Promise.all(parallelScanOptions.map(options => this.toLimited(this.scan(options, metadataOptions))));
            // merge all responses
            const response = allPromisesResponse.reduce((acc, current, index) => {
                var _a, _b;
                if ((_a = current.items) === null || _a === void 0 ? void 0 : _a.length) {
                    if (!acc.items) {
                        acc.items = [];
                    }
                    acc.items = [...acc.items, ...current.items];
                }
                if ((_b = current.unknownItems) === null || _b === void 0 ? void 0 : _b.length) {
                    if (!acc.unknownItems) {
                        acc.unknownItems = [];
                    }
                    acc.unknownItems = [...acc.unknownItems, ...current.unknownItems];
                }
                if (current.cursor) {
                    if (!acc.cursor) {
                        acc.cursor = {};
                    }
                    acc.cursor = Object.assign(Object.assign({}, acc.cursor), { [index]: current.cursor });
                }
                return acc;
            }, {});
            return response;
        });
    }
    /**
     * Low level scan operation.
     *
     * Perhaps you are looking for higher level ScanManager.find or ScanManager.parallelScan operation
     * @param scanOptions scan options to run scan with
     * @param metadataOptions any other metadata options
     */
    scan(scanOptions, metadataOptions) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const requestId = (0, get_unique_request_id_1.getUniqueRequestId)(metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId);
            const dynamoScanInput = this._dcScanTransformer.toDynamoScanItem(Object.assign(Object.assign({}, scanOptions), { 
                // if requested segmented scan, then apply segment limit or default to limit operator
                limit: (scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.totalSegments)
                    ? scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limitPerSegment
                    : scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limit }), {
                requestId,
                returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
            });
            const response = yield this._internalRecursiveScan({
                scanInput: dynamoScanInput,
                limit: scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.limit,
                cursor: scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.cursor,
                metadataOptions: {
                    requestId,
                    returnConsumedCapacity: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.returnConsumedCapacity,
                },
            });
            const entities = this._dcScanTransformer.fromDynamoScanResponseItemList(response.items);
            if ((scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.entity) && entities.unknownItems) {
                this.connection.logger.logWarn({
                    requestId,
                    scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                    log: `
        There were some items that looked like ${scanOptions === null || scanOptions === void 0 ? void 0 : scanOptions.entity.name} but TypeDORM was unable to convert it back to entity type,
        This can happen when there are items in the table with "${common_1.INTERNAL_ENTITY_ATTRIBUTE.ENTITY_NAME} but was not created by TypeDORM.
        You should remove them or update it to something different."`,
                });
            }
            return {
                items: ((_a = entities.items) === null || _a === void 0 ? void 0 : _a.length) ? entities.items : undefined,
                unknownItems: ((_b = entities.unknownItems) === null || _b === void 0 ? void 0 : _b.length)
                    ? entities.unknownItems
                    : undefined,
                cursor: response.cursor,
            };
        });
    }
    /**
     * Recursively scans table with given options
     */
    _internalRecursiveScan({ scanInput, limit, cursor, itemsFetched = [], metadataOptions, }) {
        return __awaiter(this, void 0, void 0, function* () {
            // return if the count is already met
            if (limit && this.itemsFetchedSoFarTotalParallelCount >= limit) {
                return {
                    items: itemsFetched,
                    cursor,
                };
            }
            const { LastEvaluatedKey, Items = [], ConsumedCapacity, } = yield this.connection.documentClient.scan(Object.assign(Object.assign({}, scanInput), { ExclusiveStartKey: cursor }));
            // stats
            if (ConsumedCapacity) {
                this.connection.logger.logStats({
                    requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                    scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                    statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: ConsumedCapacity,
                });
            }
            // recheck if requested items limit is already met, may be other worker
            // if so drop the result of current request and return
            if (limit && this.itemsFetchedSoFarTotalParallelCount >= limit) {
                return {
                    items: itemsFetched,
                    cursor,
                };
            }
            itemsFetched = [...itemsFetched, ...Items];
            this.itemsFetchedSoFarTotalParallelCount += Items.length;
            if (LastEvaluatedKey) {
                return this._internalRecursiveScan({
                    scanInput,
                    limit,
                    cursor: LastEvaluatedKey,
                    itemsFetched,
                    metadataOptions,
                });
            }
            return {
                items: itemsFetched,
                cursor: LastEvaluatedKey,
            };
        });
    }
    /**
     * Recursively counts items form table with given options
     */
    _internalRecursiveCount({ scanInput, cursor, currentCount = 0, metadataOptions, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const { Count, LastEvaluatedKey, ConsumedCapacity } = yield this.connection.documentClient.scan(Object.assign(Object.assign({}, scanInput), { ExclusiveStartKey: cursor }));
            // stats
            if (ConsumedCapacity) {
                this.connection.logger.logStats({
                    requestId: metadataOptions === null || metadataOptions === void 0 ? void 0 : metadataOptions.requestId,
                    scope: common_1.MANAGER_NAME.SCAN_MANAGER,
                    statsType: common_1.STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: ConsumedCapacity,
                });
            }
            currentCount += Count || 0;
            if (LastEvaluatedKey) {
                return this._internalRecursiveCount({
                    scanInput,
                    cursor: LastEvaluatedKey,
                    currentCount,
                    metadataOptions,
                });
            }
            return currentCount;
        });
    }
    /**
     * Simple wrapper to limit number of concurrent calls
     * @param promise wraps promise in a limited factory
     * @returns
     */
    toLimited(promise) {
        return this.limit(() => promise);
    }
}
exports.ScanManager = ScanManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nhbi1tYW5hZ2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY2xhc3Nlcy9tYW5hZ2VyL3NjYW4tbWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDQSw2Q0FPMEI7QUFDMUIsc0RBQTZCO0FBQzdCLCtFQUF1RTtBQUt2RSxzR0FBOEY7QUFxSzlGLE1BQWEsV0FBVztJQUt0QixZQUFvQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBSGxDLFVBQUssR0FBRyxJQUFBLGlCQUFNLEVBQUMsd0NBQStCLENBQUMsQ0FBQztRQUl0RCxJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxnRUFBNkIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN4RSxJQUFJLENBQUMsbUNBQW1DLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNHLElBQUksQ0FDUixXQUFpQyxFQUNqQyxXQUE0QyxFQUM1QyxlQUFpQzs7O1lBRWpDLE1BQU0sU0FBUyxHQUFHLElBQUEsMENBQWtCLEVBQUMsZUFBZSxhQUFmLGVBQWUsdUJBQWYsZUFBZSxDQUFFLFNBQVMsQ0FBQyxDQUFDO1lBRWpFLElBQUksUUFNSCxDQUFDO1lBRUYsSUFBSSxXQUFXLGFBQVgsV0FBVyx1QkFBWCxXQUFXLENBQUUsYUFBYSxFQUFFO2dCQUM5QixDQUFDLFFBQVEsR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQVMsZ0NBQ3ZDLFdBQVcsS0FDZCxNQUFNLEVBQUUsV0FBVyxHQUNjLENBQUMsQ0FBQztvQkFDbkM7d0JBQ0UsU0FBUzt3QkFDVCxzQkFBc0IsRUFBRSxlQUFlLGFBQWYsZUFBZSx1QkFBZixlQUFlLENBQUUsc0JBQXNCO3FCQUNoRSxDQUFDO2FBQ0w7aUJBQU07Z0JBQ0wsUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FD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LHFCQUFZLENBQUMsWUFBWTtvQkFDaEMsU0FBUyxFQUFFLG1CQUFVLENBQUMsaUJBQWlCO29CQUN2QyxvQkFBb0IsRUFBRSxnQkFBZ0I7aUJBQ3ZDLENBQUMsQ0FBQzthQUNKO1lBRUQsWUFBWSxJQUFJLEtBQUssSUFBSSxDQUFDLENBQUM7WUFFM0IsSUFBSSxnQkFBZ0IsRUFBRTtnQkFDcEIsT0FBTyxJQUFJLENBQUMsdUJBQXVCLENBQUM7b0JBQ2xDLFNBQVM7b0JBQ1QsTUFBTSxFQUFFLGdCQUFnQjtvQkFDeEIsWUFBWTtvQkFDWixlQUFlO2lCQUNoQixDQUFDLENBQUM7YUFDSjtZQUVELE9BQU8sWUFBWSxDQUFDO1FBQ3RCLENBQUM7S0FBQTtJQUVEOzs7O09BSUc7SUFDSyxTQUFTLENBQUksT0FBbUI7UUFDdEMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25DLENBQUM7Q0FDRjtBQXJaRCxrQ0FxWkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RvY3VtZW50Q2xpZW50VHlwZXN9IGZyb20gJ0B0eXBlZG9ybS9kb2N1bWVudC1jbGllbnQnO1xuaW1wb3J0IHtcbiAgRW50aXR5VGFyZ2V0LFxuICBJTlRFUk5BTF9FTlRJVFlfQVRUUklCVVRFLFxuICBJbnZhbGlkUGFyYWxsZWxTY2FuTGltaXRPcHRpb25FcnJvcixcbiAgTUFOQUdFUl9OQU1FLFxuICBQQVJBTExFTF9TQ0FOX0NPTkNVUlJFTkNZX0xJTUlULFxuICBTVEFUU19UWVBFLFxufSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCBwTGltaXQgZnJvbSAncC1saW1pdCc7XG5pbXBvcnQge2dldFVuaXF1ZVJlcXVlc3RJZH0gZnJvbSAnLi4vLi4vaGVscGVycy9nZXQtdW5pcXVlLXJlcXVlc3QtaWQnO1xuaW1wb3J0IHtDb25uZWN0aW9ufSBmcm9tICcuLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb24nO1xuaW1wb3J0IHtGaWx0ZXJPcHRpb25zfSBmcm9tICcuLi9leHByZXNzaW9uL2ZpbHRlci1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtQcm9qZWN0aW9uS2V5c30gZnJvbSAnLi4vZXhwcmVzc2lvbi9wcm9qZWN0aW9uLWtleXMtb3B0aW9ucy10eXBlJztcbmltcG9ydCB7TWV0YWRhdGFPcHRpb25zfSBmcm9tICcuLi90cmFuc2Zvcm1lci9iYXNlLXRyYW5zZm9ybWVyJztcbmltcG9ydCB7RG9jdW1lbnRDbGllbnRTY2FuVHJhbnNmb3JtZXJ9IGZyb20gJy4uL3RyYW5zZm9ybWVyL2RvY3VtZW50LWNsaWVudC1zY2FuLXRyYW5zZm9ybWVyJztcblxuaW50ZXJmYWNlIFNjYW5NYW5hZ2VCYXNlT3B0aW9uczxFbnRpdHksIFBhcnRpdGlvbktleT4ge1xuICAvKipcbiAgICogSW5kZXggdG8gc2NhbiBmb3IgaXRlbXNcbiAgICogQGRlZmF1bHQgLSBtYWluIHRhYmxlXG4gICAqL1xuICBzY2FuSW5kZXg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgcmVjb3JkcyB0byBxdWVyeVxuICAgKiBAZGVmYXVsdCAtIGltcGxpY2l0IGR5bmFtbyBkYiBxdWVyeSBsaW1pdCBpcyBhcHBsaWVkXG4gICAqL1xuICBsaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogQ3Vyc29yIHRvIHRyYXZlcnNlIGZyb21cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKi9cbiAgY3Vyc29yPzogRG9jdW1lbnRDbGllbnRUeXBlcy5LZXk7XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgZmlsdGVyIHRvIGFwcGx5XG4gICAqIEF2b2lkIHVzaW5nIHRoaXMgd2hlcmUgcG9zc2libGUsIHNpbmNlIGZpbHRlcnMgaW4gZHluYW1vZGIgYXBwbGllcyBhZnRlciBpdGVtc1xuICAgKiBhcmUgcmVhZFxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqL1xuICB3aGVyZT86IEZpbHRlck9wdGlvbnM8RW50aXR5LCBQYXJ0aXRpb25LZXk+O1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgd2hpY2ggYXR0cmlidXRlcyB0byBmZXRjaFxuICAgKiBAZGVmYXVsdCBhbGwgYXR0cmlidXRlcyBhcmUgZmV0Y2hlZFxuICAgKi9cbiAgc2VsZWN0PzogUHJvamVjdGlvbktleXM8RW50aXR5Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2FuTWFuYWdlckZpbmRPcHRpb25zPEVudGl0eT5cbiAgZXh0ZW5kcyBTY2FuTWFuYWdlQmFzZU9wdGlvbnM8XG4gICAgRW50aXR5LFxuICAgIHt9IC8vIGVtcHR5IG9iamVjdCBzaW5jZSBhbGwgYXR0cmlidXRlcyBpbmNsdWRpbmcgb25lcyB1c2VkIGluIHByaW1hcnkga2V5IGNhbiBiZSB1c2VkIHdpdGggZmlsdGVyXG4gID4ge1xuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGRpdmlkZSB0aGlzIHNjYW4gaW4uXG4gICAqXG4gICAqIEBkZWZhdWx0IG5vbmUgLSBhbGwgaXRlbXMgYXJlIHNjYW5uZWQgc2VxdWVudGlhbGx5XG4gICAqL1xuICB0b3RhbFNlZ21lbnRzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBMaW1pdCB0byBhcHBseSBwZXIgc2VnbWVudC5cbiAgICpcbiAgICogd2hlbiBubyBgdG90YWxTZWdtZW50c2AgaXMgcHJvdmlkZWQsIHRoaXMgb3B0aW9uIGlzIGlnbm9yZWRcbiAgICogQGRlZmF1bHQgbm9uZSAtIGxpbWl0IHRvIGFwcGx5IHBlciBzZWdtZW50XG4gICAqL1xuICBsaW1pdFBlclNlZ21lbnQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEl0ZW0gY3Vyc29yLCB1c2VkIGZvciBwYWdpbmF0aW5nIGEgc2Nhbi5cbiAgICpcbiAgICogV2hlbiB0aGUgYHRvdGFsU2VnbWVudHNgIG9wdGlvbiBpcyBwcm92aWRlZCwgdGhpcyBvcHRpb24gc2hvdWxkIGJlIG9mIHR5cGUge1tzZWdtZW50Tm9dOiBbS2V5XX1cbiAgICogQGRlZmF1bHQgbm9uZVxuICAgKi9cbiAgY3Vyc29yPzpcbiAgICB8IFJlY29yZDxudW1iZXIsIFNjYW5NYW5hZ2VCYXNlT3B0aW9uczxFbnRpdHksIHt9PlsnY3Vyc29yJ10+XG4gICAgfCBTY2FuTWFuYWdlQmFzZU9wdGlvbnM8RW50aXR5LCB7fT5bJ2N1cnNvciddO1xuXG4gIC8qKlxuICAgKiBNYXggbnVtYmVyIG9mIHJlcXVlc3RzIHRvIHJ1biBpbiBwYXJhbGxlbFxuICAgKlxuICAgKiBXaGVuIHJlcXVlc3RpbmcgcGFyYWxsZWwgc2NhbiBvbiB4IHNlZ21lbnRzLCByZXF1ZXN0IGFyZSBleGVjdXRlZCBpbiBwYXJhbGxlbCB1c2luZyBQcm9taXNlLmFsbFxuICAgKiBXaGlsZSBpdCBpcyBva2F5IHRvIHJ1biBzbWFsbCBudW1iZXIgb2YgcmVxdWVzdHMgaW4gcGFyYWxsZWwsIGl0IGlzIG9mdGVuIGEgZ29vZCBpZGVhIHRvIGVuZm9yY2UgYSBjb25jdXJyZW5jeSBjb250cm9sbGVyIHRvIHN0b3Agbm9kZSBmcm9tIGVhdGluZyB1cCB0aGUgYWxsIHRoZSBtZW1vcnlcbiAgICpcbiAgICogVGhpcyBwYXJhbWV0ZXIgZG9lcyBleGFjdGx5IHRoYXQuIGkuZSBpZiByZXF1ZXN0ZWQgdG8gcnVuIHNjYW4gd2l0aCBgMjAsMDAwYCBzZWdtZW50cywgYW5kIGByZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXRgIGlzIHNldCB0byBgMTAwYFxuICAgKiBUeXBlRE9STSB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBhbHdheXMgb25seSBgMTAwYCByZXF1ZXN0cyBhcmUgcnVubmluZyBpbiBwYXJhbGxlbCBhdCBhbnkgdGltZSB1bnRpbCBhbGwgYDIwLDAwMGAgc2VnbWVudHMgaGF2ZSBmaW5pc2hlZCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdCBQQVJBTExFTF9TQ0FOX0NPTkNVUlJFTkNZX0xJTUlUXG4gICAqL1xuICByZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIFNjYW5NYW5hZ2VyQ291bnRPcHRpb25zPEVudGl0eT4gPSBQaWNrPFxuICBTY2FuTWFuYWdlQmFzZU9wdGlvbnM8XG4gICAgRW50aXR5LFxuICAgIHt9IC8vIGVtcHR5IG9iamVjdCBzaW5jZSBhbGwgYXR0cmlidXRlcyBpbmNsdWRpbmcgb25lcyB1c2VkIGluIHByaW1hcnkga2V5IGNhbiBiZSB1c2VkIHdpdGggZmlsdGVyXG4gID4sXG4gICdzY2FuSW5kZXgnIHwgJ3doZXJlJ1xuPjtcblxuZXhwb3J0IGludGVyZmFjZSBTY2FuTWFuYWdlclBhcmFsbGVsU2Nhbk9wdGlvbnNcbiAgZXh0ZW5kcyBTY2FuTWFuYWdlQmFzZU9wdGlvbnM8YW55LCBhbnk+IHtcbiAgLyoqXG4gICAqIFRvdGFsIG51bWJlciBvZiBzZWdtZW50cyB0byBkaXZpZGUgdGhpcyBzY2FuIGluXG4gICAqL1xuICB0b3RhbFNlZ21lbnRzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIExpbWl0IHRvIGFwcGx5IHBlciBzZWdtZW50XG4gICAqXG4gICAqIEBkZWZhdWx0IG5vbmUgLSBsaW1pdCB0byBhcHBseSBwZXIgc2VnbWVudFxuICAgKi9cbiAgbGltaXRQZXJTZWdtZW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBFbnRpdHkgdG8gcnVuIHNjYW4gZm9yLlxuICAgKlxuICAgKiBXaGVuIG9uZSBpcyBwcm92aWRlZCwgZmlsdGVyIGV4cHJlc3Npb24gaW4gYXV0byB1cGRhdGVkIHRvIGluY2x1ZGUgYSBkZWZhdWx0IGZpbGVyIGNvbmRpdGlvbiBmb3IgbWF0Y2hpbmcgZW50aXR5XG4gICAqXG4gICAqIEBkZWZhdWx0IG5vbmVcbiAgICovXG4gIGVudGl0eT86IEVudGl0eVRhcmdldDxhbnk+O1xuXG4gIC8qKlxuICAgKiBQZXIgc2VnbWVudCBjdXJzb3IsIHdoZXJlIGtleSBpcyB0aGUgc2VnbWVudCBudW1iZXIsIGFuZCB2YWx1ZSBpcyB0aGUgY3Vyc29yIG9wdGlvbnMgZm9yIHRoYXQgc2VnbWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqL1xuICBjdXJzb3I/OiBSZWNvcmQ8bnVtYmVyLCBTY2FuTWFuYWdlclNjYW5PcHRpb25zWydjdXJzb3InXT47XG5cbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgcmVxdWVzdHMgdG8gcnVuIGluIHBhcmFsbGVsXG4gICAqXG4gICAqIFdoZW4gcmVxdWVzdGluZyBwYXJhbGxlbCBzY2FuIG9uIHggc2VnbWVudHMsIHJlcXVlc3QgYXJlIGV4ZWN1dGVkIGluIHBhcmFsbGVsIHVzaW5nIFByb21pc2UuYWxsXG4gICAqIFdoaWxlIGl0IGlzIG9rYXkgdG8gcnVuIHNtYWxsIG51bWJlciBvZiByZXF1ZXN0cyBpbiBwYXJhbGxlbCwgaXQgaXMgb2Z0ZW4gYSBnb29kIGlkZWEgdG8gZW5mb3JjZSBhIGNvbmN1cnJlbmN5IGNvbnRyb2xsZXIgdG8gc3RvcCBub2RlIGZyb20gZWF0aW5nIHVwIHRoZSBhbGwgdGhlIG1lbW9yeVxuICAgKlxuICAgKiBUaGlzIHBhcmFtZXRlciBkb2VzIGV4YWN0bHkgdGhhdC4gaS5lIGlmIHJlcXVlc3RlZCB0byBydW4gc2NhbiB3aXRoIGAyMCwwMDBgIHNlZ21lbnRzLCBhbmQgYHJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdGAgaXMgc2V0IHRvIGAxMDBgXG4gICAqIFR5cGVET1JNIHdpbGwgbWFrZSBzdXJlIHRoYXQgdGhlcmUgYXJlIGFsd2F5cyBvbmx5IGAxMDBgIHJlcXVlc3RzIGFyZSBydW5uaW5nIGluIHBhcmFsbGVsIGF0IGFueSB0aW1lIHVudGlsIGFsbCBgMjAsMDAwYCBzZWdtZW50cyBoYXZlIGZpbmlzaGVkIHByb2Nlc3NpbmcuXG4gICAqXG4gICAqIEBkZWZhdWx0IFBBUkFMTEVMX1NDQU5fQ09OQ1VSUkVOQ1lfTElNSVRcbiAgICovXG4gIHJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2FuTWFuYWdlclNjYW5PcHRpb25zXG4gIGV4dGVuZHMgU2Nhbk1hbmFnZUJhc2VPcHRpb25zPGFueSwgYW55PiB7XG4gIC8qKlxuICAgKiBFbnRpdHkgdG8gc2NhblxuICAgKlxuICAgKiBXaGVuIG9uZSBpcyBwcm92aWRlZCwgZmlsdGVyIGV4cHJlc3Npb24gaW4gYXV0byB1cGRhdGVkIHRvIGluY2x1ZGUgZmlsZXIgY29uZGl0aW9uIGZvciB0aGlzIGVudGl0eVxuICAgKlxuICAgKiBAZGVmYXVsdCBub25lXG4gICAqL1xuICBlbnRpdHk/OiBFbnRpdHlUYXJnZXQ8YW55PjtcblxuICAvKipcbiAgICogTnVtYmVyIG9mIGN1cnJlbnQgc2VnbWVudFxuICAgKlxuICAgKiBAZGVmYXVsdCBub25lIC0gc2NhbiBpcyBub3Qgc2VnbWVudGVkXG4gICAqL1xuICBzZWdtZW50PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUb3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgdG8gZGl2aWRlIHRoaXMgc2NhbiBpblxuICAgKlxuICAgKiBAZGVmYXVsdCBub25lIC0gYWxsIGl0ZW1zIGFyZSBzY2FubmVkIHNlcXVlbnRpYWxseVxuICAgKi9cbiAgdG90YWxTZWdtZW50cz86IG51bWJlcjtcblxuICAvKipcbiAgICogTGltaXQgdG8gYXBwbHkgcGVyIHNlZ21lbnRcbiAgICpcbiAgICogQGRlZmF1bHQgbm9uZSAtIGxpbWl0IHRvIGFwcGx5IHBlciBzZWdtZW50XG4gICAqL1xuICBsaW1pdFBlclNlZ21lbnQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTY2FuTWFuYWdlciB7XG4gIHByaXZhdGUgaXRlbXNGZXRjaGVkU29GYXJUb3RhbFBhcmFsbGVsQ291bnQ6IG51bWJlcjtcbiAgcHJpdmF0ZSBsaW1pdCA9IHBMaW1pdChQQVJBTExFTF9TQ0FOX0NPTkNVUlJFTkNZX0xJTUlUKTtcbiAgcHJpdmF0ZSBfZGNTY2FuVHJhbnNmb3JtZXI6IERvY3VtZW50Q2xpZW50U2NhblRyYW5zZm9ybWVyO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29ubmVjdGlvbjogQ29ubmVjdGlvbikge1xuICAgIHRoaXMuX2RjU2NhblRyYW5zZm9ybWVyID0gbmV3IERvY3VtZW50Q2xpZW50U2NhblRyYW5zZm9ybWVyKGNvbm5lY3Rpb24pO1xuICAgIHRoaXMuaXRlbXNGZXRjaGVkU29GYXJUb3RhbFBhcmFsbGVsQ291bnQgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0aGUgbWF0Y2hpbmcgZW50aXR5IG92ZXIgZG9jdW1lbnQgY2xpZW50IHNjYW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBlbnRpdHlDbGFzcyBFbnRpdHkgdG8gZmluZFxuICAgKiBAcGFyYW0gZmluZE9wdGlvbnMgZmluZCBxdWVyeSBvcHRpb25zXG4gICAqIEBwYXJhbSBtZXRhZGF0YU9wdGlvbnMgT3RoZXIgbWV0YWRhdGEgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZmluZDxFbnRpdHk+KFxuICAgIGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5PixcbiAgICBmaW5kT3B0aW9ucz86IFNjYW5NYW5hZ2VyRmluZE9wdGlvbnM8RW50aXR5PixcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKSB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gZ2V0VW5pcXVlUmVxdWVzdElkKG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkKTtcblxuICAgIGxldCByZXNwb25zZToge1xuICAgICAgaXRlbXM/OiBFbnRpdHlbXTtcbiAgICAgIHVua25vd25JdGVtcz86IERvY3VtZW50Q2xpZW50VHlwZXMuQXR0cmlidXRlTWFwW107XG4gICAgICBjdXJzb3I/OlxuICAgICAgICB8IERvY3VtZW50Q2xpZW50VHlwZXMuS2V5XG4gICAgICAgIHwgUmVjb3JkPG51bWJlciwgRG9jdW1lbnRDbGllbnRUeXBlcy5LZXk+O1xuICAgIH07XG5cbiAgICBpZiAoZmluZE9wdGlvbnM/LnRvdGFsU2VnbWVudHMpIHtcbiAgICAgIChyZXNwb25zZSA9IGF3YWl0IHRoaXMucGFyYWxsZWxTY2FuPEVudGl0eT4oe1xuICAgICAgICAuLi5maW5kT3B0aW9ucyxcbiAgICAgICAgZW50aXR5OiBlbnRpdHlDbGFzcyxcbiAgICAgIH0gYXMgU2Nhbk1hbmFnZXJQYXJhbGxlbFNjYW5PcHRpb25zKSksXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMuc2NhbjxFbnRpdHk+KFxuICAgICAgICB7Li4uZmluZE9wdGlvbnMsIGVudGl0eTogZW50aXR5Q2xhc3N9IGFzIFNjYW5NYW5hZ2VyU2Nhbk9wdGlvbnMsXG4gICAgICAgIHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChyZXNwb25zZS51bmtub3duSXRlbXM/Lmxlbmd0aCkge1xuICAgICAgLy8gbG9nIHdhcm5pbmcgZm9yIGl0ZW1zIHRoYXQgd2VyZSBza2lwcGVkIGZvcm0gdGhlIHJlc3BvbnNlXG4gICAgICAvLyBUaGVzZSBhcmUgaXRlbXMgdGhhdCBoYWQgX19lbiBhdHRyaWJ1dGUgb24gdGhlbSBidXQgVHlwZURPUk0gZG9lcyBubyBsb25nZXIga25vdyBhYm91dCB0aGVtXG4gICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1dhcm4oe1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuU0NBTl9NQU5BR0VSLFxuICAgICAgICBsb2c6IGBcIiR7cmVzcG9uc2UudW5rbm93bkl0ZW1zLmxlbmd0aH1cIiBpdGVtcyB3ZXJlIHNraXBwZWQgZnJvbSB0aGUgcmVzcG9uc2UgYmVjYXVzZSBUeXBET1JNIGZhaWxlZCB0byByZXNvbHZlIHRoZW0uYCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpdGVtczogcmVzcG9uc2UuaXRlbXMsXG4gICAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdG90YWwgY291bnQgb2YgYWxsIG1hdGNoaW5nIGl0ZW1zIGZvciBjdXJyZW50IGVudGl0eVxuICAgKiBAcGFyYW0gZW50aXR5Q2xhc3MgRW50aXR5IHRvIGNvdW50XG4gICAqIEBwYXJhbSBzY2FuT3B0aW9ucyBFeHRyYSBzY2FuIG9wdGlvbnNcbiAgICogQHBhcmFtIG1ldGFkYXRhT3B0aW9ucyBPdGhlciBtZXRhZGF0YSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBjb3VudDxFbnRpdHk+KFxuICAgIGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5PixcbiAgICBzY2FuT3B0aW9ucz86IFNjYW5NYW5hZ2VyQ291bnRPcHRpb25zPEVudGl0eT4sXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3QgcmVxdWVzdElkID0gZ2V0VW5pcXVlUmVxdWVzdElkKG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkKTtcblxuICAgIGNvbnN0IGR5bmFtb1NjYW5JbnB1dCA9IHRoaXMuX2RjU2NhblRyYW5zZm9ybWVyLnRvRHluYW1vU2Nhbkl0ZW0oXG4gICAgICB7Li4uc2Nhbk9wdGlvbnMsIGVudGl0eTogZW50aXR5Q2xhc3MsIG9ubHlDb3VudDogdHJ1ZSwgc2VsZWN0OiB1bmRlZmluZWR9LCAvLyBzZWxlY3QgcHJvamVjdGlvbiBhbmQgY291bnQgY2FuIG5vdCBiZSB1c2VkIHRvZ2V0aGVyXG4gICAgICB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgfVxuICAgICk7XG5cbiAgICBjb25zdCBjb3VudCA9IGF3YWl0IHRoaXMuX2ludGVybmFsUmVjdXJzaXZlQ291bnQoe1xuICAgICAgc2NhbklucHV0OiBkeW5hbW9TY2FuSW5wdXQsXG4gICAgICBtZXRhZGF0YU9wdGlvbnM6IHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFNjYW5zIGFsbCBpdGVtcyBmcm9tIGR5bmFtbyB0YWJsZSBpbiBwYXJhbGxlbCB3aGlsZSBhbHNvIHJlc3BlY3RpbmcgdGhlIG1heCBwcm92aXNpb25lZCBjb25jdXJyZW5jeVxuICAgKiBAcGFyYW0gc2Nhbk9wdGlvbnMgT3B0aW9ucyBmb3IgcGFyYWxsZWwgc2NhblxuICAgKiBAcGFyYW0gbWV0YWRhdGFPcHRpb25zIEFkZGl0aW9uYWwgbWV0YWRhdGEgb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgcGFyYWxsZWxTY2FuPEVudGl0eT4oXG4gICAgc2Nhbk9wdGlvbnM6IFNjYW5NYW5hZ2VyUGFyYWxsZWxTY2FuT3B0aW9ucyxcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKTogUHJvbWlzZTx7XG4gICAgaXRlbXM6IEVudGl0eVtdIHwgdW5kZWZpbmVkO1xuICAgIHVua25vd25JdGVtczogRG9jdW1lbnRDbGllbnRUeXBlcy5BdHRyaWJ1dGVNYXBbXSB8IHVuZGVmaW5lZDtcbiAgICBjdXJzb3I6IFJlY29yZDxudW1iZXIsIERvY3VtZW50Q2xpZW50VHlwZXMuS2V5IHwgdW5kZWZpbmVkPjtcbiAgfT4ge1xuICAgIC8vIHN0YXJ0IHdpdGggMFxuICAgIHRoaXMuaXRlbXNGZXRjaGVkU29GYXJUb3RhbFBhcmFsbGVsQ291bnQgPSAwO1xuXG4gICAgY29uc3QgY29uY3VycmVuY3lMaW1pdCA9XG4gICAgICBQQVJBTExFTF9TQ0FOX0NPTkNVUlJFTkNZX0xJTUlUIHx8IHNjYW5PcHRpb25zLnJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdDtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSBnZXRVbmlxdWVSZXF1ZXN0SWQobWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQpO1xuXG4gICAgaWYgKHNjYW5PcHRpb25zLnJlcXVlc3RzQ29uY3VycmVuY3lMaW1pdCkge1xuICAgICAgdGhpcy5saW1pdCA9IHBMaW1pdChzY2FuT3B0aW9ucy5yZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXQpO1xuICAgIH1cblxuICAgIGNvbnN0IHBhcmFsbGVsU2Nhbk9wdGlvbnM6IFNjYW5NYW5hZ2VyU2Nhbk9wdGlvbnNbXSA9IFtdO1xuXG4gICAgaWYgKFxuICAgICAgc2Nhbk9wdGlvbnM/LmxpbWl0ICYmXG4gICAgICBzY2FuT3B0aW9ucz8ubGltaXRQZXJTZWdtZW50ICYmXG4gICAgICBzY2FuT3B0aW9ucz8ubGltaXQgPCBzY2FuT3B0aW9ucz8ubGltaXRQZXJTZWdtZW50XG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFsbGVsU2NhbkxpbWl0T3B0aW9uRXJyb3IoXG4gICAgICAgIHNjYW5PcHRpb25zPy5saW1pdCxcbiAgICAgICAgc2Nhbk9wdGlvbnM/LmxpbWl0UGVyU2VnbWVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2Nhbk9wdGlvbnMudG90YWxTZWdtZW50czsgaW5kZXgrKykge1xuICAgICAgLy8gb25seSB0aGUgY3Vyc29yIGZvciBzYW1lIHNlZ21lbnQgY2FuIGJlIGFwcGxpZWRcbiAgICAgIGNvbnN0IGN1cnNvckZvclNlZ21lbnQgPSBzY2FuT3B0aW9ucy5jdXJzb3JcbiAgICAgICAgPyBzY2FuT3B0aW9ucy5jdXJzb3JbaW5kZXhdXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBwYXJhbGxlbFNjYW5PcHRpb25zLnB1c2goe1xuICAgICAgICAuLi5zY2FuT3B0aW9ucyxcbiAgICAgICAgY3Vyc29yOiBjdXJzb3JGb3JTZWdtZW50LFxuICAgICAgICBzZWdtZW50OiBpbmRleCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nSW5mbyh7XG4gICAgICByZXF1ZXN0SWQsXG4gICAgICBzY29wZTogTUFOQUdFUl9OQU1FLlNDQU5fTUFOQUdFUixcbiAgICAgIGxvZzogYFJ1bm5pbmcgc2NhbiBpbiBwYXJhbGxlbCB3aXRoICR7c2Nhbk9wdGlvbnMudG90YWxTZWdtZW50c30gc2VnbWVudHMuYCxcbiAgICB9KTtcblxuICAgIGlmIChjb25jdXJyZW5jeUxpbWl0IDwgc2Nhbk9wdGlvbnMudG90YWxTZWdtZW50cykge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLlNDQU5fTUFOQUdFUixcbiAgICAgICAgbG9nOiBgQ3VycmVudCByZXF1ZXN0IGNvbmN1cnJlbmN5IGxpbWl0ICR7Y29uY3VycmVuY3lMaW1pdH0gaXMgbG93ZXIgdGhhbiByZXF1ZXN0ZWQgc2VnbWVudHMgY291bnQgJHtzY2FuT3B0aW9ucy50b3RhbFNlZ21lbnRzfVxuICAgICAgICBTbyByZXF1ZXN0cyB3aWxsIGJlIHJ1biBpbiBhIGJhdGNoIG9mICR7Y29uY3VycmVuY3lMaW1pdH0gYXQgYSB0aW1lIHVudGlsIGFsbCBzZWdtZW50cyAke3NjYW5PcHRpb25zLnRvdGFsU2VnbWVudHN9IGhhdmUgcHJvY2Vzc2VkLmAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGxQcm9taXNlc1Jlc3BvbnNlID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBwYXJhbGxlbFNjYW5PcHRpb25zLm1hcChvcHRpb25zID0+XG4gICAgICAgIHRoaXMudG9MaW1pdGVkKHRoaXMuc2NhbjxFbnRpdHk+KG9wdGlvbnMsIG1ldGFkYXRhT3B0aW9ucykpXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIG1lcmdlIGFsbCByZXNwb25zZXNcbiAgICBjb25zdCByZXNwb25zZSA9IGFsbFByb21pc2VzUmVzcG9uc2UucmVkdWNlKFxuICAgICAgKFxuICAgICAgICBhY2M6IHtcbiAgICAgICAgICBpdGVtczogRW50aXR5W107XG4gICAgICAgICAgdW5rbm93bkl0ZW1zOiBEb2N1bWVudENsaWVudFR5cGVzLkF0dHJpYnV0ZU1hcFtdO1xuICAgICAgICAgIGN1cnNvcjogUmVjb3JkPG51bWJlciwgRG9jdW1lbnRDbGllbnRUeXBlcy5LZXk+O1xuICAgICAgICB9LFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICBpbmRleFxuICAgICAgKSA9PiB7XG4gICAgICAgIGlmIChjdXJyZW50Lml0ZW1zPy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWFjYy5pdGVtcykge1xuICAgICAgICAgICAgYWNjLml0ZW1zID0gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIGFjYy5pdGVtcyA9IFsuLi5hY2MuaXRlbXMsIC4uLmN1cnJlbnQuaXRlbXNdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnQudW5rbm93bkl0ZW1zPy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIWFjYy51bmtub3duSXRlbXMpIHtcbiAgICAgICAgICAgIGFjYy51bmtub3duSXRlbXMgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWNjLnVua25vd25JdGVtcyA9IFsuLi5hY2MudW5rbm93bkl0ZW1zLCAuLi5jdXJyZW50LnVua25vd25JdGVtc107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudC5jdXJzb3IpIHtcbiAgICAgICAgICBpZiAoIWFjYy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGFjYy5jdXJzb3IgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWNjLmN1cnNvciA9IHtcbiAgICAgICAgICAgIC4uLmFjYy5jdXJzb3IsXG4gICAgICAgICAgICBbaW5kZXhdOiBjdXJyZW50LmN1cnNvcixcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMge1xuICAgICAgICBpdGVtczogRW50aXR5W107XG4gICAgICAgIHVua25vd25JdGVtczogRG9jdW1lbnRDbGllbnRUeXBlcy5BdHRyaWJ1dGVNYXBbXTtcbiAgICAgICAgY3Vyc29yOiBSZWNvcmQ8bnVtYmVyLCBEb2N1bWVudENsaWVudFR5cGVzLktleT47XG4gICAgICB9XG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb3cgbGV2ZWwgc2NhbiBvcGVyYXRpb24uXG4gICAqXG4gICAqIFBlcmhhcHMgeW91IGFyZSBsb29raW5nIGZvciBoaWdoZXIgbGV2ZWwgU2Nhbk1hbmFnZXIuZmluZCBvciBTY2FuTWFuYWdlci5wYXJhbGxlbFNjYW4gb3BlcmF0aW9uXG4gICAqIEBwYXJhbSBzY2FuT3B0aW9ucyBzY2FuIG9wdGlvbnMgdG8gcnVuIHNjYW4gd2l0aFxuICAgKiBAcGFyYW0gbWV0YWRhdGFPcHRpb25zIGFueSBvdGhlciBtZXRhZGF0YSBvcHRpb25zXG4gICAqL1xuICBhc3luYyBzY2FuPEVudGl0eT4oXG4gICAgc2Nhbk9wdGlvbnM/OiBTY2FuTWFuYWdlclNjYW5PcHRpb25zLFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApOiBQcm9taXNlPHtcbiAgICBpdGVtczogRW50aXR5W10gfCB1bmRlZmluZWQ7XG4gICAgdW5rbm93bkl0ZW1zOiBEb2N1bWVudENsaWVudFR5cGVzLkF0dHJpYnV0ZU1hcFtdIHwgdW5kZWZpbmVkO1xuICAgIGN1cnNvcjogRG9jdW1lbnRDbGllbnRUeXBlcy5LZXkgfCB1bmRlZmluZWQ7XG4gIH0+IHtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSBnZXRVbmlxdWVSZXF1ZXN0SWQobWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQpO1xuXG4gICAgY29uc3QgZHluYW1vU2NhbklucHV0ID0gdGhpcy5fZGNTY2FuVHJhbnNmb3JtZXIudG9EeW5hbW9TY2FuSXRlbShcbiAgICAgIHtcbiAgICAgICAgLi4uc2Nhbk9wdGlvbnMsXG4gICAgICAgIC8vIGlmIHJlcXVlc3RlZCBzZWdtZW50ZWQgc2NhbiwgdGhlbiBhcHBseSBzZWdtZW50IGxpbWl0IG9yIGRlZmF1bHQgdG8gbGltaXQgb3BlcmF0b3JcbiAgICAgICAgbGltaXQ6IHNjYW5PcHRpb25zPy50b3RhbFNlZ21lbnRzXG4gICAgICAgICAgPyBzY2FuT3B0aW9ucz8ubGltaXRQZXJTZWdtZW50XG4gICAgICAgICAgOiBzY2FuT3B0aW9ucz8ubGltaXQsXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgIH1cbiAgICApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLl9pbnRlcm5hbFJlY3Vyc2l2ZVNjYW4oe1xuICAgICAgc2NhbklucHV0OiBkeW5hbW9TY2FuSW5wdXQsXG4gICAgICBsaW1pdDogc2Nhbk9wdGlvbnM/LmxpbWl0LFxuICAgICAgY3Vyc29yOiBzY2FuT3B0aW9ucz8uY3Vyc29yLFxuICAgICAgbWV0YWRhdGFPcHRpb25zOiB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGVudGl0aWVzID1cbiAgICAgIHRoaXMuX2RjU2NhblRyYW5zZm9ybWVyLmZyb21EeW5hbW9TY2FuUmVzcG9uc2VJdGVtTGlzdDxFbnRpdHk+KFxuICAgICAgICByZXNwb25zZS5pdGVtc1xuICAgICAgKTtcblxuICAgIGlmIChzY2FuT3B0aW9ucz8uZW50aXR5ICYmIGVudGl0aWVzLnVua25vd25JdGVtcykge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dXYXJuKHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLlNDQU5fTUFOQUdFUixcbiAgICAgICAgbG9nOiBgXG4gICAgICAgIFRoZXJlIHdlcmUgc29tZSBpdGVtcyB0aGF0IGxvb2tlZCBsaWtlICR7c2Nhbk9wdGlvbnM/LmVudGl0eS5uYW1lfSBidXQgVHlwZURPUk0gd2FzIHVuYWJsZSB0byBjb252ZXJ0IGl0IGJhY2sgdG8gZW50aXR5IHR5cGUsXG4gICAgICAgIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZXJlIGFyZSBpdGVtcyBpbiB0aGUgdGFibGUgd2l0aCBcIiR7SU5URVJOQUxfRU5USVRZX0FUVFJJQlVURS5FTlRJVFlfTkFNRX0gYnV0IHdhcyBub3QgY3JlYXRlZCBieSBUeXBlRE9STS5cbiAgICAgICAgWW91IHNob3VsZCByZW1vdmUgdGhlbSBvciB1cGRhdGUgaXQgdG8gc29tZXRoaW5nIGRpZmZlcmVudC5cImAsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IGVudGl0aWVzLml0ZW1zPy5sZW5ndGggPyBlbnRpdGllcy5pdGVtcyA6IHVuZGVmaW5lZCxcbiAgICAgIHVua25vd25JdGVtczogZW50aXRpZXMudW5rbm93bkl0ZW1zPy5sZW5ndGhcbiAgICAgICAgPyBlbnRpdGllcy51bmtub3duSXRlbXNcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICBjdXJzb3I6IHJlc3BvbnNlLmN1cnNvcixcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHNjYW5zIHRhYmxlIHdpdGggZ2l2ZW4gb3B0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW50ZXJuYWxSZWN1cnNpdmVTY2FuKHtcbiAgICBzY2FuSW5wdXQsXG4gICAgbGltaXQsXG4gICAgY3Vyc29yLFxuICAgIGl0ZW1zRmV0Y2hlZCA9IFtdLFxuICAgIG1ldGFkYXRhT3B0aW9ucyxcbiAgfToge1xuICAgIHNjYW5JbnB1dDogRG9jdW1lbnRDbGllbnRUeXBlcy5TY2FuSW5wdXQ7XG4gICAgbGltaXQ/OiBudW1iZXI7XG4gICAgY3Vyc29yPzogRG9jdW1lbnRDbGllbnRUeXBlcy5LZXk7XG4gICAgaXRlbXNGZXRjaGVkPzogRG9jdW1lbnRDbGllbnRUeXBlcy5JdGVtTGlzdDtcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnM7XG4gIH0pOiBQcm9taXNlPHtcbiAgICBpdGVtczogRG9jdW1lbnRDbGllbnRUeXBlcy5JdGVtTGlzdDtcbiAgICBjdXJzb3I/OiBEb2N1bWVudENsaWVudFR5cGVzLktleTtcbiAgfT4ge1xuICAgIC8vIHJldHVybiBpZiB0aGUgY291bnQgaXMgYWxyZWFkeSBtZXRcbiAgICBpZiAobGltaXQgJiYgdGhpcy5pdGVtc0ZldGNoZWRTb0ZhclRvdGFsUGFyYWxsZWxDb3VudCA+PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zRmV0Y2hlZCxcbiAgICAgICAgY3Vyc29yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBMYXN0RXZhbHVhdGVkS2V5LFxuICAgICAgSXRlbXMgPSBbXSxcbiAgICAgIENvbnN1bWVkQ2FwYWNpdHksXG4gICAgfSA9IGF3YWl0IHRoaXMuY29ubmVjdGlvbi5kb2N1bWVudENsaWVudC5zY2FuKHtcbiAgICAgIC4uLnNjYW5JbnB1dCxcbiAgICAgIEV4Y2x1c2l2ZVN0YXJ0S2V5OiBjdXJzb3IsXG4gICAgfSk7XG4gICAgLy8gc3RhdHNcbiAgICBpZiAoQ29uc3VtZWRDYXBhY2l0eSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dTdGF0cyh7XG4gICAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuU0NBTl9NQU5BR0VSLFxuICAgICAgICBzdGF0c1R5cGU6IFNUQVRTX1RZUEUuQ09OU1VNRURfQ0FQQUNJVFksXG4gICAgICAgIGNvbnN1bWVkQ2FwYWNpdHlEYXRhOiBDb25zdW1lZENhcGFjaXR5LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gcmVjaGVjayBpZiByZXF1ZXN0ZWQgaXRlbXMgbGltaXQgaXMgYWxyZWFkeSBtZXQsIG1heSBiZSBvdGhlciB3b3JrZXJcbiAgICAvLyBpZiBzbyBkcm9wIHRoZSByZXN1bHQgb2YgY3VycmVudCByZXF1ZXN0IGFuZCByZXR1cm5cbiAgICBpZiAobGltaXQgJiYgdGhpcy5pdGVtc0ZldGNoZWRTb0ZhclRvdGFsUGFyYWxsZWxDb3VudCA+PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IGl0ZW1zRmV0Y2hlZCxcbiAgICAgICAgY3Vyc29yLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpdGVtc0ZldGNoZWQgPSBbLi4uaXRlbXNGZXRjaGVkLCAuLi5JdGVtc107XG4gICAgdGhpcy5pdGVtc0ZldGNoZWRTb0ZhclRvdGFsUGFyYWxsZWxDb3VudCArPSBJdGVtcy5sZW5ndGg7XG5cbiAgICBpZiAoTGFzdEV2YWx1YXRlZEtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUmVjdXJzaXZlU2Nhbih7XG4gICAgICAgIHNjYW5JbnB1dCxcbiAgICAgICAgbGltaXQsXG4gICAgICAgIGN1cnNvcjogTGFzdEV2YWx1YXRlZEtleSxcbiAgICAgICAgaXRlbXNGZXRjaGVkLFxuICAgICAgICBtZXRhZGF0YU9wdGlvbnMsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IGl0ZW1zRmV0Y2hlZCxcbiAgICAgIGN1cnNvcjogTGFzdEV2YWx1YXRlZEtleSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IGNvdW50cyBpdGVtcyBmb3JtIHRhYmxlIHdpdGggZ2l2ZW4gb3B0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBfaW50ZXJuYWxSZWN1cnNpdmVDb3VudCh7XG4gICAgc2NhbklucHV0LFxuICAgIGN1cnNvcixcbiAgICBjdXJyZW50Q291bnQgPSAwLFxuICAgIG1ldGFkYXRhT3B0aW9ucyxcbiAgfToge1xuICAgIHNjYW5JbnB1dDogRG9jdW1lbnRDbGllbnRUeXBlcy5TY2FuSW5wdXQ7XG4gICAgY3Vyc29yPzogRG9jdW1lbnRDbGllbnRUeXBlcy5LZXk7XG4gICAgY3VycmVudENvdW50PzogbnVtYmVyO1xuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9ucztcbiAgfSk6IFByb21pc2U8bnVtYmVyPiB7XG4gICAgY29uc3Qge0NvdW50LCBMYXN0RXZhbHVhdGVkS2V5LCBDb25zdW1lZENhcGFjaXR5fSA9XG4gICAgICBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZG9jdW1lbnRDbGllbnQuc2Nhbih7XG4gICAgICAgIC4uLnNjYW5JbnB1dCxcbiAgICAgICAgRXhjbHVzaXZlU3RhcnRLZXk6IGN1cnNvcixcbiAgICAgIH0pO1xuICAgIC8vIHN0YXRzXG4gICAgaWYgKENvbnN1bWVkQ2FwYWNpdHkpIHtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nU3RhdHMoe1xuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLlNDQU5fTUFOQUdFUixcbiAgICAgICAgc3RhdHNUeXBlOiBTVEFUU19UWVBFLkNPTlNVTUVEX0NBUEFDSVRZLFxuICAgICAgICBjb25zdW1lZENhcGFjaXR5RGF0YTogQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGN1cnJlbnRDb3VudCArPSBDb3VudCB8fCAwO1xuXG4gICAgaWYgKExhc3RFdmFsdWF0ZWRLZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbFJlY3Vyc2l2ZUNvdW50KHtcbiAgICAgICAgc2NhbklucHV0LFxuICAgICAgICBjdXJzb3I6IExhc3RFdmFsdWF0ZWRLZXksXG4gICAgICAgIGN1cnJlbnRDb3VudCxcbiAgICAgICAgbWV0YWRhdGFPcHRpb25zLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRDb3VudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGUgd3JhcHBlciB0byBsaW1pdCBudW1iZXIgb2YgY29uY3VycmVudCBjYWxsc1xuICAgKiBAcGFyYW0gcHJvbWlzZSB3cmFwcyBwcm9taXNlIGluIGEgbGltaXRlZCBmYWN0b3J5XG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBwcml2YXRlIHRvTGltaXRlZDxUPihwcm9taXNlOiBQcm9taXNlPFQ+KSB7XG4gICAgcmV0dXJuIHRoaXMubGltaXQoKCkgPT4gcHJvbWlzZSk7XG4gIH1cbn1cbiJdfQ==