import { KeyCondition } from './key-condition';
import { Filter } from './filter';
import { FilterOptions } from './filter-options-type';
import { ConditionOptions } from './condition-options-type';
import { Condition } from './condition';
import { Projection } from './projection';
import { KeyConditionOptions } from './key-condition-options-type';
import { ProjectionKeys } from './projection-keys-options-type';
import { UpdateBody } from './update-body-type';
import { Update } from './update/update';
/**
 * Parses expression input to expression instances
 */
export declare class ExpressionInputParser {
    parseToKeyCondition(key: string, options: KeyConditionOptions): KeyCondition;
    parseToFilter<Entity, PrimaryKey>(options: FilterOptions<Entity, PrimaryKey>): Filter | undefined;
    parseToCondition<Entity>(options: ConditionOptions<Entity>): Condition | undefined;
    parseToProjection<Entity>(keys: ProjectionKeys<Entity>): Projection;
    parseToUpdate<Entity, AdditionalProperties = {}>(body: UpdateBody<Entity, AdditionalProperties>, attrValueOverrideMap?: Record<string, any>): Update;
    /**
     * Parses complex update object to a value and type
     */
    parseAttributeToUpdateValue(attr: string, value: any): {
        value: any;
        type: 'static' | 'dynamic';
    };
    /**
     * Generic Recursive input parser
     * Recursively parses nested object to build expression of type ExpClass
     * @param options Complex options object to parse
     * @param ExpClass Type of expression to build, can be of type Filter, Condition etc.
     *
     */
    private recursiveParseToBaseExpression;
    /**
     * Parses input to update expression
     * @param body body to parse
     */
    private parseToUpdateExpression;
    /**
     * Parses single attribute into update expression instance
     * @param attribute name/path of the attribute
     * @param attributeValue value to update
     */
    private parseValueToUpdateExp;
    /**
     * When this is run, it is assumed that attribute/value are validated to not have any nested objects,
     * therefor this function will not running in any recursion itself
     * @param attribute Attribute or path on entity to build comparison condition for
     * @param value value to expect
     * @param exp expression to append operators to
     */
    private operatorToBaseExpression;
    /**
     * Builds comparison expression for operators with scalar values
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    private parseScalarValueToExp;
    /**
     * Builds comparison expression for operators with Non scalar values, i.e ranges and size
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    private parseNonScalarValueToExp;
}
