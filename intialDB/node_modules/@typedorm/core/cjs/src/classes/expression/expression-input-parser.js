"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionInputParser = void 0;
const is_empty_object_1 = require("../../helpers/is-empty-object");
const key_condition_1 = require("./key-condition");
const filter_1 = require("./filter");
const base_expression_input_1 = require("./base-expression-input");
const is_scalar_type_1 = require("../../helpers/is-scalar-type");
const condition_1 = require("./condition");
const projection_1 = require("./projection");
const update_body_type_1 = require("./update-body-type");
const set_update_1 = require("./update/set-update");
const add_update_1 = require("./update/add-update");
const update_1 = require("./update/update");
const delete_update_1 = require("./update/delete-update");
const remove_update_1 = require("./update/remove-update");
const is_object_1 = require("../../helpers/is-object");
const constants_1 = require("../../helpers/constants");
/**
 * Parses expression input to expression instances
 */
class ExpressionInputParser {
    parseToKeyCondition(key, options) {
        return this.operatorToBaseExpression(key, options, new key_condition_1.KeyCondition());
    }
    parseToFilter(options) {
        return this.recursiveParseToBaseExpression(options, filter_1.Filter).pop();
    }
    parseToCondition(options) {
        return this.recursiveParseToBaseExpression(options, condition_1.Condition).pop();
    }
    parseToProjection(keys) {
        const projection = new projection_1.Projection();
        projection.addProjectionAttributes(keys);
        return projection;
    }
    parseToUpdate(body, attrValueOverrideMap = {}) {
        return this.parseToUpdateExpression(body, attrValueOverrideMap);
    }
    /**
     * Parses complex update object to a value and type
     */
    parseAttributeToUpdateValue(attr, value) {
        var _a;
        if ((0, is_object_1.isObject)(value) && !(0, is_empty_object_1.isEmptyObject)(value)) {
            const [operator, operatorValue] = Object.entries(value)[0];
            const parsedUpdate = this.parseValueToUpdateExp(attr, value, operator, operatorValue);
            const parsedValue = Object.values((_a = parsedUpdate.values) !== null && _a !== void 0 ? _a : {})[0];
            // if expression contains any dynamic operation such as value manipulation or nested attribute manipulation in a list
            if (!(parsedUpdate instanceof set_update_1.SetUpdate) ||
                parsedUpdate.expression.includes(' + ') ||
                parsedUpdate.expression.includes(' - ') ||
                constants_1.nestedKeyAccessRegex.test(parsedUpdate.expression)) {
                return {
                    value: parsedValue,
                    type: 'dynamic',
                };
            }
            // return static value
            return {
                type: 'static',
                value: parsedValue,
            };
        }
        else {
            // if tried to update nested value for key, it is considered dynamic, as we do not know full value of updating attribute
            if (constants_1.nestedKeyAccessRegex.test(attr)) {
                return {
                    type: 'dynamic',
                    value,
                };
            }
            // return value as a default value
            return { type: 'static', value };
        }
    }
    /**
     * Generic Recursive input parser
     * Recursively parses nested object to build expression of type ExpClass
     * @param options Complex options object to parse
     * @param ExpClass Type of expression to build, can be of type Filter, Condition etc.
     *
     */
    recursiveParseToBaseExpression(options, ExpClass) {
        return Object.entries(options).map(([operatorOrAttr, value]) => {
            // if top level key is one of the logical operators, rerun parse with it's values
            if (['AND', 'OR', 'NOT'].includes(operatorOrAttr)) {
                const parsedExpList = this.recursiveParseToBaseExpression(value, ExpClass);
                const base = parsedExpList.shift();
                if (!base) {
                    return new ExpClass();
                }
                switch (operatorOrAttr) {
                    case 'AND': {
                        if (!(parsedExpList === null || parsedExpList === void 0 ? void 0 : parsedExpList.length)) {
                            return base;
                        }
                        return base.mergeMany(parsedExpList, base_expression_input_1.MERGE_STRATEGY.AND);
                    }
                    case 'OR': {
                        if (!(parsedExpList === null || parsedExpList === void 0 ? void 0 : parsedExpList.length)) {
                            return base;
                        }
                        return base.mergeMany(parsedExpList, base_expression_input_1.MERGE_STRATEGY.OR);
                    }
                    case 'NOT': {
                        // not can not contain more than one items
                        if (parsedExpList === null || parsedExpList === void 0 ? void 0 : parsedExpList.length) {
                            throw new Error(`Value for operator "${operatorOrAttr}" can not contain more than 1 attributes.`);
                        }
                        return base.not();
                    }
                    default: {
                        throw new Error(`Unsupported logical operator "${operatorOrAttr}"`);
                    }
                }
            }
            else {
                // when top level attribute is something other than actual logical operators, try to parse it to expression
                return this.operatorToBaseExpression(operatorOrAttr, value, new ExpClass());
            }
        });
    }
    /**
     * Parses input to update expression
     * @param body body to parse
     */
    parseToUpdateExpression(body, attrValueOverrideMap) {
        return (Object.entries(body)
            .map(([attr, value]) => {
            if ((0, is_object_1.isObject)(value) && !(0, is_empty_object_1.isEmptyObject)(value)) {
                const [operator, operatorValue] = Object.entries(value)[0];
                return this.parseValueToUpdateExp(attr, value, operator, operatorValue, attrValueOverrideMap[attr] // get any override value if exists
                );
            }
            else {
                // fallback to default `SET` action based update
                return new set_update_1.SetUpdate().setTo(attr, attrValueOverrideMap[attr] || value);
            }
        })
            // merge all expressions with matching action
            .reduce((acc, currExp) => {
            acc
                .find(instance => instance.constructor === currExp.constructor)
                .merge(currExp);
            return acc;
        }, [
            new set_update_1.SetUpdate(),
            new add_update_1.AddUpdate(),
            new remove_update_1.RemoveUpdate(),
            new delete_update_1.DeleteUpdate(),
        ])
            // merge all expressions of different actions
            .reduce((acc, curr) => {
            acc.merge(curr);
            return acc;
        }, new update_1.Update()));
    }
    /**
     * Parses single attribute into update expression instance
     * @param attribute name/path of the attribute
     * @param attributeValue value to update
     */
    parseValueToUpdateExp(attribute, attributeValue, // attribute value to set
    operator, operatorValue, staticValueToOverride // value to override for attribute, this is set in cases where there was a custom property transform was requested
    ) {
        switch (operator) {
            case 'INCREMENT_BY':
            case 'DECREMENT_BY': {
                return new set_update_1.SetUpdate().setTo(attribute, operatorValue, operator);
            }
            case 'IF_NOT_EXISTS': {
                if ((0, update_body_type_1.isSetOperatorComplexValueType)(operatorValue)) {
                    return new set_update_1.SetUpdate().setToIfNotExists(attribute, staticValueToOverride || operatorValue.$VALUE, operatorValue.$PATH);
                }
                else {
                    return new set_update_1.SetUpdate().setToIfNotExists(attribute, operatorValue);
                }
            }
            case 'LIST_APPEND': {
                if ((0, update_body_type_1.isSetOperatorComplexValueType)(operatorValue)) {
                    return new set_update_1.SetUpdate().setOrAppendToList(attribute, operatorValue.$VALUE, operatorValue.$PATH);
                }
                else {
                    return new set_update_1.SetUpdate().setOrAppendToList(attribute, operatorValue);
                }
            }
            case 'SET': {
                /**
                 * aliased set support, this allows access patterns like
                 * {id: { SET: '1'}}
                 * behaves similar to {id: '1'}
                 */
                // handle explicit set exp
                if ((0, is_object_1.isObject)(operatorValue) && !(0, is_empty_object_1.isEmptyObject)(operatorValue)) {
                    const [nestedOperator, nestedOperatorValue] = Object.entries(operatorValue)[0];
                    return this.parseValueToUpdateExp(attribute, nestedOperatorValue, nestedOperator, nestedOperatorValue, staticValueToOverride);
                }
                else {
                    // handle attribute with map type
                    return new set_update_1.SetUpdate().setTo(attribute, staticValueToOverride || operatorValue);
                }
            }
            case 'ADD': {
                if ((0, is_empty_object_1.isEmptyObject)(operatorValue)) {
                    throw new Error(`Invalid value ${operatorValue} received for action "ADD", Only numbers and lists are supported.`);
                }
                return new add_update_1.AddUpdate().addTo(attribute, operatorValue);
            }
            case 'DELETE': {
                return new delete_update_1.DeleteUpdate().delete(attribute, operatorValue);
            }
            case 'REMOVE': {
                if (typeof operatorValue === 'boolean' && !!operatorValue) {
                    return new remove_update_1.RemoveUpdate().remove(attribute);
                }
                else if (!(0, is_empty_object_1.isEmptyObject)(operatorValue) &&
                    Array.isArray(operatorValue.$AT_INDEX)) {
                    return new remove_update_1.RemoveUpdate().remove(attribute, {
                        atIndexes: operatorValue.$AT_INDEX,
                    });
                }
                else {
                    throw new Error(`Invalid value ${operatorValue} received for action "REMOVE". Value must be set to boolean
            In addition, You may use special value type {$AT_INDEX: Array<number>} for attribute of type list..`);
                }
            }
            default: {
                // handle attribute with map type
                return new set_update_1.SetUpdate().setTo(attribute, staticValueToOverride || attributeValue);
            }
        }
    }
    /**
     * When this is run, it is assumed that attribute/value are validated to not have any nested objects,
     * therefor this function will not running in any recursion itself
     * @param attribute Attribute or path on entity to build comparison condition for
     * @param value value to expect
     * @param exp expression to append operators to
     */
    operatorToBaseExpression(attribute, value, exp) {
        switch (typeof value) {
            case 'string': {
                if (value === 'ATTRIBUTE_EXISTS') {
                    exp.attributeExists(attribute);
                    return exp;
                }
                else if (value === 'ATTRIBUTE_NOT_EXISTS') {
                    exp.attributeNotExists(attribute);
                    return exp;
                }
                else {
                    throw new Error(`Operator used must be one of "ATTRIBUTE_EXISTS", "ATTRIBUTE_NOT_EXISTS" for 
            attribute "${attribute}".`);
                }
            }
            case 'object': {
                if ((0, is_empty_object_1.isEmptyObject)(value)) {
                    throw new Error(`Value for attribute "${attribute}" can not be empty`);
                }
                const operatorAndValue = Object.entries(value);
                if (operatorAndValue.length !== 1) {
                    throw new Error(`Invalid value "${JSON.stringify(value)}" found for attribute: ${attribute}`);
                }
                const [innerOp, innerVal] = operatorAndValue[0];
                if ((0, is_scalar_type_1.isScalarType)(innerVal)) {
                    return this.parseScalarValueToExp(innerOp, attribute, innerVal, exp);
                }
                else {
                    return this.parseNonScalarValueToExp(innerOp, attribute, innerVal, exp);
                }
            }
            default: {
                throw new Error(`Value for attribute "${attribute}" must be of type object or string`);
            }
        }
    }
    /**
     * Builds comparison expression for operators with scalar values
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    parseScalarValueToExp(operator, attrPath, value, exp) {
        switch (operator) {
            case 'EQ': {
                exp.equals(attrPath, value);
                return exp;
            }
            case 'LT': {
                exp.lessThan(attrPath, value);
                return exp;
            }
            case 'LE': {
                exp.lessThanAndEqualTo(attrPath, value);
                return exp;
            }
            case 'GT': {
                exp.greaterThan(attrPath, value);
                return exp;
            }
            case 'GE': {
                exp.greaterThanAndEqualTo(attrPath, value);
                return exp;
            }
            case 'NE': {
                exp.notEquals(attrPath, value);
                return exp;
            }
            case 'BEGINS_WITH': {
                exp.beginsWith(attrPath, value);
                return exp;
            }
            case 'CONTAINS': {
                exp.contains(attrPath, value);
                return exp;
            }
            case 'ATTRIBUTE_TYPE': {
                exp.attributeType(attrPath, value);
                return exp;
            }
            default: {
                throw new Error(`Unsupported operator: ${operator}`);
            }
        }
    }
    /**
     * Builds comparison expression for operators with Non scalar values, i.e ranges and size
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    parseNonScalarValueToExp(operator, attrPath, value, exp) {
        switch (operator) {
            case 'BETWEEN': {
                if (!Array.isArray(value) || value.length !== 2) {
                    throw new Error(`Value for operator ${operator} must be of type array with exact two items.`);
                }
                exp.between(attrPath, value);
                return exp;
            }
            case 'IN': {
                if (!Array.isArray(value) || value.length < 1) {
                    throw new Error(`Value for operator ${operator} must be of type array with at least one item.`);
                }
                exp.in(attrPath, value);
                return exp;
            }
            case 'SIZE': {
                const operatorAndValue = Object.entries(value);
                if (operatorAndValue.length !== 1) {
                    throw new Error(`Invalid value "${JSON.stringify(value)}" found for operator: ${operator}`);
                }
                const [innerOp, innerVal] = operatorAndValue[0];
                const parsedExp = this.parseScalarValueToExp(innerOp, attrPath, innerVal, exp);
                // once operator condition has applied, pass it through size
                parsedExp.size(attrPath);
                return parsedExp;
            }
            default: {
                throw new Error(`Unsupported operator: ${operator}`);
            }
        }
    }
}
exports.ExpressionInputParser = ExpressionInputParser;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1pbnB1dC1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9jbGFzc2VzL2V4cHJlc3Npb24vZXhwcmVzc2lvbi1pbnB1dC1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBT0EsbUVBQTREO0FBQzVELG1EQUE2QztBQUM3QyxxQ0FBZ0M7QUFDaEMsbUVBQTRFO0FBQzVFLGlFQUEwRDtBQUcxRCwyQ0FBc0M7QUFDdEMsNkNBQXdDO0FBR3hDLHlEQUE2RTtBQUM3RSxvREFBOEM7QUFDOUMsb0RBQThDO0FBQzlDLDRDQUF1QztBQUV2QywwREFBb0Q7QUFDcEQsMERBQW9EO0FBQ3BELHVEQUFpRDtBQUNqRCx1REFBNkQ7QUFFN0Q7O0dBRUc7QUFDSCxNQUFhLHFCQUFxQjtJQUNoQyxtQkFBbUIsQ0FBQyxHQUFXLEVBQUUsT0FBNEI7UUFDM0QsT0FBTyxJQUFJLENBQUMsd0JBQXdCLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLDRCQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7SUFFRCxhQUFhLENBQ1gsT0FBMEM7UUFFMUMsT0FBTyxJQUFJLENBQUMsOEJBQThCLENBQUMsT0FBTyxFQUFFLGVBQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3BFLENBQUM7SUFFRCxnQkFBZ0IsQ0FBUyxPQUFpQztRQUN4RCxPQUFPLElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxPQUFPLEVBQUUscUJBQVMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO0lBQ3ZFLENBQUM7SUFFRCxpQkFBaUIsQ0FBUyxJQUE0QjtRQUNwRCxNQUFNLFVBQVUsR0FBRyxJQUFJLHVCQUFVLEVBQUUsQ0FBQztRQUNwQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsSUFBZ0IsQ0FBQyxDQUFDO1FBRXJELE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxhQUFhLENBQ1gsSUFBOEMsRUFDOUMsdUJBQTRDLEVBQUU7UUFFOUMsT0FBTyxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDbEUsQ0FBQztJQUVEOztPQUVHO0lBQ0gsMkJBQTJCLENBQ3pCLElBQVksRUFDWixLQUFVOztRQUVWLElBQUksSUFBQSxvQkFBUSxFQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBQSwrQkFBYSxFQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzVDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsYUFBYSxDQUFDLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFZLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVsRSxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQzdDLElBQUksRUFDSixLQUFLLEVBQ0wsUUFBZSxFQUNmLGFBQWEsQ0FDZCxDQUFDO1lBRUYsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFBLFlBQVksQ0FBQyxNQUFNLG1DQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRWhFLHFIQUFxSDtZQUNySCxJQUNFLENBQUMsQ0FBQyxZQUFZLFlBQVksc0JBQVMsQ0FBQztnQkFDcEMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDO2dCQUN2QyxZQUFZLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7Z0JBQ3ZDLGdDQUFvQixDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQ2xEO2dCQUNBLE9BQU87b0JBQ0wsS0FBSyxFQUFFLFdBQVc7b0JBQ2xCLElBQUksRUFBRSxTQUFTO2lCQUNoQixDQUFDO2FBQ0g7WUFFRCxzQkFBc0I7WUFDdEIsT0FBTztnQkFDTCxJQUFJLEVBQUUsUUFBUTtnQkFDZCxLQUFLLEVBQUUsV0FBVzthQUNuQixDQUFDO1NBQ0g7YUFBTTtZQUNMLHdIQUF3SDtZQUN4SCxJQUFJLGdDQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDbkMsT0FBTztvQkFDTCxJQUFJLEVBQUUsU0FBUztvQkFDZixLQUFLO2lCQUNOLENBQUM7YUFDSDtZQUNELGtDQUFrQztZQUNsQyxPQUFPLEVBQUMsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUMsQ0FBQztTQUNoQztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyw4QkFBOEIsQ0FDcEMsT0FBWSxFQUNaLFFBQXFCO1FBRXJCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxLQUFLLENBQUMsRUFBSyxFQUFFO1lBQ2hFLGlGQUFpRjtZQUNqRixJQUFJLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLEVBQUU7Z0JBQ2pELE1BQU0sYUFBYSxHQUFHLElBQUksQ0FBQyw4QkFBOEIsQ0FDdkQsS0FBSyxFQUNMLFFBQVEsQ0FDVCxDQUFDO2dCQUNGLE1BQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDbkMsSUFBSSxDQUFDLElBQUksRUFBRTtvQkFDVCxPQUFPLElBQUksUUFBUSxFQUFFLENBQUM7aUJBQ3ZCO2dCQUNELFFBQVEsY0FBYyxFQUFFO29CQUN0QixLQUFLLEtBQUssQ0FBQyxDQUFDO3dCQUNWLElBQUksQ0FBQyxDQUFBLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxNQUFNLENBQUEsRUFBRTs0QkFDMUIsT0FBTyxJQUFJLENBQUM7eUJBQ2I7d0JBQ0QsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQW9CLEVBQUUsc0NBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQztxQkFDakU7b0JBQ0QsS0FBSyxJQUFJLENBQUMsQ0FBQzt3QkFDVCxJQUFJLENBQUMsQ0FBQSxhQUFhLGFBQWIsYUFBYSx1QkFBYixhQUFhLENBQUUsTUFBTSxDQUFBLEVBQUU7NEJBQzFCLE9BQU8sSUFBSSxDQUFDO3lCQUNiO3dCQUNELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFvQixFQUFFLHNDQUFjLENBQUMsRUFBRSxDQUFDLENBQUM7cUJBQ2hFO29CQUNELEtBQUssS0FBSyxDQUFDLENBQUM7d0JBQ1YsMENBQTBDO3dCQUMxQyxJQUFJLGFBQWEsYUFBYixhQUFhLHVCQUFiLGFBQWEsQ0FBRSxNQUFNLEVBQUU7NEJBQ3pCLE1BQU0sSUFBSSxLQUFLLENBQ2IsdUJBQXVCLGNBQWMsMkNBQTJDLENBQ2pGLENBQUM7eUJBQ0g7d0JBQ0QsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7cUJBQ25CO29CQUNELE9BQU8sQ0FBQyxDQUFDO3dCQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMsaUNBQWlDLGNBQWMsR0FBRyxDQUFDLENBQUM7cUJBQ3JFO2lCQUNGO2FBQ0Y7aUJBQU07Z0JBQ0wsMkdBQTJHO2dCQUMzRyxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FDbEMsY0FBYyxFQUNkLEtBQUssRUFDTCxJQUFJLFFBQVEsRUFBRSxDQUNmLENBQUM7YUFDSDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRztJQUNLLHVCQUF1QixDQUM3QixJQUFTLEVBQ1Qsb0JBQXlDO1FBRXpDLE9BQU8sQ0FDTCxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQzthQUNqQixHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFO1lBQ3JCLElBQUksSUFBQSxvQkFBUSxFQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBQSwrQkFBYSxFQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUM1QyxNQUFNLENBQUMsUUFBUSxFQUFFLGFBQWEsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQzlDLEtBQVksQ0FDYixDQUFDLENBQUMsQ0FPRixDQUFDO2dCQUVGLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUMvQixJQUFJLEVBQ0osS0FBSyxFQUNMLFFBQVEsRUFDUixhQUFhLEVBQ2Isb0JBQW9CLENBQUMsSUFBSSxDQUFDLENBQUMsbUNBQW1DO2lCQUMvRCxDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsZ0RBQWdEO2dCQUNoRCxPQUFPLElBQUksc0JBQVMsRUFBRSxDQUFDLEtBQUssQ0FDMUIsSUFBSSxFQUNKLG9CQUFvQixDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FDcEMsQ0FBQzthQUNIO1FBQ0gsQ0FBQyxDQUFDO1lBQ0YsNkNBQTZDO2FBQzVDLE1BQU0sQ0FDTCxDQUFDLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBRTtZQUNmLEdBQUc7aUJBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsS0FBSyxPQUFPLENBQUMsV0FBVyxDQUFFO2lCQUMvRCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDbEIsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLEVBQ0Q7WUFDRSxJQUFJLHNCQUFTLEVBQUU7WUFDZixJQUFJLHNCQUFTLEVBQUU7WUFDZixJQUFJLDRCQUFZLEVBQUU7WUFDbEIsSUFBSSw0QkFBWSxFQUFFO1NBQ25CLENBQ0Y7WUFDRCw2Q0FBNkM7YUFDNUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ3BCLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDaEIsT0FBTyxHQUFHLENBQUM7UUFDYixDQUFDLEVBQUUsSUFBSSxlQUFNLEVBQUUsQ0FBQyxDQUNuQixDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDSyxxQkFBcUIsQ0FDM0IsU0FBaUIsRUFDakIsY0FBbUIsRUFBRSx5QkFBeUI7SUFDOUMsUUFHcUIsRUFDckIsYUFBa0IsRUFDbEIscUJBQTJCLENBQUMsa0hBQWtIOztRQUU5SSxRQUFRLFFBQVEsRUFBRTtZQUNoQixLQUFLLGNBQWMsQ0FBQztZQUNwQixLQUFLLGNBQWMsQ0FBQyxDQUFDO2dCQUNuQixPQUFPLElBQUksc0JBQVMsRUFBRSxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO2FBQ2xFO1lBQ0QsS0FBSyxlQUFlLENBQUMsQ0FBQztnQkFDcEIsSUFBSSxJQUFBLGdEQUE2QixFQUFDLGFBQWEsQ0FBQyxFQUFFO29CQUNoRCxPQUFPLElBQUksc0JBQVMsRUFBRSxDQUFDLGdCQUFnQixDQUNyQyxTQUFTLEVBQ1QscUJBQXFCLElBQUksYUFBYSxDQUFDLE1BQU0sRUFDN0MsYUFBYSxDQUFDLEtBQUssQ0FDcEIsQ0FBQztpQkFDSDtxQkFBTTtvQkFDTCxPQUFPLElBQUksc0JBQVMsRUFBRSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxhQUFhLENBQUMsQ0FBQztpQkFDbkU7YUFDRjtZQUNELEtBQUssYUFBYSxDQUFDLENBQUM7Z0JBQ2xCLElBQUksSUFBQSxnREFBNkIsRUFBQyxhQUFhLENBQUMsRUFBRTtvQkFDaEQsT0FBTyxJQUFJLHNCQUFTLEVBQUUsQ0FBQyxpQkFBaUIsQ0FDdEMsU0FBUyxFQUNULGFBQWEsQ0FBQyxNQUFNLEVBQ3BCLGFBQWEsQ0FBQyxLQUFLLENBQ3BCLENBQUM7aUJBQ0g7cUJBQU07b0JBQ0wsT0FBTyxJQUFJLHNCQUFTLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7aUJBQ3BFO2FBQ0Y7WUFDRCxLQUFLLEtBQUssQ0FBQyxDQUFDO2dCQUNWOzs7O21CQUlHO2dCQUNILDBCQUEwQjtnQkFDMUIsSUFBSSxJQUFBLG9CQUFRLEVBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFBLCtCQUFhLEVBQUMsYUFBYSxDQUFDLEVBQUU7b0JBQzVELE1BQU0sQ0FBQyxjQUFjLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUMxRCxhQUFhLENBQ2QsQ0FBQyxDQUFDLENBR0YsQ0FBQztvQkFFRixPQUFPLElBQUksQ0FBQyxxQkFBcUIsQ0FDL0IsU0FBUyxFQUNULG1CQUFtQixFQUNuQixjQUFjLEVBQ2QsbUJBQW1CLEVBQ25CLHFCQUFxQixDQUN0QixDQUFDO2lCQUNIO3FCQUFNO29CQUNMLGlDQUFpQztvQkFDakMsT0FBTyxJQUFJLHNCQUFTLEVBQUUsQ0FBQyxLQUFLLENBQzFCLFNBQVMsRUFDVCxxQkFBcUIsSUFBSSxhQUFhLENBQ3ZDLENBQUM7aUJBQ0g7YUFDRjtZQUNELEtBQUssS0FBSyxDQUFDLENBQUM7Z0JBQ1YsSUFBSSxJQUFBLCtCQUFhLEVBQUMsYUFBYSxDQUFDLEVBQUU7b0JBQ2hDLE1BQU0sSUFBSSxLQUFLLENBQ2IsaUJBQWlCLGFBQWEsbUVBQW1FLENBQ2xHLENBQUM7aUJBQ0g7Z0JBQ0QsT0FBTyxJQUFJLHNCQUFTLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxDQUFDO2FBQ3hEO1lBQ0QsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixPQUFPLElBQUksNEJBQVksRUFBRSxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDNUQ7WUFDRCxLQUFLLFFBQVEsQ0FBQyxDQUFDO2dCQUNiLElBQUksT0FBTyxhQUFhLEtBQUssU0FBUyxJQUFJLENBQUMsQ0FBQyxhQUFhLEVBQUU7b0JBQ3pELE9BQU8sSUFBSSw0QkFBWSxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO2lCQUM3QztxQkFBTSxJQUNMLENBQUMsSUFBQSwrQkFBYSxFQUFDLGFBQWEsQ0FBQztvQkFDN0IsS0FBSyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLEVBQ3RDO29CQUNBLE9BQU8sSUFBSSw0QkFBWSxFQUFFLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTt3QkFDMUMsU0FBUyxFQUFFLGFBQWEsQ0FBQyxTQUFTO3FCQUNuQyxDQUFDLENBQUM7aUJBQ0o7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLEtBQUssQ0FDYixpQkFBaUIsYUFBYTtnSEFDc0UsQ0FDckcsQ0FBQztpQkFDSDthQUNGO1lBQ0QsT0FBTyxDQUFDLENBQUM7Z0JBQ1AsaUNBQWlDO2dCQUNqQyxPQUFPLElBQUksc0JBQVMsRUFBRSxDQUFDLEtBQUssQ0FDMUIsU0FBUyxFQUNULHFCQUFxQixJQUFJLGNBQWMsQ0FDeEMsQ0FBQzthQUNIO1NBQ0Y7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0ssd0JBQXdCLENBQzlCLFNBQWMsRUFDZCxLQUFVLEVBQ1YsR0FBTTtRQUVOLFFBQVEsT0FBTyxLQUFLLEVBQUU7WUFDcEIsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixJQUFJLEtBQUssS0FBSyxrQkFBa0IsRUFBRTtvQkFDaEMsR0FBRyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDL0IsT0FBTyxHQUFHLENBQUM7aUJBQ1o7cUJBQU0sSUFBSSxLQUFLLEtBQUssc0JBQXNCLEVBQUU7b0JBQzNDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDbEMsT0FBTyxHQUFHLENBQUM7aUJBQ1o7cUJBQU07b0JBQ0wsTUFBTSxJQUFJLEtBQUssQ0FDYjt5QkFDYSxTQUFTLElBQUksQ0FDM0IsQ0FBQztpQkFDSDthQUNGO1lBQ0QsS0FBSyxRQUFRLENBQUMsQ0FBQztnQkFDYixJQUFJLElBQUEsK0JBQWEsRUFBQyxLQUFLLENBQUMsRUFBRTtvQkFDeEIsTUFBTSxJQUFJLEtBQUssQ0FDYix3QkFBd0IsU0FBUyxvQkFBb0IsQ0FDdEQsQ0FBQztpQkFDSDtnQkFFRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQy9DLElBQUksZ0JBQWdCLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtvQkFDakMsTUFBTSxJQUFJLEtBQUssQ0FDYixrQkFBa0IsSUFBSSxDQUFDLFNBQVMsQ0FDOUIsS0FBSyxDQUNOLDBCQUEwQixTQUFTLEVBQUUsQ0FDdkMsQ0FBQztpQkFDSDtnQkFDRCxNQUFNLENBQUMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLENBQUMsQ0FBc0IsQ0FBQztnQkFFckUsSUFBSSxJQUFBLDZCQUFZLEVBQUMsUUFBUSxDQUFDLEVBQUU7b0JBQzFCLE9BQU8sSUFBSSxDQUFDLHFCQUFxQixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO2lCQUN0RTtxQkFBTTtvQkFDTCxPQUFPLElBQUksQ0FBQyx3QkFBd0IsQ0FDbEMsT0FBTyxFQUNQLFNBQVMsRUFDVCxRQUFRLEVBQ1IsR0FBRyxDQUNKLENBQUM7aUJBQ0g7YUFDRjtZQUNELE9BQU8sQ0FBQyxDQUFDO2dCQUNQLE1BQU0sSUFBSSxLQUFLLENBQ2Isd0JBQXdCLFNBQVMsb0NBQW9DLENBQ3RFLENBQUM7YUFDSDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLHFCQUFxQixDQUMzQixRQUF3RSxFQUN4RSxRQUFnQixFQUNoQixLQUFpQixFQUNqQixHQUFNO1FBRU4sUUFBUSxRQUFRLEVBQUU7WUFDaEIsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDNUIsT0FBTyxHQUFHLENBQUM7YUFDWjtZQUNELEtBQUssSUFBSSxDQUFDLENBQUM7Z0JBQ1QsR0FBRyxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sR0FBRyxDQUFDO2FBQ1o7WUFDRCxLQUFLLElBQUksQ0FBQyxDQUFDO2dCQUNULEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3hDLE9BQU8sR0FBRyxDQUFDO2FBQ1o7WUFDRCxLQUFLLElBQUksQ0FBQyxDQUFDO2dCQUNULEdBQUcsQ0FBQyxXQUFXLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNqQyxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxHQUFHLENBQUMscUJBQXFCLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUMzQyxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxHQUFHLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDL0IsT0FBTyxHQUFHLENBQUM7YUFDWjtZQUNELEtBQUssYUFBYSxDQUFDLENBQUM7Z0JBQ2xCLEdBQUcsQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dCQUNoQyxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsS0FBSyxVQUFVLENBQUMsQ0FBQztnQkFDZixHQUFHLENBQUMsUUFBUSxDQUFDLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDOUIsT0FBTyxHQUFHLENBQUM7YUFDWjtZQUNELEtBQUssZ0JBQWdCLENBQUMsQ0FBQztnQkFDckIsR0FBRyxDQUFDLGFBQWEsQ0FBQyxRQUFRLEVBQUUsS0FBdUIsQ0FBQyxDQUFDO2dCQUNyRCxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsT0FBTyxDQUFDLENBQUM7Z0JBQ1AsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsUUFBUSxFQUFFLENBQUMsQ0FBQzthQUN0RDtTQUNGO0lBQ0gsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLHdCQUF3QixDQUM5QixRQUFnQyxFQUNoQyxRQUFnQixFQUNoQixLQUFVLEVBQ1YsR0FBTTtRQUVOLFFBQVEsUUFBUSxFQUFFO1lBQ2hCLEtBQUssU0FBUyxDQUFDLENBQUM7Z0JBQ2QsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7b0JBQy9DLE1BQU0sSUFBSSxLQUFLLENBQ2Isc0JBQXNCLFFBQVEsOENBQThDLENBQzdFLENBQUM7aUJBQ0g7Z0JBQ0QsR0FBRyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsS0FBaUMsQ0FBQyxDQUFDO2dCQUN6RCxPQUFPLEdBQUcsQ0FBQzthQUNaO1lBQ0QsS0FBSyxJQUFJLENBQUMsQ0FBQztnQkFDVCxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtvQkFDN0MsTUFBTSxJQUFJLEtBQUssQ0FDYixzQkFBc0IsUUFBUSxnREFBZ0QsQ0FDL0UsQ0FBQztpQkFDSDtnQkFDRCxHQUFHLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxLQUFxQixDQUFDLENBQUM7Z0JBQ3hDLE9BQU8sR0FBRyxDQUFDO2FBQ1o7WUFDRCxLQUFLLE1BQU0sQ0FBQyxDQUFDO2dCQUNYLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDL0MsSUFBSSxnQkFBZ0IsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO29CQUNqQyxNQUFNLElBQUksS0FBSyxDQUNiLGtCQUFrQixJQUFJLENBQUMsU0FBUyxDQUM5QixLQUFLLENBQ04seUJBQXlCLFFBQVEsRUFBRSxDQUNyQyxDQUFDO2lCQUNIO2dCQUNELE1BQU0sQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQyxDQUFzQixDQUFDO2dCQUNyRSxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQzFDLE9BQU8sRUFDUCxRQUFRLEVBQ1IsUUFBUSxFQUNSLEdBQUcsQ0FDSixDQUFDO2dCQUNGLDREQUE0RDtnQkFDNUQsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDekIsT0FBTyxTQUFTLENBQUM7YUFDbEI7WUFDRCxPQUFPLENBQUMsQ0FBQztnQkFDUCxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixRQUFRLEVBQUUsQ0FBQyxDQUFDO2FBQ3REO1NBQ0Y7SUFDSCxDQUFDO0NBQ0Y7QUFyZUQsc0RBcWVDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQVRUUklCVVRFX1RZUEUsXG4gIFJhbmdlT3BlcmF0b3IsXG4gIFNjYWxhclR5cGUsXG4gIFNpbXBsZU9wZXJhdG9yLFxuICBVcGRhdGVUeXBlLFxufSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCB7aXNFbXB0eU9iamVjdH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1lbXB0eS1vYmplY3QnO1xuaW1wb3J0IHtLZXlDb25kaXRpb259IGZyb20gJy4va2V5LWNvbmRpdGlvbic7XG5pbXBvcnQge0ZpbHRlcn0gZnJvbSAnLi9maWx0ZXInO1xuaW1wb3J0IHtCYXNlRXhwcmVzc2lvbklucHV0LCBNRVJHRV9TVFJBVEVHWX0gZnJvbSAnLi9iYXNlLWV4cHJlc3Npb24taW5wdXQnO1xuaW1wb3J0IHtpc1NjYWxhclR5cGV9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtc2NhbGFyLXR5cGUnO1xuaW1wb3J0IHtGaWx0ZXJPcHRpb25zfSBmcm9tICcuL2ZpbHRlci1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtDb25kaXRpb25PcHRpb25zfSBmcm9tICcuL2NvbmRpdGlvbi1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtDb25kaXRpb259IGZyb20gJy4vY29uZGl0aW9uJztcbmltcG9ydCB7UHJvamVjdGlvbn0gZnJvbSAnLi9wcm9qZWN0aW9uJztcbmltcG9ydCB7S2V5Q29uZGl0aW9uT3B0aW9uc30gZnJvbSAnLi9rZXktY29uZGl0aW9uLW9wdGlvbnMtdHlwZSc7XG5pbXBvcnQge1Byb2plY3Rpb25LZXlzfSBmcm9tICcuL3Byb2plY3Rpb24ta2V5cy1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtpc1NldE9wZXJhdG9yQ29tcGxleFZhbHVlVHlwZSwgVXBkYXRlQm9keX0gZnJvbSAnLi91cGRhdGUtYm9keS10eXBlJztcbmltcG9ydCB7U2V0VXBkYXRlfSBmcm9tICcuL3VwZGF0ZS9zZXQtdXBkYXRlJztcbmltcG9ydCB7QWRkVXBkYXRlfSBmcm9tICcuL3VwZGF0ZS9hZGQtdXBkYXRlJztcbmltcG9ydCB7VXBkYXRlfSBmcm9tICcuL3VwZGF0ZS91cGRhdGUnO1xuXG5pbXBvcnQge0RlbGV0ZVVwZGF0ZX0gZnJvbSAnLi91cGRhdGUvZGVsZXRlLXVwZGF0ZSc7XG5pbXBvcnQge1JlbW92ZVVwZGF0ZX0gZnJvbSAnLi91cGRhdGUvcmVtb3ZlLXVwZGF0ZSc7XG5pbXBvcnQge2lzT2JqZWN0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLW9iamVjdCc7XG5pbXBvcnQge25lc3RlZEtleUFjY2Vzc1JlZ2V4fSBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cyc7XG5cbi8qKlxuICogUGFyc2VzIGV4cHJlc3Npb24gaW5wdXQgdG8gZXhwcmVzc2lvbiBpbnN0YW5jZXNcbiAqL1xuZXhwb3J0IGNsYXNzIEV4cHJlc3Npb25JbnB1dFBhcnNlciB7XG4gIHBhcnNlVG9LZXlDb25kaXRpb24oa2V5OiBzdHJpbmcsIG9wdGlvbnM6IEtleUNvbmRpdGlvbk9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRvclRvQmFzZUV4cHJlc3Npb24oa2V5LCBvcHRpb25zLCBuZXcgS2V5Q29uZGl0aW9uKCkpO1xuICB9XG5cbiAgcGFyc2VUb0ZpbHRlcjxFbnRpdHksIFByaW1hcnlLZXk+KFxuICAgIG9wdGlvbnM6IEZpbHRlck9wdGlvbnM8RW50aXR5LCBQcmltYXJ5S2V5PlxuICApIHtcbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVQYXJzZVRvQmFzZUV4cHJlc3Npb24ob3B0aW9ucywgRmlsdGVyKS5wb3AoKTtcbiAgfVxuXG4gIHBhcnNlVG9Db25kaXRpb248RW50aXR5PihvcHRpb25zOiBDb25kaXRpb25PcHRpb25zPEVudGl0eT4pIHtcbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVQYXJzZVRvQmFzZUV4cHJlc3Npb24ob3B0aW9ucywgQ29uZGl0aW9uKS5wb3AoKTtcbiAgfVxuXG4gIHBhcnNlVG9Qcm9qZWN0aW9uPEVudGl0eT4oa2V5czogUHJvamVjdGlvbktleXM8RW50aXR5Pikge1xuICAgIGNvbnN0IHByb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbigpO1xuICAgIHByb2plY3Rpb24uYWRkUHJvamVjdGlvbkF0dHJpYnV0ZXMoa2V5cyBhcyBzdHJpbmdbXSk7XG5cbiAgICByZXR1cm4gcHJvamVjdGlvbjtcbiAgfVxuXG4gIHBhcnNlVG9VcGRhdGU8RW50aXR5LCBBZGRpdGlvbmFsUHJvcGVydGllcyA9IHt9PihcbiAgICBib2R5OiBVcGRhdGVCb2R5PEVudGl0eSwgQWRkaXRpb25hbFByb3BlcnRpZXM+LFxuICAgIGF0dHJWYWx1ZU92ZXJyaWRlTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VUb1VwZGF0ZUV4cHJlc3Npb24oYm9keSwgYXR0clZhbHVlT3ZlcnJpZGVNYXApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBjb21wbGV4IHVwZGF0ZSBvYmplY3QgdG8gYSB2YWx1ZSBhbmQgdHlwZVxuICAgKi9cbiAgcGFyc2VBdHRyaWJ1dGVUb1VwZGF0ZVZhbHVlKFxuICAgIGF0dHI6IHN0cmluZyxcbiAgICB2YWx1ZTogYW55XG4gICk6IHt2YWx1ZTogYW55OyB0eXBlOiAnc3RhdGljJyB8ICdkeW5hbWljJ30ge1xuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzRW1wdHlPYmplY3QodmFsdWUpKSB7XG4gICAgICBjb25zdCBbb3BlcmF0b3IsIG9wZXJhdG9yVmFsdWVdID0gT2JqZWN0LmVudHJpZXModmFsdWUgYXMgYW55KVswXTtcblxuICAgICAgY29uc3QgcGFyc2VkVXBkYXRlID0gdGhpcy5wYXJzZVZhbHVlVG9VcGRhdGVFeHAoXG4gICAgICAgIGF0dHIsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcGVyYXRvciBhcyBhbnksXG4gICAgICAgIG9wZXJhdG9yVmFsdWVcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gT2JqZWN0LnZhbHVlcyhwYXJzZWRVcGRhdGUudmFsdWVzID8/IHt9KVswXTtcblxuICAgICAgLy8gaWYgZXhwcmVzc2lvbiBjb250YWlucyBhbnkgZHluYW1pYyBvcGVyYXRpb24gc3VjaCBhcyB2YWx1ZSBtYW5pcHVsYXRpb24gb3IgbmVzdGVkIGF0dHJpYnV0ZSBtYW5pcHVsYXRpb24gaW4gYSBsaXN0XG4gICAgICBpZiAoXG4gICAgICAgICEocGFyc2VkVXBkYXRlIGluc3RhbmNlb2YgU2V0VXBkYXRlKSB8fFxuICAgICAgICBwYXJzZWRVcGRhdGUuZXhwcmVzc2lvbi5pbmNsdWRlcygnICsgJykgfHxcbiAgICAgICAgcGFyc2VkVXBkYXRlLmV4cHJlc3Npb24uaW5jbHVkZXMoJyAtICcpIHx8XG4gICAgICAgIG5lc3RlZEtleUFjY2Vzc1JlZ2V4LnRlc3QocGFyc2VkVXBkYXRlLmV4cHJlc3Npb24pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZTogcGFyc2VkVmFsdWUsXG4gICAgICAgICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gc3RhdGljIHZhbHVlXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnc3RhdGljJyxcbiAgICAgICAgdmFsdWU6IHBhcnNlZFZhbHVlLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaWYgdHJpZWQgdG8gdXBkYXRlIG5lc3RlZCB2YWx1ZSBmb3Iga2V5LCBpdCBpcyBjb25zaWRlcmVkIGR5bmFtaWMsIGFzIHdlIGRvIG5vdCBrbm93IGZ1bGwgdmFsdWUgb2YgdXBkYXRpbmcgYXR0cmlidXRlXG4gICAgICBpZiAobmVzdGVkS2V5QWNjZXNzUmVnZXgudGVzdChhdHRyKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiB2YWx1ZSBhcyBhIGRlZmF1bHQgdmFsdWVcbiAgICAgIHJldHVybiB7dHlwZTogJ3N0YXRpYycsIHZhbHVlfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJpYyBSZWN1cnNpdmUgaW5wdXQgcGFyc2VyXG4gICAqIFJlY3Vyc2l2ZWx5IHBhcnNlcyBuZXN0ZWQgb2JqZWN0IHRvIGJ1aWxkIGV4cHJlc3Npb24gb2YgdHlwZSBFeHBDbGFzc1xuICAgKiBAcGFyYW0gb3B0aW9ucyBDb21wbGV4IG9wdGlvbnMgb2JqZWN0IHRvIHBhcnNlXG4gICAqIEBwYXJhbSBFeHBDbGFzcyBUeXBlIG9mIGV4cHJlc3Npb24gdG8gYnVpbGQsIGNhbiBiZSBvZiB0eXBlIEZpbHRlciwgQ29uZGl0aW9uIGV0Yy5cbiAgICpcbiAgICovXG4gIHByaXZhdGUgcmVjdXJzaXZlUGFyc2VUb0Jhc2VFeHByZXNzaW9uPFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0PihcbiAgICBvcHRpb25zOiBhbnksXG4gICAgRXhwQ2xhc3M6IG5ldyAoKSA9PiBUXG4gICkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvcHRpb25zKS5tYXAoKFtvcGVyYXRvck9yQXR0ciwgdmFsdWVdKTogVCA9PiB7XG4gICAgICAvLyBpZiB0b3AgbGV2ZWwga2V5IGlzIG9uZSBvZiB0aGUgbG9naWNhbCBvcGVyYXRvcnMsIHJlcnVuIHBhcnNlIHdpdGggaXQncyB2YWx1ZXNcbiAgICAgIGlmIChbJ0FORCcsICdPUicsICdOT1QnXS5pbmNsdWRlcyhvcGVyYXRvck9yQXR0cikpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXhwTGlzdCA9IHRoaXMucmVjdXJzaXZlUGFyc2VUb0Jhc2VFeHByZXNzaW9uPFQ+KFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIEV4cENsYXNzXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBwYXJzZWRFeHBMaXN0LnNoaWZ0KCk7XG4gICAgICAgIGlmICghYmFzZSkge1xuICAgICAgICAgIHJldHVybiBuZXcgRXhwQ2xhc3MoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wZXJhdG9yT3JBdHRyKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzoge1xuICAgICAgICAgICAgaWYgKCFwYXJzZWRFeHBMaXN0Py5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5tZXJnZU1hbnkocGFyc2VkRXhwTGlzdCBhcyBUW10sIE1FUkdFX1NUUkFURUdZLkFORCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ09SJzoge1xuICAgICAgICAgICAgaWYgKCFwYXJzZWRFeHBMaXN0Py5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5tZXJnZU1hbnkocGFyc2VkRXhwTGlzdCBhcyBUW10sIE1FUkdFX1NUUkFURUdZLk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnTk9UJzoge1xuICAgICAgICAgICAgLy8gbm90IGNhbiBub3QgY29udGFpbiBtb3JlIHRoYW4gb25lIGl0ZW1zXG4gICAgICAgICAgICBpZiAocGFyc2VkRXhwTGlzdD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVmFsdWUgZm9yIG9wZXJhdG9yIFwiJHtvcGVyYXRvck9yQXR0cn1cIiBjYW4gbm90IGNvbnRhaW4gbW9yZSB0aGFuIDEgYXR0cmlidXRlcy5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5ub3QoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dpY2FsIG9wZXJhdG9yIFwiJHtvcGVyYXRvck9yQXR0cn1cImApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gd2hlbiB0b3AgbGV2ZWwgYXR0cmlidXRlIGlzIHNvbWV0aGluZyBvdGhlciB0aGFuIGFjdHVhbCBsb2dpY2FsIG9wZXJhdG9ycywgdHJ5IHRvIHBhcnNlIGl0IHRvIGV4cHJlc3Npb25cbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3JUb0Jhc2VFeHByZXNzaW9uKFxuICAgICAgICAgIG9wZXJhdG9yT3JBdHRyLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIG5ldyBFeHBDbGFzcygpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIGlucHV0IHRvIHVwZGF0ZSBleHByZXNzaW9uXG4gICAqIEBwYXJhbSBib2R5IGJvZHkgdG8gcGFyc2VcbiAgICovXG4gIHByaXZhdGUgcGFyc2VUb1VwZGF0ZUV4cHJlc3Npb24oXG4gICAgYm9keTogYW55LFxuICAgIGF0dHJWYWx1ZU92ZXJyaWRlTWFwOiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4gICkge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3QuZW50cmllcyhib2R5KVxuICAgICAgICAubWFwKChbYXR0ciwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtvcGVyYXRvciwgb3BlcmF0b3JWYWx1ZV0gPSBPYmplY3QuZW50cmllcyhcbiAgICAgICAgICAgICAgdmFsdWUgYXMgYW55XG4gICAgICAgICAgICApWzBdIGFzIFtcbiAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgIHwgVXBkYXRlVHlwZS5Bcml0aG1ldGljT3BlcmF0b3JcbiAgICAgICAgICAgICAgICB8IFVwZGF0ZVR5cGUuU2V0VXBkYXRlT3BlcmF0b3JcbiAgICAgICAgICAgICAgICB8IFVwZGF0ZVR5cGUuQWN0aW9uXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIGFueVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZVRvVXBkYXRlRXhwKFxuICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgIG9wZXJhdG9yVmFsdWUsXG4gICAgICAgICAgICAgIGF0dHJWYWx1ZU92ZXJyaWRlTWFwW2F0dHJdIC8vIGdldCBhbnkgb3ZlcnJpZGUgdmFsdWUgaWYgZXhpc3RzXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmYWxsYmFjayB0byBkZWZhdWx0IGBTRVRgIGFjdGlvbiBiYXNlZCB1cGRhdGVcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG8oXG4gICAgICAgICAgICAgIGF0dHIsXG4gICAgICAgICAgICAgIGF0dHJWYWx1ZU92ZXJyaWRlTWFwW2F0dHJdIHx8IHZhbHVlXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gbWVyZ2UgYWxsIGV4cHJlc3Npb25zIHdpdGggbWF0Y2hpbmcgYWN0aW9uXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgKGFjYywgY3VyckV4cCkgPT4ge1xuICAgICAgICAgICAgYWNjXG4gICAgICAgICAgICAgIC5maW5kKGluc3RhbmNlID0+IGluc3RhbmNlLmNvbnN0cnVjdG9yID09PSBjdXJyRXhwLmNvbnN0cnVjdG9yKSFcbiAgICAgICAgICAgICAgLm1lcmdlKGN1cnJFeHApO1xuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICB9LFxuICAgICAgICAgIFtcbiAgICAgICAgICAgIG5ldyBTZXRVcGRhdGUoKSxcbiAgICAgICAgICAgIG5ldyBBZGRVcGRhdGUoKSxcbiAgICAgICAgICAgIG5ldyBSZW1vdmVVcGRhdGUoKSxcbiAgICAgICAgICAgIG5ldyBEZWxldGVVcGRhdGUoKSxcbiAgICAgICAgICBdXG4gICAgICAgIClcbiAgICAgICAgLy8gbWVyZ2UgYWxsIGV4cHJlc3Npb25zIG9mIGRpZmZlcmVudCBhY3Rpb25zXG4gICAgICAgIC5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICAgIGFjYy5tZXJnZShjdXJyKTtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9LCBuZXcgVXBkYXRlKCkpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgc2luZ2xlIGF0dHJpYnV0ZSBpbnRvIHVwZGF0ZSBleHByZXNzaW9uIGluc3RhbmNlXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGUgbmFtZS9wYXRoIG9mIHRoZSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIGF0dHJpYnV0ZVZhbHVlIHZhbHVlIHRvIHVwZGF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZVZhbHVlVG9VcGRhdGVFeHAoXG4gICAgYXR0cmlidXRlOiBzdHJpbmcsXG4gICAgYXR0cmlidXRlVmFsdWU6IGFueSwgLy8gYXR0cmlidXRlIHZhbHVlIHRvIHNldFxuICAgIG9wZXJhdG9yOlxuICAgICAgfCBVcGRhdGVUeXBlLkFyaXRobWV0aWNPcGVyYXRvclxuICAgICAgfCBVcGRhdGVUeXBlLlNldFVwZGF0ZU9wZXJhdG9yXG4gICAgICB8IFVwZGF0ZVR5cGUuQWN0aW9uLFxuICAgIG9wZXJhdG9yVmFsdWU6IGFueSxcbiAgICBzdGF0aWNWYWx1ZVRvT3ZlcnJpZGU/OiBhbnkgLy8gdmFsdWUgdG8gb3ZlcnJpZGUgZm9yIGF0dHJpYnV0ZSwgdGhpcyBpcyBzZXQgaW4gY2FzZXMgd2hlcmUgdGhlcmUgd2FzIGEgY3VzdG9tIHByb3BlcnR5IHRyYW5zZm9ybSB3YXMgcmVxdWVzdGVkXG4gICk6IFVwZGF0ZSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnSU5DUkVNRU5UX0JZJzpcbiAgICAgIGNhc2UgJ0RFQ1JFTUVOVF9CWSc6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXRVcGRhdGUoKS5zZXRUbyhhdHRyaWJ1dGUsIG9wZXJhdG9yVmFsdWUsIG9wZXJhdG9yKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0lGX05PVF9FWElTVFMnOiB7XG4gICAgICAgIGlmIChpc1NldE9wZXJhdG9yQ29tcGxleFZhbHVlVHlwZShvcGVyYXRvclZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG9JZk5vdEV4aXN0cyhcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHN0YXRpY1ZhbHVlVG9PdmVycmlkZSB8fCBvcGVyYXRvclZhbHVlLiRWQUxVRSxcbiAgICAgICAgICAgIG9wZXJhdG9yVmFsdWUuJFBBVEhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG9JZk5vdEV4aXN0cyhhdHRyaWJ1dGUsIG9wZXJhdG9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlICdMSVNUX0FQUEVORCc6IHtcbiAgICAgICAgaWYgKGlzU2V0T3BlcmF0b3JDb21wbGV4VmFsdWVUeXBlKG9wZXJhdG9yVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXRVcGRhdGUoKS5zZXRPckFwcGVuZFRvTGlzdChcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG9wZXJhdG9yVmFsdWUuJFZBTFVFLFxuICAgICAgICAgICAgb3BlcmF0b3JWYWx1ZS4kUEFUSFxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXRVcGRhdGUoKS5zZXRPckFwcGVuZFRvTGlzdChhdHRyaWJ1dGUsIG9wZXJhdG9yVmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlICdTRVQnOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhbGlhc2VkIHNldCBzdXBwb3J0LCB0aGlzIGFsbG93cyBhY2Nlc3MgcGF0dGVybnMgbGlrZVxuICAgICAgICAgKiB7aWQ6IHsgU0VUOiAnMSd9fVxuICAgICAgICAgKiBiZWhhdmVzIHNpbWlsYXIgdG8ge2lkOiAnMSd9XG4gICAgICAgICAqL1xuICAgICAgICAvLyBoYW5kbGUgZXhwbGljaXQgc2V0IGV4cFxuICAgICAgICBpZiAoaXNPYmplY3Qob3BlcmF0b3JWYWx1ZSkgJiYgIWlzRW1wdHlPYmplY3Qob3BlcmF0b3JWYWx1ZSkpIHtcbiAgICAgICAgICBjb25zdCBbbmVzdGVkT3BlcmF0b3IsIG5lc3RlZE9wZXJhdG9yVmFsdWVdID0gT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICBvcGVyYXRvclZhbHVlXG4gICAgICAgICAgKVswXSBhcyBbXG4gICAgICAgICAgICBVcGRhdGVUeXBlLkFyaXRobWV0aWNPcGVyYXRvciB8IFVwZGF0ZVR5cGUuU2V0VXBkYXRlT3BlcmF0b3IsXG4gICAgICAgICAgICBhbnlcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWYWx1ZVRvVXBkYXRlRXhwKFxuICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgbmVzdGVkT3BlcmF0b3JWYWx1ZSxcbiAgICAgICAgICAgIG5lc3RlZE9wZXJhdG9yLFxuICAgICAgICAgICAgbmVzdGVkT3BlcmF0b3JWYWx1ZSxcbiAgICAgICAgICAgIHN0YXRpY1ZhbHVlVG9PdmVycmlkZVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaGFuZGxlIGF0dHJpYnV0ZSB3aXRoIG1hcCB0eXBlXG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXRVcGRhdGUoKS5zZXRUbyhcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHN0YXRpY1ZhbHVlVG9PdmVycmlkZSB8fCBvcGVyYXRvclZhbHVlXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnQUREJzoge1xuICAgICAgICBpZiAoaXNFbXB0eU9iamVjdChvcGVyYXRvclZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlICR7b3BlcmF0b3JWYWx1ZX0gcmVjZWl2ZWQgZm9yIGFjdGlvbiBcIkFERFwiLCBPbmx5IG51bWJlcnMgYW5kIGxpc3RzIGFyZSBzdXBwb3J0ZWQuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBZGRVcGRhdGUoKS5hZGRUbyhhdHRyaWJ1dGUsIG9wZXJhdG9yVmFsdWUpO1xuICAgICAgfVxuICAgICAgY2FzZSAnREVMRVRFJzoge1xuICAgICAgICByZXR1cm4gbmV3IERlbGV0ZVVwZGF0ZSgpLmRlbGV0ZShhdHRyaWJ1dGUsIG9wZXJhdG9yVmFsdWUpO1xuICAgICAgfVxuICAgICAgY2FzZSAnUkVNT1ZFJzoge1xuICAgICAgICBpZiAodHlwZW9mIG9wZXJhdG9yVmFsdWUgPT09ICdib29sZWFuJyAmJiAhIW9wZXJhdG9yVmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFJlbW92ZVVwZGF0ZSgpLnJlbW92ZShhdHRyaWJ1dGUpO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICFpc0VtcHR5T2JqZWN0KG9wZXJhdG9yVmFsdWUpICYmXG4gICAgICAgICAgQXJyYXkuaXNBcnJheShvcGVyYXRvclZhbHVlLiRBVF9JTkRFWClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVVcGRhdGUoKS5yZW1vdmUoYXR0cmlidXRlLCB7XG4gICAgICAgICAgICBhdEluZGV4ZXM6IG9wZXJhdG9yVmFsdWUuJEFUX0lOREVYLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlICR7b3BlcmF0b3JWYWx1ZX0gcmVjZWl2ZWQgZm9yIGFjdGlvbiBcIlJFTU9WRVwiLiBWYWx1ZSBtdXN0IGJlIHNldCB0byBib29sZWFuXG4gICAgICAgICAgICBJbiBhZGRpdGlvbiwgWW91IG1heSB1c2Ugc3BlY2lhbCB2YWx1ZSB0eXBlIHskQVRfSU5ERVg6IEFycmF5PG51bWJlcj59IGZvciBhdHRyaWJ1dGUgb2YgdHlwZSBsaXN0Li5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICAvLyBoYW5kbGUgYXR0cmlidXRlIHdpdGggbWFwIHR5cGVcbiAgICAgICAgcmV0dXJuIG5ldyBTZXRVcGRhdGUoKS5zZXRUbyhcbiAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgc3RhdGljVmFsdWVUb092ZXJyaWRlIHx8IGF0dHJpYnV0ZVZhbHVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gdGhpcyBpcyBydW4sIGl0IGlzIGFzc3VtZWQgdGhhdCBhdHRyaWJ1dGUvdmFsdWUgYXJlIHZhbGlkYXRlZCB0byBub3QgaGF2ZSBhbnkgbmVzdGVkIG9iamVjdHMsXG4gICAqIHRoZXJlZm9yIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgcnVubmluZyBpbiBhbnkgcmVjdXJzaW9uIGl0c2VsZlxuICAgKiBAcGFyYW0gYXR0cmlidXRlIEF0dHJpYnV0ZSBvciBwYXRoIG9uIGVudGl0eSB0byBidWlsZCBjb21wYXJpc29uIGNvbmRpdGlvbiBmb3JcbiAgICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGV4cGVjdFxuICAgKiBAcGFyYW0gZXhwIGV4cHJlc3Npb24gdG8gYXBwZW5kIG9wZXJhdG9ycyB0b1xuICAgKi9cbiAgcHJpdmF0ZSBvcGVyYXRvclRvQmFzZUV4cHJlc3Npb248VCBleHRlbmRzIEJhc2VFeHByZXNzaW9uSW5wdXQ+KFxuICAgIGF0dHJpYnV0ZTogYW55LFxuICAgIHZhbHVlOiBhbnksXG4gICAgZXhwOiBUXG4gICkge1xuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOiB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ0FUVFJJQlVURV9FWElTVFMnKSB7XG4gICAgICAgICAgZXhwLmF0dHJpYnV0ZUV4aXN0cyhhdHRyaWJ1dGUpO1xuICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09ICdBVFRSSUJVVEVfTk9UX0VYSVNUUycpIHtcbiAgICAgICAgICBleHAuYXR0cmlidXRlTm90RXhpc3RzKGF0dHJpYnV0ZSk7XG4gICAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgT3BlcmF0b3IgdXNlZCBtdXN0IGJlIG9uZSBvZiBcIkFUVFJJQlVURV9FWElTVFNcIiwgXCJBVFRSSUJVVEVfTk9UX0VYSVNUU1wiIGZvciBcbiAgICAgICAgICAgIGF0dHJpYnV0ZSBcIiR7YXR0cmlidXRlfVwiLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYXNlICdvYmplY3QnOiB7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBWYWx1ZSBmb3IgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGV9XCIgY2FuIG5vdCBiZSBlbXB0eWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3BlcmF0b3JBbmRWYWx1ZSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlKTtcbiAgICAgICAgaWYgKG9wZXJhdG9yQW5kVmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgKX1cIiBmb3VuZCBmb3IgYXR0cmlidXRlOiAke2F0dHJpYnV0ZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5uZXJPcCwgaW5uZXJWYWxdID0gb3BlcmF0b3JBbmRWYWx1ZVswXSBhcyBbYW55LCBTY2FsYXJUeXBlXTtcblxuICAgICAgICBpZiAoaXNTY2FsYXJUeXBlKGlubmVyVmFsKSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NhbGFyVmFsdWVUb0V4cChpbm5lck9wLCBhdHRyaWJ1dGUsIGlubmVyVmFsLCBleHApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlTm9uU2NhbGFyVmFsdWVUb0V4cChcbiAgICAgICAgICAgIGlubmVyT3AsXG4gICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICBpbm5lclZhbCxcbiAgICAgICAgICAgIGV4cFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBWYWx1ZSBmb3IgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGV9XCIgbXVzdCBiZSBvZiB0eXBlIG9iamVjdCBvciBzdHJpbmdgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBjb21wYXJpc29uIGV4cHJlc3Npb24gZm9yIG9wZXJhdG9ycyB3aXRoIHNjYWxhciB2YWx1ZXNcbiAgICogQHBhcmFtIG9wZXJhdG9yIG9wZXJhdG9yIHRoYXQgc3VwcG9ydHMgc2NhbGFyIHZhbHVlc1xuICAgKiBAcGFyYW0gYXR0clBhdGggYXR0cmlidXRlIHBhdGggdG8gaW5jbHVkZSBpbiBidWlsdCBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBleHBlY3QgaW4gZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gZXhwIGV4cHJlc3Npb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZVNjYWxhclZhbHVlVG9FeHA8VCBleHRlbmRzIEJhc2VFeHByZXNzaW9uSW5wdXQ+KFxuICAgIG9wZXJhdG9yOiBTaW1wbGVPcGVyYXRvciB8ICdCRUdJTlNfV0lUSCcgfCAnQ09OVEFJTlMnIHwgJ0FUVFJJQlVURV9UWVBFJyxcbiAgICBhdHRyUGF0aDogc3RyaW5nLFxuICAgIHZhbHVlOiBTY2FsYXJUeXBlLFxuICAgIGV4cDogVFxuICApIHtcbiAgICBzd2l0Y2ggKG9wZXJhdG9yKSB7XG4gICAgICBjYXNlICdFUSc6IHtcbiAgICAgICAgZXhwLmVxdWFscyhhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnTFQnOiB7XG4gICAgICAgIGV4cC5sZXNzVGhhbihhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnTEUnOiB7XG4gICAgICAgIGV4cC5sZXNzVGhhbkFuZEVxdWFsVG8oYXR0clBhdGgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0dUJzoge1xuICAgICAgICBleHAuZ3JlYXRlclRoYW4oYXR0clBhdGgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0dFJzoge1xuICAgICAgICBleHAuZ3JlYXRlclRoYW5BbmRFcXVhbFRvKGF0dHJQYXRoLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdORSc6IHtcbiAgICAgICAgZXhwLm5vdEVxdWFscyhhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnQkVHSU5TX1dJVEgnOiB7XG4gICAgICAgIGV4cC5iZWdpbnNXaXRoKGF0dHJQYXRoLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdDT05UQUlOUyc6IHtcbiAgICAgICAgZXhwLmNvbnRhaW5zKGF0dHJQYXRoLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdBVFRSSUJVVEVfVFlQRSc6IHtcbiAgICAgICAgZXhwLmF0dHJpYnV0ZVR5cGUoYXR0clBhdGgsIHZhbHVlIGFzIEFUVFJJQlVURV9UWVBFKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGNvbXBhcmlzb24gZXhwcmVzc2lvbiBmb3Igb3BlcmF0b3JzIHdpdGggTm9uIHNjYWxhciB2YWx1ZXMsIGkuZSByYW5nZXMgYW5kIHNpemVcbiAgICogQHBhcmFtIG9wZXJhdG9yIG9wZXJhdG9yIHRoYXQgc3VwcG9ydHMgc2NhbGFyIHZhbHVlc1xuICAgKiBAcGFyYW0gYXR0clBhdGggYXR0cmlidXRlIHBhdGggdG8gaW5jbHVkZSBpbiBidWlsdCBleHByZXNzaW9uXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBleHBlY3QgaW4gZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gZXhwIGV4cHJlc3Npb24gdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZU5vblNjYWxhclZhbHVlVG9FeHA8VCBleHRlbmRzIEJhc2VFeHByZXNzaW9uSW5wdXQ+KFxuICAgIG9wZXJhdG9yOiBSYW5nZU9wZXJhdG9yIHwgJ1NJWkUnLFxuICAgIGF0dHJQYXRoOiBzdHJpbmcsXG4gICAgdmFsdWU6IGFueSxcbiAgICBleHA6IFRcbiAgKSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnQkVUV0VFTic6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yIG9wZXJhdG9yICR7b3BlcmF0b3J9IG11c3QgYmUgb2YgdHlwZSBhcnJheSB3aXRoIGV4YWN0IHR3byBpdGVtcy5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBleHAuYmV0d2VlbihhdHRyUGF0aCwgdmFsdWUgYXMgW1NjYWxhclR5cGUsIFNjYWxhclR5cGVdKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0lOJzoge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yIG9wZXJhdG9yICR7b3BlcmF0b3J9IG11c3QgYmUgb2YgdHlwZSBhcnJheSB3aXRoIGF0IGxlYXN0IG9uZSBpdGVtLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGV4cC5pbihhdHRyUGF0aCwgdmFsdWUgYXMgU2NhbGFyVHlwZVtdKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1NJWkUnOiB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yQW5kVmFsdWUgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvckFuZFZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICl9XCIgZm91bmQgZm9yIG9wZXJhdG9yOiAke29wZXJhdG9yfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtpbm5lck9wLCBpbm5lclZhbF0gPSBvcGVyYXRvckFuZFZhbHVlWzBdIGFzIFthbnksIFNjYWxhclR5cGVdO1xuICAgICAgICBjb25zdCBwYXJzZWRFeHAgPSB0aGlzLnBhcnNlU2NhbGFyVmFsdWVUb0V4cChcbiAgICAgICAgICBpbm5lck9wLFxuICAgICAgICAgIGF0dHJQYXRoLFxuICAgICAgICAgIGlubmVyVmFsLFxuICAgICAgICAgIGV4cFxuICAgICAgICApO1xuICAgICAgICAvLyBvbmNlIG9wZXJhdG9yIGNvbmRpdGlvbiBoYXMgYXBwbGllZCwgcGFzcyBpdCB0aHJvdWdoIHNpemVcbiAgICAgICAgcGFyc2VkRXhwLnNpemUoYXR0clBhdGgpO1xuICAgICAgICByZXR1cm4gcGFyc2VkRXhwO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9wZXJhdG9yOiAke29wZXJhdG9yfWApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl19