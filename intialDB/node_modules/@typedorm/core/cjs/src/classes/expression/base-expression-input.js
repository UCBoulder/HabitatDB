"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseExpressionInput = exports.MERGE_STRATEGY = void 0;
const constants_1 = require("../../helpers/constants");
const lastCharSpaceMatcher = /\s$/;
var MERGE_STRATEGY;
(function (MERGE_STRATEGY) {
    MERGE_STRATEGY["AND"] = "AND";
    MERGE_STRATEGY["OR"] = "OR";
})(MERGE_STRATEGY = exports.MERGE_STRATEGY || (exports.MERGE_STRATEGY = {}));
class BaseExpressionInput {
    constructor() {
        this.expression = '';
    }
    set names(value) {
        this._names = Object.assign(Object.assign({}, this.names), value);
    }
    get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : {};
    }
    set values(value) {
        this._values = Object.assign(Object.assign({}, this.values), value);
    }
    get values() {
        var _a;
        return (_a = this._values) !== null && _a !== void 0 ? _a : {};
    }
    appendToExpression(segment) {
        if (!segment) {
            return;
        }
        if (this.expression.length === 0) {
            this.expression += segment;
            return;
        }
        if (!this.hasSpaceInLastChar(this.expression)) {
            this.expression += ' '; // append empty space if does not exist
        }
        this.expression += segment;
    }
    addExpressionName(name) {
        // when trying to access nested prop i.e profile.name, replace . with appropriate expression safe string
        const nestedKeys = name.split('.');
        const topKey = nestedKeys.shift();
        if (!topKey) {
            throw new Error('Expression attribute name can not be empty');
        }
        const topLevelPropKey = this.innerAddExpressionName(topKey);
        return nestedKeys.reduce((acc, keySeg) => {
            let { prefix } = acc;
            // make sure that prefix does not contain any nested value reference
            prefix = prefix.replace(constants_1.nestedKeyAccessRegex, '');
            const currentSegPropKey = this.innerAddExpressionName(`${prefix}_${keySeg}`, keySeg);
            acc.prefix += `_${keySeg}`;
            acc.encoded += `.${currentSegPropKey}`;
            return acc;
        }, { prefix: topKey, encoded: topLevelPropKey }).encoded;
    }
    innerAddExpressionName(nameKey, nameValue) {
        // match any nested list item reference, and update it to be valid expression
        // i.e key such as addresses[0] will be name #addresses with expression #addresses[0]
        let match = '';
        nameKey = nameKey.replace(constants_1.nestedKeyAccessRegex, substr => {
            match = substr;
            return '';
        });
        nameValue = nameValue === null || nameValue === void 0 ? void 0 : nameValue.replace(match, '');
        const expressionPrefixedName = this.getExpNameKey(nameKey);
        if (this.names[expressionPrefixedName]) {
            throw new Error(`There is already an expression name with key ${expressionPrefixedName}.`);
        }
        this.names = Object.assign(Object.assign({}, this.names), { [expressionPrefixedName]: nameValue !== null && nameValue !== void 0 ? nameValue : nameKey });
        return expressionPrefixedName + match;
    }
    addExpressionValue(name, value) {
        const expressionSafeName = name.replace(/\./g, '_');
        return this.innerAddExpressionValue(expressionSafeName, value);
    }
    innerAddExpressionValue(name, value) {
        // remove any nested list item reference, it will be handled by names matcher
        // i.e key such as addresses[0]
        name = name.replace(constants_1.nestedKeyAccessRegex, '');
        const expressionPrefixedValue = this.getExpValueKey(name);
        if (this.values[expressionPrefixedValue]) {
            throw new Error(`There is already an expression value with key ${expressionPrefixedValue}.`);
        }
        this.values = Object.assign(Object.assign({}, this.values), { [expressionPrefixedValue]: value });
        return expressionPrefixedValue;
    }
    merge(condition, strategy = MERGE_STRATEGY.AND) {
        const { expression, names, values } = condition;
        // if merging condition does not have anything to merge return
        if (!expression) {
            return this;
        }
        // if base condition does not have any expression replace
        if (!this.expression) {
            this.expression += expression;
            this.names = names;
            this.values = values;
            return this;
        }
        if (strategy === MERGE_STRATEGY.OR) {
            this.or().appendToExpression(`(${expression})`);
        }
        else {
            this.and().appendToExpression(`(${expression})`);
        }
        Object.keys(names).forEach(nameKey => {
            if (this.names[nameKey]) {
                throw new Error(`Failed to merge expression attribute names, there are multiple attributes names with key "${nameKey}"`);
            }
        });
        Object.keys(values).forEach(valueKey => {
            if (this.names[valueKey]) {
                throw new Error(`Failed to merge expression attribute values, there are multiple attributes values with key "${valueKey}"`);
            }
        });
        this.names = Object.assign(Object.assign({}, this.names), names);
        this.values = Object.assign(Object.assign({}, this.values), values);
        return this;
    }
    mergeMany(inputs, strategy) {
        // check if base expression has any value
        if (this.expression) {
            this.expression = `(${this.expression})`;
            this.appendToExpression(strategy);
        }
        inputs.forEach((input, index) => {
            this.appendToExpression(`(${input.expression})`);
            if (index !== inputs.length - 1) {
                this.appendToExpression(strategy);
            }
            Object.keys(input.names).forEach(nameKey => {
                if (this.names[nameKey]) {
                    throw new Error(`Failed to merge expression attribute names, there are multiple attributes names with key "${nameKey}"`);
                }
            });
            Object.keys(input.values).forEach(valueKey => {
                if (this.names[valueKey]) {
                    throw new Error(`Failed to merge expression attribute values, there are multiple attributes values with key "${valueKey}"`);
                }
            });
            this.names = Object.assign(Object.assign({}, this.names), input.names);
            this.values = Object.assign(Object.assign({}, this.values), input.values);
        });
        return this;
    }
    /** Use merge instead
     * @deprecated
     */
    and() {
        this.expression = `(${this.expression})`;
        this.appendToExpression('AND');
        return this;
    }
    not(condition) {
        if (condition) {
            this.expression = `NOT (${condition.expression})`;
            this.names = condition.names;
            this.values = condition.values;
            return this;
        }
        else {
            if (!this.expression) {
                return this;
            }
            this.expression = `NOT (${this.expression})`;
            return this;
        }
    }
    /**
     * Use merge instead
     * @deprecated
     */
    or() {
        this.expression = `(${this.expression})`;
        this.appendToExpression('OR');
        return this;
    }
    beginsWith(key, substring) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, substring);
        this.appendToExpression(`begins_with(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    contains(key, value) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        this.appendToExpression(`contains(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    attributeType(key, type) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, type);
        this.appendToExpression(`attribute_type(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    attributeExists(attr) {
        const attrName = this.addExpressionName(attr);
        this.appendToExpression(`attribute_exists(${attrName})`);
        return this;
    }
    attributeNotExists(attr) {
        const attrName = this.addExpressionName(attr);
        this.appendToExpression(`attribute_not_exists(${attrName})`);
        return this;
    }
    equals(key, value) {
        return this.addBaseOperator('EQ', key, value);
    }
    lessThan(key, value) {
        return this.addBaseOperator('LT', key, value);
    }
    lessThanAndEqualTo(key, value) {
        return this.addBaseOperator('LE', key, value);
    }
    greaterThan(key, value) {
        return this.addBaseOperator('GT', key, value);
    }
    greaterThanAndEqualTo(key, value) {
        return this.addBaseOperator('GE', key, value);
    }
    notEquals(key, value) {
        return this.addBaseOperator('NE', key, value);
    }
    between(key, value) {
        if (value.length !== 2) {
            throw new Error('Incorrect query value for BETWEEN operator, it requires array containing two values.');
        }
        const [startIncluding, endIncluding] = value;
        const attrExpName = this.addExpressionName(key);
        const attrExpValueStart = this.addExpressionValue(`${key}_start`, startIncluding);
        const attrExpValueEnd = this.addExpressionValue(`${key}_end`, endIncluding);
        this.appendToExpression(`${attrExpName} BETWEEN ${attrExpValueStart} AND ${attrExpValueEnd}`);
        return this;
    }
    in(key, values) {
        if (values.length < 1) {
            throw new Error('Incorrect value for IN operator, it requires array containing at lease one SCALAR type value.');
        }
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = values.reduce((acc, value, index) => {
            const attrExpValueStart = this.addExpressionValue(`${key}_${index}`, value);
            acc += attrExpValueStart;
            if (index !== values.length - 1) {
                // if not last index append separator followed by space
                acc += ', ';
            }
            return acc;
        }, '');
        this.appendToExpression(`${attrExpName} IN (${attrExpValue})`);
        return this;
    }
    size(key) {
        const attrExpName = this.getExpNameKey(key);
        this.expression = this.expression.replace(attrExpName, `size(${attrExpName})`);
        return this;
    }
    addBaseOperator(operator, key, value) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        this.appendToExpression(`${attrExpName} ${this.getSymbolForOperator(operator)} ${attrExpValue}`);
        return this;
    }
    getSymbolForOperator(operator) {
        const symbolMap = {
            EQ: '=',
            LE: '<=',
            LT: '<',
            GE: '>=',
            GT: '>',
            NE: '<>',
        };
        return symbolMap[operator];
    }
    hasSpaceInLastChar(match) {
        return lastCharSpaceMatcher.test(match);
    }
}
exports.BaseExpressionInput = BaseExpressionInput;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1leHByZXNzaW9uLWlucHV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY2xhc3Nlcy9leHByZXNzaW9uL2Jhc2UtZXhwcmVzc2lvbi1pbnB1dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSx1REFBNkQ7QUFFN0QsTUFBTSxvQkFBb0IsR0FBRyxLQUFLLENBQUM7QUFDbkMsSUFBWSxjQUdYO0FBSEQsV0FBWSxjQUFjO0lBQ3hCLDZCQUFXLENBQUE7SUFDWCwyQkFBUyxDQUFBO0FBQ1gsQ0FBQyxFQUhXLGNBQWMsR0FBZCxzQkFBYyxLQUFkLHNCQUFjLFFBR3pCO0FBRUQsTUFBc0IsbUJBQW1CO0lBS3ZDO1FBQ0UsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQUksS0FBSyxDQUFDLEtBQVU7UUFDbEIsSUFBSSxDQUFDLE1BQU0sbUNBQ04sSUFBSSxDQUFDLEtBQUssR0FDVixLQUFLLENBQ1QsQ0FBQztJQUNKLENBQUM7SUFFRCxJQUFJLEtBQUs7O1FBQ1AsT0FBTyxNQUFBLElBQUksQ0FBQyxNQUFNLG1DQUFJLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBRUQsSUFBSSxNQUFNLENBQUMsS0FBVTtRQUNuQixJQUFJLENBQUMsT0FBTyxtQ0FDUCxJQUFJLENBQUMsTUFBTSxHQUNYLEtBQUssQ0FDVCxDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksTUFBTTs7UUFDUixPQUFPLE1BQUEsSUFBSSxDQUFDLE9BQU8sbUNBQUksRUFBRSxDQUFDO0lBQzVCLENBQUM7SUFNUyxrQkFBa0IsQ0FBQyxPQUFlO1FBQzFDLElBQUksQ0FBQyxPQUFPLEVBQUU7WUFDWixPQUFPO1NBQ1I7UUFFRCxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUNoQyxJQUFJLENBQUMsVUFBVSxJQUFJLE9B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QUN6RCxJQUFJLENBQUMsa0JBQWtCLENBQ3JCLEdBQUcsV0FBVyxJQUFJLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxRQUFRLENBQUMsSUFBSSxZQUFZLEVBQUUsQ0FDeEUsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVTLG9CQUFvQixDQUFDLFFBQXdCO1FBQ3JELE1BQU0sU0FBUyxHQUFHO1lBQ2hCLEVBQUUsRUFBRSxHQUFHO1lBQ1AsRUFBRSxFQUFFLElBQUk7WUFDUixFQUFFLEVBQUUsR0FBRztZQUNQLEVBQUUsRUFBRSxJQUFJO1lBQ1IsRUFBRSxFQUFFLEdBQUc7WUFDUCxFQUFFLEVBQUUsSUFBSTtTQUNULENBQUM7UUFDRixPQUFPLFNBQVMsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUM3QixDQUFDO0lBRU8sa0JBQWtCLENBQUMsS0FBYTtRQUN0QyxPQUFPLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQyxDQUFDO0NBQ0Y7QUFqWUQsa0RBaVlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtBVFRSSUJVVEVfVFlQRSwgU2NhbGFyVHlwZSwgU2ltcGxlT3BlcmF0b3J9IGZyb20gJ0B0eXBlZG9ybS9jb21tb24nO1xuaW1wb3J0IHtuZXN0ZWRLZXlBY2Nlc3NSZWdleH0gZnJvbSAnLi4vLi4vaGVscGVycy9jb25zdGFudHMnO1xuXG5jb25zdCBsYXN0Q2hhclNwYWNlTWF0Y2hlciA9IC9cXHMkLztcbmV4cG9ydCBlbnVtIE1FUkdFX1NUUkFURUdZIHtcbiAgQU5EID0gJ0FORCcsXG4gIE9SID0gJ09SJyxcbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VFeHByZXNzaW9uSW5wdXQge1xuICBleHByZXNzaW9uOiBzdHJpbmc7XG4gIHByb3RlY3RlZCBfbmFtZXM/OiB7W2tleTogc3RyaW5nXTogYW55fTtcbiAgcHJvdGVjdGVkIF92YWx1ZXM/OiB7W2tleTogc3RyaW5nXTogYW55fTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSAnJztcbiAgfVxuXG4gIHNldCBuYW1lcyh2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5fbmFtZXMgPSB7XG4gICAgICAuLi50aGlzLm5hbWVzLFxuICAgICAgLi4udmFsdWUsXG4gICAgfTtcbiAgfVxuXG4gIGdldCBuYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMgPz8ge307XG4gIH1cblxuICBzZXQgdmFsdWVzKHZhbHVlOiBhbnkpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSB7XG4gICAgICAuLi50aGlzLnZhbHVlcyxcbiAgICAgIC4uLnZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMgPz8ge307XG4gIH1cblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0RXhwTmFtZUtleShrZXk6IHN0cmluZyk6IHN0cmluZztcblxuICBwcm90ZWN0ZWQgYWJzdHJhY3QgZ2V0RXhwVmFsdWVLZXkoa2V5OiBzdHJpbmcpOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGFwcGVuZFRvRXhwcmVzc2lvbihzZWdtZW50OiBzdHJpbmcpIHtcbiAgICBpZiAoIXNlZ21lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHByZXNzaW9uLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5leHByZXNzaW9uICs9IHNlZ21lbnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmhhc1NwYWNlSW5MYXN0Q2hhcih0aGlzLmV4cHJlc3Npb24pKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gKz0gJyAnOyAvLyBhcHBlbmQgZW1wdHkgc3BhY2UgaWYgZG9lcyBub3QgZXhpc3RcbiAgICB9XG5cbiAgICB0aGlzLmV4cHJlc3Npb24gKz0gc2VnbWVudDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRFeHByZXNzaW9uTmFtZShuYW1lOiBzdHJpbmcpIHtcbiAgICAvLyB3aGVuIHRyeWluZyB0byBhY2Nlc3MgbmVzdGVkIHByb3AgaS5lIHByb2ZpbGUubmFtZSwgcmVwbGFjZSAuIHdpdGggYXBwcm9wcmlhdGUgZXhwcmVzc2lvbiBzYWZlIHN0cmluZ1xuICAgIGNvbnN0IG5lc3RlZEtleXMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgdG9wS2V5ID0gbmVzdGVkS2V5cy5zaGlmdCgpO1xuXG4gICAgaWYgKCF0b3BLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwcmVzc2lvbiBhdHRyaWJ1dGUgbmFtZSBjYW4gbm90IGJlIGVtcHR5Jyk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9wTGV2ZWxQcm9wS2V5ID0gdGhpcy5pbm5lckFkZEV4cHJlc3Npb25OYW1lKHRvcEtleSk7XG4gICAgcmV0dXJuIG5lc3RlZEtleXMucmVkdWNlKFxuICAgICAgKGFjYywga2V5U2VnKSA9PiB7XG4gICAgICAgIGxldCB7cHJlZml4fSA9IGFjYztcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgcHJlZml4IGRvZXMgbm90IGNvbnRhaW4gYW55IG5lc3RlZCB2YWx1ZSByZWZlcmVuY2VcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnJlcGxhY2UobmVzdGVkS2V5QWNjZXNzUmVnZXgsICcnKTtcblxuICAgICAgICBjb25zdCBjdXJyZW50U2VnUHJvcEtleSA9IHRoaXMuaW5uZXJBZGRFeHByZXNzaW9uTmFtZShcbiAgICAgICAgICBgJHtwcmVmaXh9XyR7a2V5U2VnfWAsXG4gICAgICAgICAga2V5U2VnXG4gICAgICAgICk7XG5cbiAgICAgICAgYWNjLnByZWZpeCArPSBgXyR7a2V5U2VnfWA7XG4gICAgICAgIGFjYy5lbmNvZGVkICs9IGAuJHtjdXJyZW50U2VnUHJvcEtleX1gO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHtwcmVmaXg6IHRvcEtleSwgZW5jb2RlZDogdG9wTGV2ZWxQcm9wS2V5fVxuICAgICkuZW5jb2RlZDtcbiAgfVxuXG4gIHByaXZhdGUgaW5uZXJBZGRFeHByZXNzaW9uTmFtZShuYW1lS2V5OiBzdHJpbmcsIG5hbWVWYWx1ZT86IHN0cmluZykge1xuICAgIC8vIG1hdGNoIGFueSBuZXN0ZWQgbGlzdCBpdGVtIHJlZmVyZW5jZSwgYW5kIHVwZGF0ZSBpdCB0byBiZSB2YWxpZCBleHByZXNzaW9uXG4gICAgLy8gaS5lIGtleSBzdWNoIGFzIGFkZHJlc3Nlc1swXSB3aWxsIGJlIG5hbWUgI2FkZHJlc3NlcyB3aXRoIGV4cHJlc3Npb24gI2FkZHJlc3Nlc1swXVxuXG4gICAgbGV0IG1hdGNoID0gJyc7XG4gICAgbmFtZUtleSA9IG5hbWVLZXkucmVwbGFjZShuZXN0ZWRLZXlBY2Nlc3NSZWdleCwgc3Vic3RyID0+IHtcbiAgICAgIG1hdGNoID0gc3Vic3RyO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIG5hbWVWYWx1ZSA9IG5hbWVWYWx1ZT8ucmVwbGFjZShtYXRjaCwgJycpO1xuXG4gICAgY29uc3QgZXhwcmVzc2lvblByZWZpeGVkTmFtZSA9IHRoaXMuZ2V0RXhwTmFtZUtleShuYW1lS2V5KTtcbiAgICBpZiAodGhpcy5uYW1lc1tleHByZXNzaW9uUHJlZml4ZWROYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBleHByZXNzaW9uIG5hbWUgd2l0aCBrZXkgJHtleHByZXNzaW9uUHJlZml4ZWROYW1lfS5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLm5hbWVzID0ge1xuICAgICAgLi4udGhpcy5uYW1lcyxcbiAgICAgIFtleHByZXNzaW9uUHJlZml4ZWROYW1lXTogbmFtZVZhbHVlID8/IG5hbWVLZXksXG4gICAgfTtcbiAgICByZXR1cm4gZXhwcmVzc2lvblByZWZpeGVkTmFtZSArIG1hdGNoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEV4cHJlc3Npb25WYWx1ZShuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICBjb25zdCBleHByZXNzaW9uU2FmZU5hbWUgPSBuYW1lLnJlcGxhY2UoL1xcLi9nLCAnXycpO1xuICAgIHJldHVybiB0aGlzLmlubmVyQWRkRXhwcmVzc2lvblZhbHVlKGV4cHJlc3Npb25TYWZlTmFtZSwgdmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbm5lckFkZEV4cHJlc3Npb25WYWx1ZShuYW1lOiBzdHJpbmcsIHZhbHVlOiBhbnkpIHtcbiAgICAvLyByZW1vdmUgYW55IG5lc3RlZCBsaXN0IGl0ZW0gcmVmZXJlbmNlLCBpdCB3aWxsIGJlIGhhbmRsZWQgYnkgbmFtZXMgbWF0Y2hlclxuICAgIC8vIGkuZSBrZXkgc3VjaCBhcyBhZGRyZXNzZXNbMF1cbiAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG5lc3RlZEtleUFjY2Vzc1JlZ2V4LCAnJyk7XG5cbiAgICBjb25zdCBleHByZXNzaW9uUHJlZml4ZWRWYWx1ZSA9IHRoaXMuZ2V0RXhwVmFsdWVLZXkobmFtZSk7XG4gICAgaWYgKHRoaXMudmFsdWVzW2V4cHJlc3Npb25QcmVmaXhlZFZhbHVlXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVGhlcmUgaXMgYWxyZWFkeSBhbiBleHByZXNzaW9uIHZhbHVlIHdpdGgga2V5ICR7ZXhwcmVzc2lvblByZWZpeGVkVmFsdWV9LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMudmFsdWVzID0ge1xuICAgICAgLi4udGhpcy52YWx1ZXMsXG4gICAgICBbZXhwcmVzc2lvblByZWZpeGVkVmFsdWVdOiB2YWx1ZSxcbiAgICB9O1xuICAgIHJldHVybiBleHByZXNzaW9uUHJlZml4ZWRWYWx1ZTtcbiAgfVxuXG4gIG1lcmdlKFxuICAgIGNvbmRpdGlvbjogQmFzZUV4cHJlc3Npb25JbnB1dCxcbiAgICBzdHJhdGVneTogTUVSR0VfU1RSQVRFR1kgPSBNRVJHRV9TVFJBVEVHWS5BTkRcbiAgKTogdGhpcyB7XG4gICAgY29uc3Qge2V4cHJlc3Npb24sIG5hbWVzLCB2YWx1ZXN9ID0gY29uZGl0aW9uO1xuXG4gICAgLy8gaWYgbWVyZ2luZyBjb25kaXRpb24gZG9lcyBub3QgaGF2ZSBhbnl0aGluZyB0byBtZXJnZSByZXR1cm5cbiAgICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGlmIGJhc2UgY29uZGl0aW9uIGRvZXMgbm90IGhhdmUgYW55IGV4cHJlc3Npb24gcmVwbGFjZVxuICAgIGlmICghdGhpcy5leHByZXNzaW9uKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gKz0gZXhwcmVzc2lvbjtcbiAgICAgIHRoaXMubmFtZXMgPSBuYW1lcztcbiAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKHN0cmF0ZWd5ID09PSBNRVJHRV9TVFJBVEVHWS5PUikge1xuICAgICAgdGhpcy5vcigpLmFwcGVuZFRvRXhwcmVzc2lvbihgKCR7ZXhwcmVzc2lvbn0pYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYW5kKCkuYXBwZW5kVG9FeHByZXNzaW9uKGAoJHtleHByZXNzaW9ufSlgKTtcbiAgICB9XG5cbiAgICBPYmplY3Qua2V5cyhuYW1lcykuZm9yRWFjaChuYW1lS2V5ID0+IHtcbiAgICAgIGlmICh0aGlzLm5hbWVzW25hbWVLZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIG1lcmdlIGV4cHJlc3Npb24gYXR0cmlidXRlIG5hbWVzLCB0aGVyZSBhcmUgbXVsdGlwbGUgYXR0cmlidXRlcyBuYW1lcyB3aXRoIGtleSBcIiR7bmFtZUtleX1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2godmFsdWVLZXkgPT4ge1xuICAgICAgaWYgKHRoaXMubmFtZXNbdmFsdWVLZXldKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIG1lcmdlIGV4cHJlc3Npb24gYXR0cmlidXRlIHZhbHVlcywgdGhlcmUgYXJlIG11bHRpcGxlIGF0dHJpYnV0ZXMgdmFsdWVzIHdpdGgga2V5IFwiJHt2YWx1ZUtleX1cImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm5hbWVzID0gey4uLnRoaXMubmFtZXMsIC4uLm5hbWVzfTtcbiAgICB0aGlzLnZhbHVlcyA9IHsuLi50aGlzLnZhbHVlcywgLi4udmFsdWVzfTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbWVyZ2VNYW55PFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0PihcbiAgICBpbnB1dHM6IFRbXSxcbiAgICBzdHJhdGVneTogTUVSR0VfU1RSQVRFR1lcbiAgKSB7XG4gICAgLy8gY2hlY2sgaWYgYmFzZSBleHByZXNzaW9uIGhhcyBhbnkgdmFsdWVcbiAgICBpZiAodGhpcy5leHByZXNzaW9uKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBgKCR7dGhpcy5leHByZXNzaW9ufSlgO1xuICAgICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oc3RyYXRlZ3kpO1xuICAgIH1cblxuICAgIGlucHV0cy5mb3JFYWNoKChpbnB1dCwgaW5kZXgpID0+IHtcbiAgICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKGAoJHtpbnB1dC5leHByZXNzaW9ufSlgKTtcblxuICAgICAgaWYgKGluZGV4ICE9PSBpbnB1dHMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihzdHJhdGVneSk7XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKGlucHV0Lm5hbWVzKS5mb3JFYWNoKG5hbWVLZXkgPT4ge1xuICAgICAgICBpZiAodGhpcy5uYW1lc1tuYW1lS2V5XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gbWVyZ2UgZXhwcmVzc2lvbiBhdHRyaWJ1dGUgbmFtZXMsIHRoZXJlIGFyZSBtdWx0aXBsZSBhdHRyaWJ1dGVzIG5hbWVzIHdpdGgga2V5IFwiJHtuYW1lS2V5fVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmtleXMoaW5wdXQudmFsdWVzKS5mb3JFYWNoKHZhbHVlS2V5ID0+IHtcbiAgICAgICAgaWYgKHRoaXMubmFtZXNbdmFsdWVLZXldKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBtZXJnZSBleHByZXNzaW9uIGF0dHJpYnV0ZSB2YWx1ZXMsIHRoZXJlIGFyZSBtdWx0aXBsZSBhdHRyaWJ1dGVzIHZhbHVlcyB3aXRoIGtleSBcIiR7dmFsdWVLZXl9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMubmFtZXMgPSB7Li4udGhpcy5uYW1lcywgLi4uaW5wdXQubmFtZXN9O1xuICAgICAgdGhpcy52YWx1ZXMgPSB7Li4udGhpcy52YWx1ZXMsIC4uLmlucHV0LnZhbHVlc307XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBVc2UgbWVyZ2UgaW5zdGVhZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgYW5kKCk6IHRoaXMge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGAoJHt0aGlzLmV4cHJlc3Npb259KWA7XG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oJ0FORCcpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbm90PFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0Pihjb25kaXRpb24/OiBUKTogdGhpcyB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gYE5PVCAoJHtjb25kaXRpb24uZXhwcmVzc2lvbn0pYDtcbiAgICAgIHRoaXMubmFtZXMgPSBjb25kaXRpb24ubmFtZXM7XG4gICAgICB0aGlzLnZhbHVlcyA9IGNvbmRpdGlvbi52YWx1ZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB0aGlzLmV4cHJlc3Npb24gPSBgTk9UICgke3RoaXMuZXhwcmVzc2lvbn0pYDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2UgbWVyZ2UgaW5zdGVhZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgb3IoKTogdGhpcyB7XG4gICAgdGhpcy5leHByZXNzaW9uID0gYCgke3RoaXMuZXhwcmVzc2lvbn0pYDtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbignT1InKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGJlZ2luc1dpdGgoa2V5OiBzdHJpbmcsIHN1YnN0cmluZzogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShrZXkpO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZSA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKGtleSwgc3Vic3RyaW5nKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihgYmVnaW5zX3dpdGgoJHthdHRyRXhwTmFtZX0sICR7YXR0ckV4cFZhbHVlfSlgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGNvbnRhaW5zKGtleTogc3RyaW5nLCB2YWx1ZTogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShrZXkpO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZSA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKGtleSwgdmFsdWUpO1xuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKGBjb250YWlucygke2F0dHJFeHBOYW1lfSwgJHthdHRyRXhwVmFsdWV9KWApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXR0cmlidXRlVHlwZShrZXk6IHN0cmluZywgdHlwZTogQVRUUklCVVRFX1RZUEUpOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWUgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShrZXksIHR5cGUpO1xuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKGBhdHRyaWJ1dGVfdHlwZSgke2F0dHJFeHBOYW1lfSwgJHthdHRyRXhwVmFsdWV9KWApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYXR0cmlidXRlRXhpc3RzKGF0dHI6IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShhdHRyKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihgYXR0cmlidXRlX2V4aXN0cygke2F0dHJOYW1lfSlgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGF0dHJpYnV0ZU5vdEV4aXN0cyhhdHRyOiBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoYXR0cik7XG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oYGF0dHJpYnV0ZV9ub3RfZXhpc3RzKCR7YXR0ck5hbWV9KWApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZXF1YWxzKGtleTogc3RyaW5nLCB2YWx1ZTogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIHJldHVybiB0aGlzLmFkZEJhc2VPcGVyYXRvcignRVEnLCBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIGxlc3NUaGFuKGtleTogc3RyaW5nLCB2YWx1ZTogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIHJldHVybiB0aGlzLmFkZEJhc2VPcGVyYXRvcignTFQnLCBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIGxlc3NUaGFuQW5kRXF1YWxUbyhrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCYXNlT3BlcmF0b3IoJ0xFJywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBncmVhdGVyVGhhbihrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCYXNlT3BlcmF0b3IoJ0dUJywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBncmVhdGVyVGhhbkFuZEVxdWFsVG8oa2V5OiBzdHJpbmcsIHZhbHVlOiBTY2FsYXJUeXBlKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQmFzZU9wZXJhdG9yKCdHRScsIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgbm90RXF1YWxzKGtleTogc3RyaW5nLCB2YWx1ZTogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIHJldHVybiB0aGlzLmFkZEJhc2VPcGVyYXRvcignTkUnLCBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIGJldHdlZW4oa2V5OiBzdHJpbmcsIHZhbHVlOiBbU2NhbGFyVHlwZSwgU2NhbGFyVHlwZV0pOiB0aGlzIHtcbiAgICBpZiAodmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbmNvcnJlY3QgcXVlcnkgdmFsdWUgZm9yIEJFVFdFRU4gb3BlcmF0b3IsIGl0IHJlcXVpcmVzIGFycmF5IGNvbnRhaW5pbmcgdHdvIHZhbHVlcy4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBbc3RhcnRJbmNsdWRpbmcsIGVuZEluY2x1ZGluZ10gPSB2YWx1ZTtcbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWVTdGFydCA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKFxuICAgICAgYCR7a2V5fV9zdGFydGAsXG4gICAgICBzdGFydEluY2x1ZGluZ1xuICAgICk7XG4gICAgY29uc3QgYXR0ckV4cFZhbHVlRW5kID0gdGhpcy5hZGRFeHByZXNzaW9uVmFsdWUoYCR7a2V5fV9lbmRgLCBlbmRJbmNsdWRpbmcpO1xuXG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oXG4gICAgICBgJHthdHRyRXhwTmFtZX0gQkVUV0VFTiAke2F0dHJFeHBWYWx1ZVN0YXJ0fSBBTkQgJHthdHRyRXhwVmFsdWVFbmR9YFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpbihrZXk6IHN0cmluZywgdmFsdWVzOiBTY2FsYXJUeXBlW10pOiB0aGlzIHtcbiAgICBpZiAodmFsdWVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0luY29ycmVjdCB2YWx1ZSBmb3IgSU4gb3BlcmF0b3IsIGl0IHJlcXVpcmVzIGFycmF5IGNvbnRhaW5pbmcgYXQgbGVhc2Ugb25lIFNDQUxBUiB0eXBlIHZhbHVlLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgYXR0ckV4cE5hbWUgPSB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKGtleSk7XG4gICAgY29uc3QgYXR0ckV4cFZhbHVlID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB2YWx1ZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJFeHBWYWx1ZVN0YXJ0ID0gdGhpcy5hZGRFeHByZXNzaW9uVmFsdWUoXG4gICAgICAgIGAke2tleX1fJHtpbmRleH1gLFxuICAgICAgICB2YWx1ZVxuICAgICAgKTtcbiAgICAgIGFjYyArPSBhdHRyRXhwVmFsdWVTdGFydDtcbiAgICAgIGlmIChpbmRleCAhPT0gdmFsdWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gaWYgbm90IGxhc3QgaW5kZXggYXBwZW5kIHNlcGFyYXRvciBmb2xsb3dlZCBieSBzcGFjZVxuICAgICAgICBhY2MgKz0gJywgJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgJycpO1xuXG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oYCR7YXR0ckV4cE5hbWV9IElOICgke2F0dHJFeHBWYWx1ZX0pYCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzaXplKGtleTogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgYXR0ckV4cE5hbWUgPSB0aGlzLmdldEV4cE5hbWVLZXkoa2V5KTtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSB0aGlzLmV4cHJlc3Npb24ucmVwbGFjZShcbiAgICAgIGF0dHJFeHBOYW1lLFxuICAgICAgYHNpemUoJHthdHRyRXhwTmFtZX0pYFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkQmFzZU9wZXJhdG9yKFxuICAgIG9wZXJhdG9yOiBTaW1wbGVPcGVyYXRvcixcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogYW55XG4gICk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShrZXkpO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZSA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKGtleSwgdmFsdWUpO1xuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKFxuICAgICAgYCR7YXR0ckV4cE5hbWV9ICR7dGhpcy5nZXRTeW1ib2xGb3JPcGVyYXRvcihvcGVyYXRvcil9ICR7YXR0ckV4cFZhbHVlfWBcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFN5bWJvbEZvck9wZXJhdG9yKG9wZXJhdG9yOiBTaW1wbGVPcGVyYXRvcik6IHN0cmluZyB7XG4gICAgY29uc3Qgc3ltYm9sTWFwID0ge1xuICAgICAgRVE6ICc9JyxcbiAgICAgIExFOiAnPD0nLFxuICAgICAgTFQ6ICc8JyxcbiAgICAgIEdFOiAnPj0nLFxuICAgICAgR1Q6ICc+JyxcbiAgICAgIE5FOiAnPD4nLFxuICAgIH07XG4gICAgcmV0dXJuIHN5bWJvbE1hcFtvcGVyYXRvcl07XG4gIH1cblxuICBwcml2YXRlIGhhc1NwYWNlSW5MYXN0Q2hhcihtYXRjaDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGxhc3RDaGFyU3BhY2VNYXRjaGVyLnRlc3QobWF0Y2gpO1xuICB9XG59XG4iXX0=