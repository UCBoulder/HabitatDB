import { NestedAttributes, RequireOnlyOne, ConditionType, ATTRIBUTE_TYPE, ResolveScalarType } from '@typedorm/common';
type AttributeConditionOptions<Entity> = {
    [enKey in keyof Entity]?: RequireOnlyOne<{
        [key in ConditionType.SimpleOperator | Extract<ConditionType.FunctionOperator, 'CONTAINS' | 'BEGINS_WITH'>]: ResolveScalarType<Entity[enKey]>;
    } & {
        [key in Extract<ConditionType.RangeOperator, 'BETWEEN'>]: [
            ResolveScalarType<Entity[enKey]>,
            ResolveScalarType<Entity[enKey]>
        ];
    } & {
        [key in Extract<ConditionType.RangeOperator, 'IN'>]: ResolveScalarType<Entity[enKey]>[];
    } & {
        [key in Extract<ConditionType.FunctionOperator, 'ATTRIBUTE_TYPE'>]: ATTRIBUTE_TYPE;
    } & {
        [key in Extract<ConditionType.FunctionOperator, 'SIZE'>]: RequireOnlyOne<{
            [key in ConditionType.SimpleOperator]: number;
        }>;
    }>;
} | NestedAttributes<Entity, Extract<ConditionType.FunctionOperator, 'ATTRIBUTE_EXISTS' | 'ATTRIBUTE_NOT_EXISTS'>>;
type RecursiveConditionOptions<Entity> = {
    [key in Extract<ConditionType.LogicalOperator, 'OR' | 'AND'>]: Partial<AttributeConditionOptions<Entity> & RecursiveConditionOptions<Entity>> | {} extends infer R ? R : never;
} & {
    [key in Extract<ConditionType.LogicalOperator, 'NOT'>]: Partial<AttributeConditionOptions<Entity> & RecursiveConditionOptions<Entity>> | {} extends infer R ? R : never;
} & AttributeConditionOptions<Entity>;
export type ConditionOptions<Entity> = RequireOnlyOne<RecursiveConditionOptions<Entity>>;
export {};
