import { InvalidAttributeAliasSchemaError, NoSuchAttributeExistsError, } from '@typedorm/common';
import { regexInterpolatedWord } from './constants';
import { isKeyOfTypeAliasSchema } from './is-key-of-type-alias-schema';
/**
 *
 * @param key key to validate
 * @param dict dictionary to validate key against, dictionary of attribute { name: type }
 */
export function validateKey(key, dict, entityName) {
    // validate aliases
    if (isKeyOfTypeAliasSchema(key)) {
        if (typeof key.alias !== 'string') {
            throw new InvalidAttributeAliasSchemaError(key.alias);
        }
        const aliasType = dict[key.alias];
        if (!aliasType) {
            throw new NoSuchAttributeExistsError(key.alias, entityName);
        }
        // return when successfully validated
        return;
    }
    const matchIterator = key.matchAll(regexInterpolatedWord);
    validateMatch(key, matchIterator, dict);
    return;
}
function validateMatch(key, iterator, dict) {
    const next = iterator.next();
    if (next.done) {
        return;
    }
    const variable = next.value[1];
    const variableType = dict[variable];
    if (!variableType) {
        throw new Error(`key "${key}" references variable "${variable}" but it could not be resolved`);
    }
    if (variableType !== 'String' &&
        variableType !== 'Number' &&
        variableType !== 'Boolean') {
        throw new Error(`"${variable}" is used in key ${key}, thus it's type must be or scalar type, if attribute type is Enum, please set "isEnum" to true in attribute decorator.`);
    }
    validateMatch(key, iterator, dict);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUta2V5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvaGVscGVycy92YWxpZGF0ZS1rZXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLGdDQUFnQyxFQUNoQywwQkFBMEIsR0FDM0IsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDbEQsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFFckU7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3pCLEdBQTZCLEVBQzdCLElBQTZCLEVBQzdCLFVBQW1CO0lBRW5CLG1CQUFtQjtJQUNuQixJQUFJLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQy9CLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUNqQyxNQUFNLElBQUksZ0NBQWdDLENBQUMsR0FBRyxDQUFDLEtBQVksQ0FBQyxDQUFDO1NBQzlEO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2QsTUFBTSxJQUFJLDBCQUEwQixDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDN0Q7UUFDRCxxQ0FBcUM7UUFDckMsT0FBTztLQUNSO0lBQ0QsTUFBTSxhQUFhLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQzFELGFBQWEsQ0FBQyxHQUFHLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3hDLE9BQU87QUFDVCxDQUFDO0FBRUQsU0FBUyxhQUFhLENBQ3BCLEdBQVcsRUFDWCxRQUE0QyxFQUM1QyxJQUE2QjtJQUU3QixNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDN0IsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ2IsT0FBTztLQUNSO0lBRUQsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMvQixNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFcEMsSUFBSSxDQUFDLFlBQVksRUFBRTtRQUNqQixNQUFNLElBQUksS0FBSyxDQUNiLFFBQVEsR0FBRywwQkFBMEIsUUFBUSxnQ0FBZ0MsQ0FDOUUsQ0FBQztLQUNIO0lBRUQsSUFDRSxZQUFZLEtBQUssUUFBUTtRQUN6QixZQUFZLEtBQUssUUFBUTtRQUN6QixZQUFZLEtBQUssU0FBUyxFQUMxQjtRQUNBLE1BQU0sSUFBSSxLQUFLLENBQ2IsSUFBSSxRQUFRLG9CQUFvQixHQUFHLHlIQUF5SCxDQUM3SixDQUFDO0tBQ0g7SUFFRCxhQUFhLENBQUMsR0FBRyxFQUFFLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNyQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRW50aXR5QWxpYXNPclN0cmluZyxcbiAgSW52YWxpZEF0dHJpYnV0ZUFsaWFzU2NoZW1hRXJyb3IsXG4gIE5vU3VjaEF0dHJpYnV0ZUV4aXN0c0Vycm9yLFxufSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCB7cmVnZXhJbnRlcnBvbGF0ZWRXb3JkfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2lzS2V5T2ZUeXBlQWxpYXNTY2hlbWF9IGZyb20gJy4vaXMta2V5LW9mLXR5cGUtYWxpYXMtc2NoZW1hJztcblxuLyoqXG4gKlxuICogQHBhcmFtIGtleSBrZXkgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBkaWN0IGRpY3Rpb25hcnkgdG8gdmFsaWRhdGUga2V5IGFnYWluc3QsIGRpY3Rpb25hcnkgb2YgYXR0cmlidXRlIHsgbmFtZTogdHlwZSB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUtleShcbiAga2V5OiBFbnRpdHlBbGlhc09yU3RyaW5nPGFueT4sXG4gIGRpY3Q6IHtba2V5OiBzdHJpbmddOiBzdHJpbmd9LFxuICBlbnRpdHlOYW1lPzogc3RyaW5nXG4pIHtcbiAgLy8gdmFsaWRhdGUgYWxpYXNlc1xuICBpZiAoaXNLZXlPZlR5cGVBbGlhc1NjaGVtYShrZXkpKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkuYWxpYXMgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEF0dHJpYnV0ZUFsaWFzU2NoZW1hRXJyb3Ioa2V5LmFsaWFzIGFzIGFueSk7XG4gICAgfVxuXG4gICAgY29uc3QgYWxpYXNUeXBlID0gZGljdFtrZXkuYWxpYXNdO1xuXG4gICAgaWYgKCFhbGlhc1R5cGUpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hBdHRyaWJ1dGVFeGlzdHNFcnJvcihrZXkuYWxpYXMsIGVudGl0eU5hbWUpO1xuICAgIH1cbiAgICAvLyByZXR1cm4gd2hlbiBzdWNjZXNzZnVsbHkgdmFsaWRhdGVkXG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG1hdGNoSXRlcmF0b3IgPSBrZXkubWF0Y2hBbGwocmVnZXhJbnRlcnBvbGF0ZWRXb3JkKTtcbiAgdmFsaWRhdGVNYXRjaChrZXksIG1hdGNoSXRlcmF0b3IsIGRpY3QpO1xuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWF0Y2goXG4gIGtleTogc3RyaW5nLFxuICBpdGVyYXRvcjogSXRlcmFibGVJdGVyYXRvcjxSZWdFeHBNYXRjaEFycmF5PixcbiAgZGljdDoge1trZXk6IHN0cmluZ106IHN0cmluZ31cbikge1xuICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICBpZiAobmV4dC5kb25lKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdmFyaWFibGUgPSBuZXh0LnZhbHVlWzFdO1xuICBjb25zdCB2YXJpYWJsZVR5cGUgPSBkaWN0W3ZhcmlhYmxlXTtcblxuICBpZiAoIXZhcmlhYmxlVHlwZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBrZXkgXCIke2tleX1cIiByZWZlcmVuY2VzIHZhcmlhYmxlIFwiJHt2YXJpYWJsZX1cIiBidXQgaXQgY291bGQgbm90IGJlIHJlc29sdmVkYFxuICAgICk7XG4gIH1cblxuICBpZiAoXG4gICAgdmFyaWFibGVUeXBlICE9PSAnU3RyaW5nJyAmJlxuICAgIHZhcmlhYmxlVHlwZSAhPT0gJ051bWJlcicgJiZcbiAgICB2YXJpYWJsZVR5cGUgIT09ICdCb29sZWFuJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgXCIke3ZhcmlhYmxlfVwiIGlzIHVzZWQgaW4ga2V5ICR7a2V5fSwgdGh1cyBpdCdzIHR5cGUgbXVzdCBiZSBvciBzY2FsYXIgdHlwZSwgaWYgYXR0cmlidXRlIHR5cGUgaXMgRW51bSwgcGxlYXNlIHNldCBcImlzRW51bVwiIHRvIHRydWUgaW4gYXR0cmlidXRlIGRlY29yYXRvci5gXG4gICAgKTtcbiAgfVxuXG4gIHZhbGlkYXRlTWF0Y2goa2V5LCBpdGVyYXRvciwgZGljdCk7XG59XG4iXX0=