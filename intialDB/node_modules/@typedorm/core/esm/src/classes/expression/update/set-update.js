import { Update } from './update';
export class SetUpdate extends Update {
    prefix = 'SET';
    /**
     * Support specifying additional arithmetic operations
     */
    setTo(key, value, incrementBy) {
        const arithmeticOperator = incrementBy
            ? this.getSymbolForArithmeticOperator(incrementBy)
            : '';
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        this.appendToExpression(`${attrExpName} ` +
            `${this.getSymbolForOperator('EQ')} ` +
            // builds exp like #UE_age = #UE_age + :UE_age if incrementBy was provided
            `${arithmeticOperator ? `${attrExpName} ${arithmeticOperator} ` : ''}` +
            `${attrExpValue}`);
        return this;
    }
    setToIfNotExists(key, value, otherKeyAttribute) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        // if no other key is specified, use default value of updating key
        const keyofValueToCheck = otherKeyAttribute
            ? this.addExpressionName(otherKeyAttribute)
            : attrExpName;
        this.appendToExpression(`${attrExpName} ` +
            `${this.getSymbolForOperator('EQ')} ` +
            `if_not_exists(${keyofValueToCheck}, ${attrExpValue})`);
        return this;
    }
    setOrAppendToList(key, value, otherKeyAttribute) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        // if no other key is specified, use default value of updating key
        const keyofValueToAppend = otherKeyAttribute
            ? this.addExpressionName(otherKeyAttribute)
            : attrExpName;
        this.appendToExpression(`${attrExpName} ` +
            `${this.getSymbolForOperator('EQ')} ` +
            `list_append(${keyofValueToAppend}, ${attrExpValue})`);
        return this;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2V0LXVwZGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2NsYXNzZXMvZXhwcmVzc2lvbi91cGRhdGUvc2V0LXVwZGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBRWhDLE1BQU0sT0FBTyxTQUFVLFNBQVEsTUFBTTtJQUN6QixNQUFNLEdBQXNCLEtBQUssQ0FBQztJQUU1Qzs7T0FFRztJQUNILEtBQUssQ0FDSCxHQUFXLEVBQ1gsS0FBVSxFQUNWLFdBQTJDO1FBRTNDLE1BQU0sa0JBQWtCLEdBQUcsV0FBVztZQUNwQyxDQUFDLENBQUMsSUFBSSxDQUFDLDhCQUE4QixDQUFDLFdBQVcsQ0FBQztZQUNsRCxDQUFDLENBQUMsRUFBRSxDQUFDO1FBRVAsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFDekQsSUFBSSxDQUFDLGtCQUFrQixDQUNyQixHQUFHLFdBQVcsR0FBRztZQUNmLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHO1lBQ3JDLDBFQUEwRTtZQUMxRSxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxHQUFHLFdBQVcsSUFBSSxrQkFBa0IsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUU7WUFDdEUsR0FBRyxZQUFZLEVBQUUsQ0FDcEIsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGdCQUFnQixDQUFDLEdBQVcsRUFBRSxLQUFVLEVBQUUsaUJBQTBCO1FBQ2xFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBRXpELGtFQUFrRTtRQUNsRSxNQUFNLGlCQUFpQixHQUFHLGlCQUFpQjtZQUN6QyxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGlCQUFpQixDQUFDO1lBQzNDLENBQUMsQ0FBQyxXQUFXLENBQUM7UUFFaEIsSUFBSSxDQUFDLGtCQUFrQixDQUNyQixHQUFHLFdBQVcsR0FBRztZQUNmLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxHQUFHO1lBQ3JDLGlCQUFpQixpQkFBaUIsS0FBSyxZQUFZLEdBQUcsQ0FDekQsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUVELGlCQUFpQixDQUNmLEdBQVcsRUFDWCxLQUFtQixFQUNuQixpQkFBMEI7UUFFMUIsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFekQsa0VBQWtFO1FBQ2xFLE1BQU0sa0JBQWtCLEdBQUcsaUJBQWlCO1lBQzFDLENBQUMsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsaUJBQWlCLENBQUM7WUFDM0MsQ0FBQyxDQUFDLFdBQVcsQ0FBQztRQUVoQixJQUFJLENBQUMsa0JBQWtCLENBQ3JCLEdBQUcsV0FBVyxHQUFHO1lBQ2YsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsSUFBSSxDQUFDLEdBQUc7WUFDckMsZUFBZSxrQkFBa0IsS0FBSyxZQUFZLEdBQUcsQ0FDeEQsQ0FBQztRQUNGLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtVcGRhdGVUeXBlLCBTY2FsYXJUeXBlfSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCB7VXBkYXRlfSBmcm9tICcuL3VwZGF0ZSc7XG5cbmV4cG9ydCBjbGFzcyBTZXRVcGRhdGUgZXh0ZW5kcyBVcGRhdGUge1xuICBwcm90ZWN0ZWQgcHJlZml4OiBVcGRhdGVUeXBlLkFjdGlvbiA9ICdTRVQnO1xuXG4gIC8qKlxuICAgKiBTdXBwb3J0IHNwZWNpZnlpbmcgYWRkaXRpb25hbCBhcml0aG1ldGljIG9wZXJhdGlvbnNcbiAgICovXG4gIHNldFRvKFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBhbnksXG4gICAgaW5jcmVtZW50Qnk/OiBVcGRhdGVUeXBlLkFyaXRobWV0aWNPcGVyYXRvclxuICApOiB0aGlzIHtcbiAgICBjb25zdCBhcml0aG1ldGljT3BlcmF0b3IgPSBpbmNyZW1lbnRCeVxuICAgICAgPyB0aGlzLmdldFN5bWJvbEZvckFyaXRobWV0aWNPcGVyYXRvcihpbmNyZW1lbnRCeSlcbiAgICAgIDogJyc7XG5cbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWUgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihcbiAgICAgIGAke2F0dHJFeHBOYW1lfSBgICtcbiAgICAgICAgYCR7dGhpcy5nZXRTeW1ib2xGb3JPcGVyYXRvcignRVEnKX0gYCArXG4gICAgICAgIC8vIGJ1aWxkcyBleHAgbGlrZSAjVUVfYWdlID0gI1VFX2FnZSArIDpVRV9hZ2UgaWYgaW5jcmVtZW50Qnkgd2FzIHByb3ZpZGVkXG4gICAgICAgIGAke2FyaXRobWV0aWNPcGVyYXRvciA/IGAke2F0dHJFeHBOYW1lfSAke2FyaXRobWV0aWNPcGVyYXRvcn0gYCA6ICcnfWAgK1xuICAgICAgICBgJHthdHRyRXhwVmFsdWV9YFxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzZXRUb0lmTm90RXhpc3RzKGtleTogc3RyaW5nLCB2YWx1ZTogYW55LCBvdGhlcktleUF0dHJpYnV0ZT86IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShrZXkpO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZSA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKGtleSwgdmFsdWUpO1xuXG4gICAgLy8gaWYgbm8gb3RoZXIga2V5IGlzIHNwZWNpZmllZCwgdXNlIGRlZmF1bHQgdmFsdWUgb2YgdXBkYXRpbmcga2V5XG4gICAgY29uc3Qga2V5b2ZWYWx1ZVRvQ2hlY2sgPSBvdGhlcktleUF0dHJpYnV0ZVxuICAgICAgPyB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKG90aGVyS2V5QXR0cmlidXRlKVxuICAgICAgOiBhdHRyRXhwTmFtZTtcblxuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKFxuICAgICAgYCR7YXR0ckV4cE5hbWV9IGAgK1xuICAgICAgICBgJHt0aGlzLmdldFN5bWJvbEZvck9wZXJhdG9yKCdFUScpfSBgICtcbiAgICAgICAgYGlmX25vdF9leGlzdHMoJHtrZXlvZlZhbHVlVG9DaGVja30sICR7YXR0ckV4cFZhbHVlfSlgXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNldE9yQXBwZW5kVG9MaXN0KFxuICAgIGtleTogc3RyaW5nLFxuICAgIHZhbHVlOiBTY2FsYXJUeXBlW10sXG4gICAgb3RoZXJLZXlBdHRyaWJ1dGU/OiBzdHJpbmdcbiAgKTogdGhpcyB7XG4gICAgY29uc3QgYXR0ckV4cE5hbWUgPSB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKGtleSk7XG4gICAgY29uc3QgYXR0ckV4cFZhbHVlID0gdGhpcy5hZGRFeHByZXNzaW9uVmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgICAvLyBpZiBubyBvdGhlciBrZXkgaXMgc3BlY2lmaWVkLCB1c2UgZGVmYXVsdCB2YWx1ZSBvZiB1cGRhdGluZyBrZXlcbiAgICBjb25zdCBrZXlvZlZhbHVlVG9BcHBlbmQgPSBvdGhlcktleUF0dHJpYnV0ZVxuICAgICAgPyB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKG90aGVyS2V5QXR0cmlidXRlKVxuICAgICAgOiBhdHRyRXhwTmFtZTtcblxuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKFxuICAgICAgYCR7YXR0ckV4cE5hbWV9IGAgK1xuICAgICAgICBgJHt0aGlzLmdldFN5bWJvbEZvck9wZXJhdG9yKCdFUScpfSBgICtcbiAgICAgICAgYGxpc3RfYXBwZW5kKCR7a2V5b2ZWYWx1ZVRvQXBwZW5kfSwgJHthdHRyRXhwVmFsdWV9KWBcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iXX0=