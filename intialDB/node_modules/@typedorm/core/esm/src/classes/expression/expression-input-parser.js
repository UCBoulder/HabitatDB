import { isEmptyObject } from '../../helpers/is-empty-object';
import { KeyCondition } from './key-condition';
import { Filter } from './filter';
import { MERGE_STRATEGY } from './base-expression-input';
import { isScalarType } from '../../helpers/is-scalar-type';
import { Condition } from './condition';
import { Projection } from './projection';
import { isSetOperatorComplexValueType } from './update-body-type';
import { SetUpdate } from './update/set-update';
import { AddUpdate } from './update/add-update';
import { Update } from './update/update';
import { DeleteUpdate } from './update/delete-update';
import { RemoveUpdate } from './update/remove-update';
import { isObject } from '../../helpers/is-object';
import { nestedKeyAccessRegex } from '../../helpers/constants';
/**
 * Parses expression input to expression instances
 */
export class ExpressionInputParser {
    parseToKeyCondition(key, options) {
        return this.operatorToBaseExpression(key, options, new KeyCondition());
    }
    parseToFilter(options) {
        return this.recursiveParseToBaseExpression(options, Filter).pop();
    }
    parseToCondition(options) {
        return this.recursiveParseToBaseExpression(options, Condition).pop();
    }
    parseToProjection(keys) {
        const projection = new Projection();
        projection.addProjectionAttributes(keys);
        return projection;
    }
    parseToUpdate(body, attrValueOverrideMap = {}) {
        return this.parseToUpdateExpression(body, attrValueOverrideMap);
    }
    /**
     * Parses complex update object to a value and type
     */
    parseAttributeToUpdateValue(attr, value) {
        if (isObject(value) && !isEmptyObject(value)) {
            const [operator, operatorValue] = Object.entries(value)[0];
            const parsedUpdate = this.parseValueToUpdateExp(attr, value, operator, operatorValue);
            const parsedValue = Object.values(parsedUpdate.values ?? {})[0];
            // if expression contains any dynamic operation such as value manipulation or nested attribute manipulation in a list
            if (!(parsedUpdate instanceof SetUpdate) ||
                parsedUpdate.expression.includes(' + ') ||
                parsedUpdate.expression.includes(' - ') ||
                nestedKeyAccessRegex.test(parsedUpdate.expression)) {
                return {
                    value: parsedValue,
                    type: 'dynamic',
                };
            }
            // return static value
            return {
                type: 'static',
                value: parsedValue,
            };
        }
        else {
            // if tried to update nested value for key, it is considered dynamic, as we do not know full value of updating attribute
            if (nestedKeyAccessRegex.test(attr)) {
                return {
                    type: 'dynamic',
                    value,
                };
            }
            // return value as a default value
            return { type: 'static', value };
        }
    }
    /**
     * Generic Recursive input parser
     * Recursively parses nested object to build expression of type ExpClass
     * @param options Complex options object to parse
     * @param ExpClass Type of expression to build, can be of type Filter, Condition etc.
     *
     */
    recursiveParseToBaseExpression(options, ExpClass) {
        return Object.entries(options).map(([operatorOrAttr, value]) => {
            // if top level key is one of the logical operators, rerun parse with it's values
            if (['AND', 'OR', 'NOT'].includes(operatorOrAttr)) {
                const parsedExpList = this.recursiveParseToBaseExpression(value, ExpClass);
                const base = parsedExpList.shift();
                if (!base) {
                    return new ExpClass();
                }
                switch (operatorOrAttr) {
                    case 'AND': {
                        if (!parsedExpList?.length) {
                            return base;
                        }
                        return base.mergeMany(parsedExpList, MERGE_STRATEGY.AND);
                    }
                    case 'OR': {
                        if (!parsedExpList?.length) {
                            return base;
                        }
                        return base.mergeMany(parsedExpList, MERGE_STRATEGY.OR);
                    }
                    case 'NOT': {
                        // not can not contain more than one items
                        if (parsedExpList?.length) {
                            throw new Error(`Value for operator "${operatorOrAttr}" can not contain more than 1 attributes.`);
                        }
                        return base.not();
                    }
                    default: {
                        throw new Error(`Unsupported logical operator "${operatorOrAttr}"`);
                    }
                }
            }
            else {
                // when top level attribute is something other than actual logical operators, try to parse it to expression
                return this.operatorToBaseExpression(operatorOrAttr, value, new ExpClass());
            }
        });
    }
    /**
     * Parses input to update expression
     * @param body body to parse
     */
    parseToUpdateExpression(body, attrValueOverrideMap) {
        return (Object.entries(body)
            .map(([attr, value]) => {
            if (isObject(value) && !isEmptyObject(value)) {
                const [operator, operatorValue] = Object.entries(value)[0];
                return this.parseValueToUpdateExp(attr, value, operator, operatorValue, attrValueOverrideMap[attr] // get any override value if exists
                );
            }
            else {
                // fallback to default `SET` action based update
                return new SetUpdate().setTo(attr, attrValueOverrideMap[attr] || value);
            }
        })
            // merge all expressions with matching action
            .reduce((acc, currExp) => {
            acc
                .find(instance => instance.constructor === currExp.constructor)
                .merge(currExp);
            return acc;
        }, [
            new SetUpdate(),
            new AddUpdate(),
            new RemoveUpdate(),
            new DeleteUpdate(),
        ])
            // merge all expressions of different actions
            .reduce((acc, curr) => {
            acc.merge(curr);
            return acc;
        }, new Update()));
    }
    /**
     * Parses single attribute into update expression instance
     * @param attribute name/path of the attribute
     * @param attributeValue value to update
     */
    parseValueToUpdateExp(attribute, attributeValue, // attribute value to set
    operator, operatorValue, staticValueToOverride // value to override for attribute, this is set in cases where there was a custom property transform was requested
    ) {
        switch (operator) {
            case 'INCREMENT_BY':
            case 'DECREMENT_BY': {
                return new SetUpdate().setTo(attribute, operatorValue, operator);
            }
            case 'IF_NOT_EXISTS': {
                if (isSetOperatorComplexValueType(operatorValue)) {
                    return new SetUpdate().setToIfNotExists(attribute, staticValueToOverride || operatorValue.$VALUE, operatorValue.$PATH);
                }
                else {
                    return new SetUpdate().setToIfNotExists(attribute, operatorValue);
                }
            }
            case 'LIST_APPEND': {
                if (isSetOperatorComplexValueType(operatorValue)) {
                    return new SetUpdate().setOrAppendToList(attribute, operatorValue.$VALUE, operatorValue.$PATH);
                }
                else {
                    return new SetUpdate().setOrAppendToList(attribute, operatorValue);
                }
            }
            case 'SET': {
                /**
                 * aliased set support, this allows access patterns like
                 * {id: { SET: '1'}}
                 * behaves similar to {id: '1'}
                 */
                // handle explicit set exp
                if (isObject(operatorValue) && !isEmptyObject(operatorValue)) {
                    const [nestedOperator, nestedOperatorValue] = Object.entries(operatorValue)[0];
                    return this.parseValueToUpdateExp(attribute, nestedOperatorValue, nestedOperator, nestedOperatorValue, staticValueToOverride);
                }
                else {
                    // handle attribute with map type
                    return new SetUpdate().setTo(attribute, staticValueToOverride || operatorValue);
                }
            }
            case 'ADD': {
                if (isEmptyObject(operatorValue)) {
                    throw new Error(`Invalid value ${operatorValue} received for action "ADD", Only numbers and lists are supported.`);
                }
                return new AddUpdate().addTo(attribute, operatorValue);
            }
            case 'DELETE': {
                return new DeleteUpdate().delete(attribute, operatorValue);
            }
            case 'REMOVE': {
                if (typeof operatorValue === 'boolean' && !!operatorValue) {
                    return new RemoveUpdate().remove(attribute);
                }
                else if (!isEmptyObject(operatorValue) &&
                    Array.isArray(operatorValue.$AT_INDEX)) {
                    return new RemoveUpdate().remove(attribute, {
                        atIndexes: operatorValue.$AT_INDEX,
                    });
                }
                else {
                    throw new Error(`Invalid value ${operatorValue} received for action "REMOVE". Value must be set to boolean
            In addition, You may use special value type {$AT_INDEX: Array<number>} for attribute of type list..`);
                }
            }
            default: {
                // handle attribute with map type
                return new SetUpdate().setTo(attribute, staticValueToOverride || attributeValue);
            }
        }
    }
    /**
     * When this is run, it is assumed that attribute/value are validated to not have any nested objects,
     * therefor this function will not running in any recursion itself
     * @param attribute Attribute or path on entity to build comparison condition for
     * @param value value to expect
     * @param exp expression to append operators to
     */
    operatorToBaseExpression(attribute, value, exp) {
        switch (typeof value) {
            case 'string': {
                if (value === 'ATTRIBUTE_EXISTS') {
                    exp.attributeExists(attribute);
                    return exp;
                }
                else if (value === 'ATTRIBUTE_NOT_EXISTS') {
                    exp.attributeNotExists(attribute);
                    return exp;
                }
                else {
                    throw new Error(`Operator used must be one of "ATTRIBUTE_EXISTS", "ATTRIBUTE_NOT_EXISTS" for 
            attribute "${attribute}".`);
                }
            }
            case 'object': {
                if (isEmptyObject(value)) {
                    throw new Error(`Value for attribute "${attribute}" can not be empty`);
                }
                const operatorAndValue = Object.entries(value);
                if (operatorAndValue.length !== 1) {
                    throw new Error(`Invalid value "${JSON.stringify(value)}" found for attribute: ${attribute}`);
                }
                const [innerOp, innerVal] = operatorAndValue[0];
                if (isScalarType(innerVal)) {
                    return this.parseScalarValueToExp(innerOp, attribute, innerVal, exp);
                }
                else {
                    return this.parseNonScalarValueToExp(innerOp, attribute, innerVal, exp);
                }
            }
            default: {
                throw new Error(`Value for attribute "${attribute}" must be of type object or string`);
            }
        }
    }
    /**
     * Builds comparison expression for operators with scalar values
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    parseScalarValueToExp(operator, attrPath, value, exp) {
        switch (operator) {
            case 'EQ': {
                exp.equals(attrPath, value);
                return exp;
            }
            case 'LT': {
                exp.lessThan(attrPath, value);
                return exp;
            }
            case 'LE': {
                exp.lessThanAndEqualTo(attrPath, value);
                return exp;
            }
            case 'GT': {
                exp.greaterThan(attrPath, value);
                return exp;
            }
            case 'GE': {
                exp.greaterThanAndEqualTo(attrPath, value);
                return exp;
            }
            case 'NE': {
                exp.notEquals(attrPath, value);
                return exp;
            }
            case 'BEGINS_WITH': {
                exp.beginsWith(attrPath, value);
                return exp;
            }
            case 'CONTAINS': {
                exp.contains(attrPath, value);
                return exp;
            }
            case 'ATTRIBUTE_TYPE': {
                exp.attributeType(attrPath, value);
                return exp;
            }
            default: {
                throw new Error(`Unsupported operator: ${operator}`);
            }
        }
    }
    /**
     * Builds comparison expression for operators with Non scalar values, i.e ranges and size
     * @param operator operator that supports scalar values
     * @param attrPath attribute path to include in built expression
     * @param value value to expect in expression
     * @param exp expression type
     */
    parseNonScalarValueToExp(operator, attrPath, value, exp) {
        switch (operator) {
            case 'BETWEEN': {
                if (!Array.isArray(value) || value.length !== 2) {
                    throw new Error(`Value for operator ${operator} must be of type array with exact two items.`);
                }
                exp.between(attrPath, value);
                return exp;
            }
            case 'IN': {
                if (!Array.isArray(value) || value.length < 1) {
                    throw new Error(`Value for operator ${operator} must be of type array with at least one item.`);
                }
                exp.in(attrPath, value);
                return exp;
            }
            case 'SIZE': {
                const operatorAndValue = Object.entries(value);
                if (operatorAndValue.length !== 1) {
                    throw new Error(`Invalid value "${JSON.stringify(value)}" found for operator: ${operator}`);
                }
                const [innerOp, innerVal] = operatorAndValue[0];
                const parsedExp = this.parseScalarValueToExp(innerOp, attrPath, innerVal, exp);
                // once operator condition has applied, pass it through size
                parsedExp.size(attrPath);
                return parsedExp;
            }
            default: {
                throw new Error(`Unsupported operator: ${operator}`);
            }
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1pbnB1dC1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9jbGFzc2VzL2V4cHJlc3Npb24vZXhwcmVzc2lvbi1pbnB1dC1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBT0EsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQzVELE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ2hDLE9BQU8sRUFBc0IsY0FBYyxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDNUUsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLDhCQUE4QixDQUFDO0FBRzFELE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDdEMsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQUd4QyxPQUFPLEVBQUMsNkJBQTZCLEVBQWEsTUFBTSxvQkFBb0IsQ0FBQztBQUM3RSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDOUMsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQzlDLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUV2QyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDcEQsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQ3BELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUU3RDs7R0FFRztBQUNILE1BQU0sT0FBTyxxQkFBcUI7SUFDaEMsbUJBQW1CLENBQUMsR0FBVyxFQUFFLE9B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QUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN6QixPQUFPLFNBQVMsQ0FBQzthQUNsQjtZQUNELE9BQU8sQ0FBQyxDQUFDO2dCQUNQLE1BQU0sSUFBSSxLQUFLLENBQUMseUJBQXlCLFFBQVEsRUFBRSxDQUFDLENBQUM7YUFDdEQ7U0FDRjtJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFUVFJJQlVURV9UWVBFLFxuICBSYW5nZU9wZXJhdG9yLFxuICBTY2FsYXJUeXBlLFxuICBTaW1wbGVPcGVyYXRvcixcbiAgVXBkYXRlVHlwZSxcbn0gZnJvbSAnQHR5cGVkb3JtL2NvbW1vbic7XG5pbXBvcnQge2lzRW1wdHlPYmplY3R9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtZW1wdHktb2JqZWN0JztcbmltcG9ydCB7S2V5Q29uZGl0aW9ufSBmcm9tICcuL2tleS1jb25kaXRpb24nO1xuaW1wb3J0IHtGaWx0ZXJ9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7QmFzZUV4cHJlc3Npb25JbnB1dCwgTUVSR0VfU1RSQVRFR1l9IGZyb20gJy4vYmFzZS1leHByZXNzaW9uLWlucHV0JztcbmltcG9ydCB7aXNTY2FsYXJUeXBlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLXNjYWxhci10eXBlJztcbmltcG9ydCB7RmlsdGVyT3B0aW9uc30gZnJvbSAnLi9maWx0ZXItb3B0aW9ucy10eXBlJztcbmltcG9ydCB7Q29uZGl0aW9uT3B0aW9uc30gZnJvbSAnLi9jb25kaXRpb24tb3B0aW9ucy10eXBlJztcbmltcG9ydCB7Q29uZGl0aW9ufSBmcm9tICcuL2NvbmRpdGlvbic7XG5pbXBvcnQge1Byb2plY3Rpb259IGZyb20gJy4vcHJvamVjdGlvbic7XG5pbXBvcnQge0tleUNvbmRpdGlvbk9wdGlvbnN9IGZyb20gJy4va2V5LWNvbmRpdGlvbi1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtQcm9qZWN0aW9uS2V5c30gZnJvbSAnLi9wcm9qZWN0aW9uLWtleXMtb3B0aW9ucy10eXBlJztcbmltcG9ydCB7aXNTZXRPcGVyYXRvckNvbXBsZXhWYWx1ZVR5cGUsIFVwZGF0ZUJvZHl9IGZyb20gJy4vdXBkYXRlLWJvZHktdHlwZSc7XG5pbXBvcnQge1NldFVwZGF0ZX0gZnJvbSAnLi91cGRhdGUvc2V0LXVwZGF0ZSc7XG5pbXBvcnQge0FkZFVwZGF0ZX0gZnJvbSAnLi91cGRhdGUvYWRkLXVwZGF0ZSc7XG5pbXBvcnQge1VwZGF0ZX0gZnJvbSAnLi91cGRhdGUvdXBkYXRlJztcblxuaW1wb3J0IHtEZWxldGVVcGRhdGV9IGZyb20gJy4vdXBkYXRlL2RlbGV0ZS11cGRhdGUnO1xuaW1wb3J0IHtSZW1vdmVVcGRhdGV9IGZyb20gJy4vdXBkYXRlL3JlbW92ZS11cGRhdGUnO1xuaW1wb3J0IHtpc09iamVjdH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1vYmplY3QnO1xuaW1wb3J0IHtuZXN0ZWRLZXlBY2Nlc3NSZWdleH0gZnJvbSAnLi4vLi4vaGVscGVycy9jb25zdGFudHMnO1xuXG4vKipcbiAqIFBhcnNlcyBleHByZXNzaW9uIGlucHV0IHRvIGV4cHJlc3Npb24gaW5zdGFuY2VzXG4gKi9cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uSW5wdXRQYXJzZXIge1xuICBwYXJzZVRvS2V5Q29uZGl0aW9uKGtleTogc3RyaW5nLCBvcHRpb25zOiBLZXlDb25kaXRpb25PcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMub3BlcmF0b3JUb0Jhc2VFeHByZXNzaW9uKGtleSwgb3B0aW9ucywgbmV3IEtleUNvbmRpdGlvbigpKTtcbiAgfVxuXG4gIHBhcnNlVG9GaWx0ZXI8RW50aXR5LCBQcmltYXJ5S2V5PihcbiAgICBvcHRpb25zOiBGaWx0ZXJPcHRpb25zPEVudGl0eSwgUHJpbWFyeUtleT5cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlUGFyc2VUb0Jhc2VFeHByZXNzaW9uKG9wdGlvbnMsIEZpbHRlcikucG9wKCk7XG4gIH1cblxuICBwYXJzZVRvQ29uZGl0aW9uPEVudGl0eT4ob3B0aW9uczogQ29uZGl0aW9uT3B0aW9uczxFbnRpdHk+KSB7XG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlUGFyc2VUb0Jhc2VFeHByZXNzaW9uKG9wdGlvbnMsIENvbmRpdGlvbikucG9wKCk7XG4gIH1cblxuICBwYXJzZVRvUHJvamVjdGlvbjxFbnRpdHk+KGtleXM6IFByb2plY3Rpb25LZXlzPEVudGl0eT4pIHtcbiAgICBjb25zdCBwcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb24oKTtcbiAgICBwcm9qZWN0aW9uLmFkZFByb2plY3Rpb25BdHRyaWJ1dGVzKGtleXMgYXMgc3RyaW5nW10pO1xuXG4gICAgcmV0dXJuIHByb2plY3Rpb247XG4gIH1cblxuICBwYXJzZVRvVXBkYXRlPEVudGl0eSwgQWRkaXRpb25hbFByb3BlcnRpZXMgPSB7fT4oXG4gICAgYm9keTogVXBkYXRlQm9keTxFbnRpdHksIEFkZGl0aW9uYWxQcm9wZXJ0aWVzPixcbiAgICBhdHRyVmFsdWVPdmVycmlkZU1hcDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9XG4gICkge1xuICAgIHJldHVybiB0aGlzLnBhcnNlVG9VcGRhdGVFeHByZXNzaW9uKGJvZHksIGF0dHJWYWx1ZU92ZXJyaWRlTWFwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZXMgY29tcGxleCB1cGRhdGUgb2JqZWN0IHRvIGEgdmFsdWUgYW5kIHR5cGVcbiAgICovXG4gIHBhcnNlQXR0cmlidXRlVG9VcGRhdGVWYWx1ZShcbiAgICBhdHRyOiBzdHJpbmcsXG4gICAgdmFsdWU6IGFueVxuICApOiB7dmFsdWU6IGFueTsgdHlwZTogJ3N0YXRpYycgfCAnZHluYW1pYyd9IHtcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpICYmICFpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgY29uc3QgW29wZXJhdG9yLCBvcGVyYXRvclZhbHVlXSA9IE9iamVjdC5lbnRyaWVzKHZhbHVlIGFzIGFueSlbMF07XG5cbiAgICAgIGNvbnN0IHBhcnNlZFVwZGF0ZSA9IHRoaXMucGFyc2VWYWx1ZVRvVXBkYXRlRXhwKFxuICAgICAgICBhdHRyLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3BlcmF0b3IgYXMgYW55LFxuICAgICAgICBvcGVyYXRvclZhbHVlXG4gICAgICApO1xuXG4gICAgICBjb25zdCBwYXJzZWRWYWx1ZSA9IE9iamVjdC52YWx1ZXMocGFyc2VkVXBkYXRlLnZhbHVlcyA/PyB7fSlbMF07XG5cbiAgICAgIC8vIGlmIGV4cHJlc3Npb24gY29udGFpbnMgYW55IGR5bmFtaWMgb3BlcmF0aW9uIHN1Y2ggYXMgdmFsdWUgbWFuaXB1bGF0aW9uIG9yIG5lc3RlZCBhdHRyaWJ1dGUgbWFuaXB1bGF0aW9uIGluIGEgbGlzdFxuICAgICAgaWYgKFxuICAgICAgICAhKHBhcnNlZFVwZGF0ZSBpbnN0YW5jZW9mIFNldFVwZGF0ZSkgfHxcbiAgICAgICAgcGFyc2VkVXBkYXRlLmV4cHJlc3Npb24uaW5jbHVkZXMoJyArICcpIHx8XG4gICAgICAgIHBhcnNlZFVwZGF0ZS5leHByZXNzaW9uLmluY2x1ZGVzKCcgLSAnKSB8fFxuICAgICAgICBuZXN0ZWRLZXlBY2Nlc3NSZWdleC50ZXN0KHBhcnNlZFVwZGF0ZS5leHByZXNzaW9uKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHBhcnNlZFZhbHVlLFxuICAgICAgICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIHN0YXRpYyB2YWx1ZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ3N0YXRpYycsXG4gICAgICAgIHZhbHVlOiBwYXJzZWRWYWx1ZSxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRyaWVkIHRvIHVwZGF0ZSBuZXN0ZWQgdmFsdWUgZm9yIGtleSwgaXQgaXMgY29uc2lkZXJlZCBkeW5hbWljLCBhcyB3ZSBkbyBub3Qga25vdyBmdWxsIHZhbHVlIG9mIHVwZGF0aW5nIGF0dHJpYnV0ZVxuICAgICAgaWYgKG5lc3RlZEtleUFjY2Vzc1JlZ2V4LnRlc3QoYXR0cikpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gdmFsdWUgYXMgYSBkZWZhdWx0IHZhbHVlXG4gICAgICByZXR1cm4ge3R5cGU6ICdzdGF0aWMnLCB2YWx1ZX07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyaWMgUmVjdXJzaXZlIGlucHV0IHBhcnNlclxuICAgKiBSZWN1cnNpdmVseSBwYXJzZXMgbmVzdGVkIG9iamVjdCB0byBidWlsZCBleHByZXNzaW9uIG9mIHR5cGUgRXhwQ2xhc3NcbiAgICogQHBhcmFtIG9wdGlvbnMgQ29tcGxleCBvcHRpb25zIG9iamVjdCB0byBwYXJzZVxuICAgKiBAcGFyYW0gRXhwQ2xhc3MgVHlwZSBvZiBleHByZXNzaW9uIHRvIGJ1aWxkLCBjYW4gYmUgb2YgdHlwZSBGaWx0ZXIsIENvbmRpdGlvbiBldGMuXG4gICAqXG4gICAqL1xuICBwcml2YXRlIHJlY3Vyc2l2ZVBhcnNlVG9CYXNlRXhwcmVzc2lvbjxUIGV4dGVuZHMgQmFzZUV4cHJlc3Npb25JbnB1dD4oXG4gICAgb3B0aW9uczogYW55LFxuICAgIEV4cENsYXNzOiBuZXcgKCkgPT4gVFxuICApIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob3B0aW9ucykubWFwKChbb3BlcmF0b3JPckF0dHIsIHZhbHVlXSk6IFQgPT4ge1xuICAgICAgLy8gaWYgdG9wIGxldmVsIGtleSBpcyBvbmUgb2YgdGhlIGxvZ2ljYWwgb3BlcmF0b3JzLCByZXJ1biBwYXJzZSB3aXRoIGl0J3MgdmFsdWVzXG4gICAgICBpZiAoWydBTkQnLCAnT1InLCAnTk9UJ10uaW5jbHVkZXMob3BlcmF0b3JPckF0dHIpKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZEV4cExpc3QgPSB0aGlzLnJlY3Vyc2l2ZVBhcnNlVG9CYXNlRXhwcmVzc2lvbjxUPihcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBFeHBDbGFzc1xuICAgICAgICApO1xuICAgICAgICBjb25zdCBiYXNlID0gcGFyc2VkRXhwTGlzdC5zaGlmdCgpO1xuICAgICAgICBpZiAoIWJhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IEV4cENsYXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcGVyYXRvck9yQXR0cikge1xuICAgICAgICAgIGNhc2UgJ0FORCc6IHtcbiAgICAgICAgICAgIGlmICghcGFyc2VkRXhwTGlzdD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2UubWVyZ2VNYW55KHBhcnNlZEV4cExpc3QgYXMgVFtdLCBNRVJHRV9TVFJBVEVHWS5BTkQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlICdPUic6IHtcbiAgICAgICAgICAgIGlmICghcGFyc2VkRXhwTGlzdD8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2UubWVyZ2VNYW55KHBhcnNlZEV4cExpc3QgYXMgVFtdLCBNRVJHRV9TVFJBVEVHWS5PUik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJ05PVCc6IHtcbiAgICAgICAgICAgIC8vIG5vdCBjYW4gbm90IGNvbnRhaW4gbW9yZSB0aGFuIG9uZSBpdGVtc1xuICAgICAgICAgICAgaWYgKHBhcnNlZEV4cExpc3Q/Lmxlbmd0aCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYFZhbHVlIGZvciBvcGVyYXRvciBcIiR7b3BlcmF0b3JPckF0dHJ9XCIgY2FuIG5vdCBjb250YWluIG1vcmUgdGhhbiAxIGF0dHJpYnV0ZXMuYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJhc2Uubm90KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbG9naWNhbCBvcGVyYXRvciBcIiR7b3BlcmF0b3JPckF0dHJ9XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdoZW4gdG9wIGxldmVsIGF0dHJpYnV0ZSBpcyBzb21ldGhpbmcgb3RoZXIgdGhhbiBhY3R1YWwgbG9naWNhbCBvcGVyYXRvcnMsIHRyeSB0byBwYXJzZSBpdCB0byBleHByZXNzaW9uXG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yVG9CYXNlRXhwcmVzc2lvbihcbiAgICAgICAgICBvcGVyYXRvck9yQXR0cixcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBuZXcgRXhwQ2xhc3MoKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBpbnB1dCB0byB1cGRhdGUgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gYm9keSBib2R5IHRvIHBhcnNlXG4gICAqL1xuICBwcml2YXRlIHBhcnNlVG9VcGRhdGVFeHByZXNzaW9uKFxuICAgIGJvZHk6IGFueSxcbiAgICBhdHRyVmFsdWVPdmVycmlkZU1hcDogUmVjb3JkPHN0cmluZywgYW55PlxuICApIHtcbiAgICByZXR1cm4gKFxuICAgICAgT2JqZWN0LmVudHJpZXMoYm9keSlcbiAgICAgICAgLm1hcCgoW2F0dHIsIHZhbHVlXSkgPT4ge1xuICAgICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgIWlzRW1wdHlPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbb3BlcmF0b3IsIG9wZXJhdG9yVmFsdWVdID0gT2JqZWN0LmVudHJpZXMoXG4gICAgICAgICAgICAgIHZhbHVlIGFzIGFueVxuICAgICAgICAgICAgKVswXSBhcyBbXG4gICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICB8IFVwZGF0ZVR5cGUuQXJpdGhtZXRpY09wZXJhdG9yXG4gICAgICAgICAgICAgICAgfCBVcGRhdGVUeXBlLlNldFVwZGF0ZU9wZXJhdG9yXG4gICAgICAgICAgICAgICAgfCBVcGRhdGVUeXBlLkFjdGlvblxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBhbnlcbiAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWVUb1VwZGF0ZUV4cChcbiAgICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIG9wZXJhdG9yLFxuICAgICAgICAgICAgICBvcGVyYXRvclZhbHVlLFxuICAgICAgICAgICAgICBhdHRyVmFsdWVPdmVycmlkZU1hcFthdHRyXSAvLyBnZXQgYW55IG92ZXJyaWRlIHZhbHVlIGlmIGV4aXN0c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCBgU0VUYCBhY3Rpb24gYmFzZWQgdXBkYXRlXG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldFVwZGF0ZSgpLnNldFRvKFxuICAgICAgICAgICAgICBhdHRyLFxuICAgICAgICAgICAgICBhdHRyVmFsdWVPdmVycmlkZU1hcFthdHRyXSB8fCB2YWx1ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC8vIG1lcmdlIGFsbCBleHByZXNzaW9ucyB3aXRoIG1hdGNoaW5nIGFjdGlvblxuICAgICAgICAucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cnJFeHApID0+IHtcbiAgICAgICAgICAgIGFjY1xuICAgICAgICAgICAgICAuZmluZChpbnN0YW5jZSA9PiBpbnN0YW5jZS5jb25zdHJ1Y3RvciA9PT0gY3VyckV4cC5jb25zdHJ1Y3RvcikhXG4gICAgICAgICAgICAgIC5tZXJnZShjdXJyRXhwKTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBbXG4gICAgICAgICAgICBuZXcgU2V0VXBkYXRlKCksXG4gICAgICAgICAgICBuZXcgQWRkVXBkYXRlKCksXG4gICAgICAgICAgICBuZXcgUmVtb3ZlVXBkYXRlKCksXG4gICAgICAgICAgICBuZXcgRGVsZXRlVXBkYXRlKCksXG4gICAgICAgICAgXVxuICAgICAgICApXG4gICAgICAgIC8vIG1lcmdlIGFsbCBleHByZXNzaW9ucyBvZiBkaWZmZXJlbnQgYWN0aW9uc1xuICAgICAgICAucmVkdWNlKChhY2MsIGN1cnIpID0+IHtcbiAgICAgICAgICBhY2MubWVyZ2UoY3Vycik7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwgbmV3IFVwZGF0ZSgpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHNpbmdsZSBhdHRyaWJ1dGUgaW50byB1cGRhdGUgZXhwcmVzc2lvbiBpbnN0YW5jZVxuICAgKiBAcGFyYW0gYXR0cmlidXRlIG5hbWUvcGF0aCBvZiB0aGUgYXR0cmlidXRlXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVWYWx1ZSB2YWx1ZSB0byB1cGRhdGVcbiAgICovXG4gIHByaXZhdGUgcGFyc2VWYWx1ZVRvVXBkYXRlRXhwKFxuICAgIGF0dHJpYnV0ZTogc3RyaW5nLFxuICAgIGF0dHJpYnV0ZVZhbHVlOiBhbnksIC8vIGF0dHJpYnV0ZSB2YWx1ZSB0byBzZXRcbiAgICBvcGVyYXRvcjpcbiAgICAgIHwgVXBkYXRlVHlwZS5Bcml0aG1ldGljT3BlcmF0b3JcbiAgICAgIHwgVXBkYXRlVHlwZS5TZXRVcGRhdGVPcGVyYXRvclxuICAgICAgfCBVcGRhdGVUeXBlLkFjdGlvbixcbiAgICBvcGVyYXRvclZhbHVlOiBhbnksXG4gICAgc3RhdGljVmFsdWVUb092ZXJyaWRlPzogYW55IC8vIHZhbHVlIHRvIG92ZXJyaWRlIGZvciBhdHRyaWJ1dGUsIHRoaXMgaXMgc2V0IGluIGNhc2VzIHdoZXJlIHRoZXJlIHdhcyBhIGN1c3RvbSBwcm9wZXJ0eSB0cmFuc2Zvcm0gd2FzIHJlcXVlc3RlZFxuICApOiBVcGRhdGUge1xuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJ0lOQ1JFTUVOVF9CWSc6XG4gICAgICBjYXNlICdERUNSRU1FTlRfQlknOiB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG8oYXR0cmlidXRlLCBvcGVyYXRvclZhbHVlLCBvcGVyYXRvcik7XG4gICAgICB9XG4gICAgICBjYXNlICdJRl9OT1RfRVhJU1RTJzoge1xuICAgICAgICBpZiAoaXNTZXRPcGVyYXRvckNvbXBsZXhWYWx1ZVR5cGUob3BlcmF0b3JWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldFVwZGF0ZSgpLnNldFRvSWZOb3RFeGlzdHMoXG4gICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICBzdGF0aWNWYWx1ZVRvT3ZlcnJpZGUgfHwgb3BlcmF0b3JWYWx1ZS4kVkFMVUUsXG4gICAgICAgICAgICBvcGVyYXRvclZhbHVlLiRQQVRIXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldFVwZGF0ZSgpLnNldFRvSWZOb3RFeGlzdHMoYXR0cmlidXRlLCBvcGVyYXRvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnTElTVF9BUFBFTkQnOiB7XG4gICAgICAgIGlmIChpc1NldE9wZXJhdG9yQ29tcGxleFZhbHVlVHlwZShvcGVyYXRvclZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0T3JBcHBlbmRUb0xpc3QoXG4gICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICBvcGVyYXRvclZhbHVlLiRWQUxVRSxcbiAgICAgICAgICAgIG9wZXJhdG9yVmFsdWUuJFBBVEhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0T3JBcHBlbmRUb0xpc3QoYXR0cmlidXRlLCBvcGVyYXRvclZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnU0VUJzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogYWxpYXNlZCBzZXQgc3VwcG9ydCwgdGhpcyBhbGxvd3MgYWNjZXNzIHBhdHRlcm5zIGxpa2VcbiAgICAgICAgICoge2lkOiB7IFNFVDogJzEnfX1cbiAgICAgICAgICogYmVoYXZlcyBzaW1pbGFyIHRvIHtpZDogJzEnfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaGFuZGxlIGV4cGxpY2l0IHNldCBleHBcbiAgICAgICAgaWYgKGlzT2JqZWN0KG9wZXJhdG9yVmFsdWUpICYmICFpc0VtcHR5T2JqZWN0KG9wZXJhdG9yVmFsdWUpKSB7XG4gICAgICAgICAgY29uc3QgW25lc3RlZE9wZXJhdG9yLCBuZXN0ZWRPcGVyYXRvclZhbHVlXSA9IE9iamVjdC5lbnRyaWVzKFxuICAgICAgICAgICAgb3BlcmF0b3JWYWx1ZVxuICAgICAgICAgIClbMF0gYXMgW1xuICAgICAgICAgICAgVXBkYXRlVHlwZS5Bcml0aG1ldGljT3BlcmF0b3IgfCBVcGRhdGVUeXBlLlNldFVwZGF0ZU9wZXJhdG9yLFxuICAgICAgICAgICAgYW55XG4gICAgICAgICAgXTtcblxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWVUb1VwZGF0ZUV4cChcbiAgICAgICAgICAgIGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIG5lc3RlZE9wZXJhdG9yVmFsdWUsXG4gICAgICAgICAgICBuZXN0ZWRPcGVyYXRvcixcbiAgICAgICAgICAgIG5lc3RlZE9wZXJhdG9yVmFsdWUsXG4gICAgICAgICAgICBzdGF0aWNWYWx1ZVRvT3ZlcnJpZGVcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGUgd2l0aCBtYXAgdHlwZVxuICAgICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG8oXG4gICAgICAgICAgICBhdHRyaWJ1dGUsXG4gICAgICAgICAgICBzdGF0aWNWYWx1ZVRvT3ZlcnJpZGUgfHwgb3BlcmF0b3JWYWx1ZVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhc2UgJ0FERCc6IHtcbiAgICAgICAgaWYgKGlzRW1wdHlPYmplY3Qob3BlcmF0b3JWYWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSAke29wZXJhdG9yVmFsdWV9IHJlY2VpdmVkIGZvciBhY3Rpb24gXCJBRERcIiwgT25seSBudW1iZXJzIGFuZCBsaXN0cyBhcmUgc3VwcG9ydGVkLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWRkVXBkYXRlKCkuYWRkVG8oYXR0cmlidXRlLCBvcGVyYXRvclZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0RFTEVURSc6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWxldGVVcGRhdGUoKS5kZWxldGUoYXR0cmlidXRlLCBvcGVyYXRvclZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1JFTU9WRSc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRvclZhbHVlID09PSAnYm9vbGVhbicgJiYgISFvcGVyYXRvclZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVVcGRhdGUoKS5yZW1vdmUoYXR0cmlidXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAhaXNFbXB0eU9iamVjdChvcGVyYXRvclZhbHVlKSAmJlxuICAgICAgICAgIEFycmF5LmlzQXJyYXkob3BlcmF0b3JWYWx1ZS4kQVRfSU5ERVgpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlVXBkYXRlKCkucmVtb3ZlKGF0dHJpYnV0ZSwge1xuICAgICAgICAgICAgYXRJbmRleGVzOiBvcGVyYXRvclZhbHVlLiRBVF9JTkRFWCxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSAke29wZXJhdG9yVmFsdWV9IHJlY2VpdmVkIGZvciBhY3Rpb24gXCJSRU1PVkVcIi4gVmFsdWUgbXVzdCBiZSBzZXQgdG8gYm9vbGVhblxuICAgICAgICAgICAgSW4gYWRkaXRpb24sIFlvdSBtYXkgdXNlIHNwZWNpYWwgdmFsdWUgdHlwZSB7JEFUX0lOREVYOiBBcnJheTxudW1iZXI+fSBmb3IgYXR0cmlidXRlIG9mIHR5cGUgbGlzdC4uYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgLy8gaGFuZGxlIGF0dHJpYnV0ZSB3aXRoIG1hcCB0eXBlXG4gICAgICAgIHJldHVybiBuZXcgU2V0VXBkYXRlKCkuc2V0VG8oXG4gICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgIHN0YXRpY1ZhbHVlVG9PdmVycmlkZSB8fCBhdHRyaWJ1dGVWYWx1ZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIHRoaXMgaXMgcnVuLCBpdCBpcyBhc3N1bWVkIHRoYXQgYXR0cmlidXRlL3ZhbHVlIGFyZSB2YWxpZGF0ZWQgdG8gbm90IGhhdmUgYW55IG5lc3RlZCBvYmplY3RzLFxuICAgKiB0aGVyZWZvciB0aGlzIGZ1bmN0aW9uIHdpbGwgbm90IHJ1bm5pbmcgaW4gYW55IHJlY3Vyc2lvbiBpdHNlbGZcbiAgICogQHBhcmFtIGF0dHJpYnV0ZSBBdHRyaWJ1dGUgb3IgcGF0aCBvbiBlbnRpdHkgdG8gYnVpbGQgY29tcGFyaXNvbiBjb25kaXRpb24gZm9yXG4gICAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBleHBlY3RcbiAgICogQHBhcmFtIGV4cCBleHByZXNzaW9uIHRvIGFwcGVuZCBvcGVyYXRvcnMgdG9cbiAgICovXG4gIHByaXZhdGUgb3BlcmF0b3JUb0Jhc2VFeHByZXNzaW9uPFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0PihcbiAgICBhdHRyaWJ1dGU6IGFueSxcbiAgICB2YWx1ZTogYW55LFxuICAgIGV4cDogVFxuICApIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgY2FzZSAnc3RyaW5nJzoge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdBVFRSSUJVVEVfRVhJU1RTJykge1xuICAgICAgICAgIGV4cC5hdHRyaWJ1dGVFeGlzdHMoYXR0cmlidXRlKTtcbiAgICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnQVRUUklCVVRFX05PVF9FWElTVFMnKSB7XG4gICAgICAgICAgZXhwLmF0dHJpYnV0ZU5vdEV4aXN0cyhhdHRyaWJ1dGUpO1xuICAgICAgICAgIHJldHVybiBleHA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYE9wZXJhdG9yIHVzZWQgbXVzdCBiZSBvbmUgb2YgXCJBVFRSSUJVVEVfRVhJU1RTXCIsIFwiQVRUUklCVVRFX05PVF9FWElTVFNcIiBmb3IgXG4gICAgICAgICAgICBhdHRyaWJ1dGUgXCIke2F0dHJpYnV0ZX1cIi5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FzZSAnb2JqZWN0Jzoge1xuICAgICAgICBpZiAoaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgVmFsdWUgZm9yIGF0dHJpYnV0ZSBcIiR7YXR0cmlidXRlfVwiIGNhbiBub3QgYmUgZW1wdHlgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9wZXJhdG9yQW5kVmFsdWUgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgICAgIGlmIChvcGVyYXRvckFuZFZhbHVlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIFwiJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICl9XCIgZm91bmQgZm9yIGF0dHJpYnV0ZTogJHthdHRyaWJ1dGV9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2lubmVyT3AsIGlubmVyVmFsXSA9IG9wZXJhdG9yQW5kVmFsdWVbMF0gYXMgW2FueSwgU2NhbGFyVHlwZV07XG5cbiAgICAgICAgaWYgKGlzU2NhbGFyVHlwZShpbm5lclZhbCkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjYWxhclZhbHVlVG9FeHAoaW5uZXJPcCwgYXR0cmlidXRlLCBpbm5lclZhbCwgZXhwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU5vblNjYWxhclZhbHVlVG9FeHAoXG4gICAgICAgICAgICBpbm5lck9wLFxuICAgICAgICAgICAgYXR0cmlidXRlLFxuICAgICAgICAgICAgaW5uZXJWYWwsXG4gICAgICAgICAgICBleHBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVmFsdWUgZm9yIGF0dHJpYnV0ZSBcIiR7YXR0cmlidXRlfVwiIG11c3QgYmUgb2YgdHlwZSBvYmplY3Qgb3Igc3RyaW5nYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgY29tcGFyaXNvbiBleHByZXNzaW9uIGZvciBvcGVyYXRvcnMgd2l0aCBzY2FsYXIgdmFsdWVzXG4gICAqIEBwYXJhbSBvcGVyYXRvciBvcGVyYXRvciB0aGF0IHN1cHBvcnRzIHNjYWxhciB2YWx1ZXNcbiAgICogQHBhcmFtIGF0dHJQYXRoIGF0dHJpYnV0ZSBwYXRoIHRvIGluY2x1ZGUgaW4gYnVpbHQgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gZXhwZWN0IGluIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIGV4cCBleHByZXNzaW9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgcGFyc2VTY2FsYXJWYWx1ZVRvRXhwPFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0PihcbiAgICBvcGVyYXRvcjogU2ltcGxlT3BlcmF0b3IgfCAnQkVHSU5TX1dJVEgnIHwgJ0NPTlRBSU5TJyB8ICdBVFRSSUJVVEVfVFlQRScsXG4gICAgYXR0clBhdGg6IHN0cmluZyxcbiAgICB2YWx1ZTogU2NhbGFyVHlwZSxcbiAgICBleHA6IFRcbiAgKSB7XG4gICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgY2FzZSAnRVEnOiB7XG4gICAgICAgIGV4cC5lcXVhbHMoYXR0clBhdGgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0xUJzoge1xuICAgICAgICBleHAubGVzc1RoYW4oYXR0clBhdGgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0xFJzoge1xuICAgICAgICBleHAubGVzc1RoYW5BbmRFcXVhbFRvKGF0dHJQYXRoLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdHVCc6IHtcbiAgICAgICAgZXhwLmdyZWF0ZXJUaGFuKGF0dHJQYXRoLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdHRSc6IHtcbiAgICAgICAgZXhwLmdyZWF0ZXJUaGFuQW5kRXF1YWxUbyhhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnTkUnOiB7XG4gICAgICAgIGV4cC5ub3RFcXVhbHMoYXR0clBhdGgsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGV4cDtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ0JFR0lOU19XSVRIJzoge1xuICAgICAgICBleHAuYmVnaW5zV2l0aChhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnQ09OVEFJTlMnOiB7XG4gICAgICAgIGV4cC5jb250YWlucyhhdHRyUGF0aCwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gZXhwO1xuICAgICAgfVxuICAgICAgY2FzZSAnQVRUUklCVVRFX1RZUEUnOiB7XG4gICAgICAgIGV4cC5hdHRyaWJ1dGVUeXBlKGF0dHJQYXRoLCB2YWx1ZSBhcyBBVFRSSUJVVEVfVFlQRSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICR7b3BlcmF0b3J9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBjb21wYXJpc29uIGV4cHJlc3Npb24gZm9yIG9wZXJhdG9ycyB3aXRoIE5vbiBzY2FsYXIgdmFsdWVzLCBpLmUgcmFuZ2VzIGFuZCBzaXplXG4gICAqIEBwYXJhbSBvcGVyYXRvciBvcGVyYXRvciB0aGF0IHN1cHBvcnRzIHNjYWxhciB2YWx1ZXNcbiAgICogQHBhcmFtIGF0dHJQYXRoIGF0dHJpYnV0ZSBwYXRoIHRvIGluY2x1ZGUgaW4gYnVpbHQgZXhwcmVzc2lvblxuICAgKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gZXhwZWN0IGluIGV4cHJlc3Npb25cbiAgICogQHBhcmFtIGV4cCBleHByZXNzaW9uIHR5cGVcbiAgICovXG4gIHByaXZhdGUgcGFyc2VOb25TY2FsYXJWYWx1ZVRvRXhwPFQgZXh0ZW5kcyBCYXNlRXhwcmVzc2lvbklucHV0PihcbiAgICBvcGVyYXRvcjogUmFuZ2VPcGVyYXRvciB8ICdTSVpFJyxcbiAgICBhdHRyUGF0aDogc3RyaW5nLFxuICAgIHZhbHVlOiBhbnksXG4gICAgZXhwOiBUXG4gICkge1xuICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgIGNhc2UgJ0JFVFdFRU4nOiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFZhbHVlIGZvciBvcGVyYXRvciAke29wZXJhdG9yfSBtdXN0IGJlIG9mIHR5cGUgYXJyYXkgd2l0aCBleGFjdCB0d28gaXRlbXMuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZXhwLmJldHdlZW4oYXR0clBhdGgsIHZhbHVlIGFzIFtTY2FsYXJUeXBlLCBTY2FsYXJUeXBlXSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdJTic6IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFZhbHVlIGZvciBvcGVyYXRvciAke29wZXJhdG9yfSBtdXN0IGJlIG9mIHR5cGUgYXJyYXkgd2l0aCBhdCBsZWFzdCBvbmUgaXRlbS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBleHAuaW4oYXR0clBhdGgsIHZhbHVlIGFzIFNjYWxhclR5cGVbXSk7XG4gICAgICAgIHJldHVybiBleHA7XG4gICAgICB9XG4gICAgICBjYXNlICdTSVpFJzoge1xuICAgICAgICBjb25zdCBvcGVyYXRvckFuZFZhbHVlID0gT2JqZWN0LmVudHJpZXModmFsdWUpO1xuICAgICAgICBpZiAob3BlcmF0b3JBbmRWYWx1ZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBcIiR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICApfVwiIGZvdW5kIGZvciBvcGVyYXRvcjogJHtvcGVyYXRvcn1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbaW5uZXJPcCwgaW5uZXJWYWxdID0gb3BlcmF0b3JBbmRWYWx1ZVswXSBhcyBbYW55LCBTY2FsYXJUeXBlXTtcbiAgICAgICAgY29uc3QgcGFyc2VkRXhwID0gdGhpcy5wYXJzZVNjYWxhclZhbHVlVG9FeHAoXG4gICAgICAgICAgaW5uZXJPcCxcbiAgICAgICAgICBhdHRyUGF0aCxcbiAgICAgICAgICBpbm5lclZhbCxcbiAgICAgICAgICBleHBcbiAgICAgICAgKTtcbiAgICAgICAgLy8gb25jZSBvcGVyYXRvciBjb25kaXRpb24gaGFzIGFwcGxpZWQsIHBhc3MgaXQgdGhyb3VnaCBzaXplXG4gICAgICAgIHBhcnNlZEV4cC5zaXplKGF0dHJQYXRoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZEV4cDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvcGVyYXRvcjogJHtvcGVyYXRvcn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiJdfQ==