import { CONSUMED_CAPACITY_TYPE, EntityAttributes, EntityInstance, EntityTarget, QUERY_ORDER } from '@typedorm/common';
import { Connection } from '../connection/connection';
import { FilterOptions } from '../expression/filter-options-type';
import { ConditionOptions } from '../expression/condition-options-type';
import { MetadataOptions } from '../transformer/base-transformer';
import { ProjectionKeys } from '../expression/projection-keys-options-type';
import { KeyConditionOptions } from '../expression/key-condition-options-type';
import { UpdateBody } from '../expression/update-body-type';
import { DocumentClientTypes } from '@typedorm/document-client';
export interface EntityManagerCreateOptions<Entity> {
    /**
     * @default false
     */
    overwriteIfExists?: boolean;
    /**
     * Specify condition to apply
     */
    where?: ConditionOptions<Entity>;
}
export interface EntityManagerUpdateOptions<Entity> {
    /**
     * @default '.'
     */
    nestedKeySeparator?: string;
    /**
     * Specify condition to apply
     */
    where?: ConditionOptions<Entity>;
}
export interface EntityManagerDeleteOptions<Entity> {
    /**
     * Specify condition to apply
     */
    where?: ConditionOptions<Entity>;
}
export interface EntityManagerFindOptions<Entity, PartitionKey> {
    /**
     * Index to query, when omitted, query will be run against main table
     */
    queryIndex?: string;
    /**
     * Sort key condition
     * @default none - no sort key condition is applied
     */
    keyCondition?: KeyConditionOptions;
    /**
     * Max number of records to query
     * @default - implicit dynamo db query limit is applied
     */
    limit?: number;
    /**
     * Order to query items in
     * @default ASC
     */
    orderBy?: QUERY_ORDER;
    /**
     * Cursor to traverse from
     */
    cursor?: DocumentClientTypes.Key;
    /**
     * Specify filter to apply
     * Avoid using this where possible, since filters in dynamodb applies after items
     * are read
     */
    where?: FilterOptions<Entity, PartitionKey>;
    /**
     * Specifies which attributes to fetch
     * @default all attributes are fetched
     */
    select?: ProjectionKeys<Entity>;
    /**
     * Perform a consistent read on the table, consumes twice as much RCUs then normal
     *
     * @description Strongly consistent reads are not supported on global secondary indexes.
     * If you query a global secondary index with ConsistentRead set to true,
     * you will receive a ValidationException.
     * @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-ConsistentRead
     */
    consistentRead?: boolean;
}
export interface EntityManagerCountOptions<Entity, PartitionKey> {
    /**
     * Index to query, when omitted, query will be run against main table
     */
    queryIndex?: string;
    /**
     * Sort key condition
     * @default none - no sort key condition is applied
     */
    keyCondition?: KeyConditionOptions;
    /**
     * Specify filter to apply
     * Avoid using this where possible, since filters in dynamodb applies after items
     * are read
     */
    where?: FilterOptions<Entity, PartitionKey>;
    /**
     * Perform a consistent read on the table, consumes twice as much RCUs then normal
     *
     * @description Strongly consistent reads are not supported on global secondary indexes.
     * If you query a global secondary index with ConsistentRead set to true,
     * you will receive a ValidationException.
     * @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-ConsistentRead
     */
    consistentRead?: boolean;
}
export interface EntityManagerFindOneOptions<Entity> {
    /**
     * Specifies which attributes to fetch
     * @default all attributes are fetched
     */
    select?: ProjectionKeys<Entity>;
    /**
     * Perform a consistent read on the table, consumes twice as much RCUs then normal
     */
    consistentRead?: boolean;
}
export interface EntityManagerExistsOptions {
    /**
     * Perform a consistent read on the table, consumes twice as much RCUs then normal
     *
     * @description Strongly consistent reads are not supported on global secondary indexes.
     * If you query a global secondary index with ConsistentRead set to true,
     * you will receive a ValidationException.
     * @see https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Query.html#DDB-Query-request-ConsistentRead
     */
    consistentRead?: boolean;
    /**
     * @deprecated - Provide the "requestId" in the next parameter instead
     * Only available here for backwards compatibility
     */
    requestId?: string;
    /**
     * @deprecated - Provide the "returnConsumedCapacity" in the next parameter instead
     * Only available here for backwards compatibility
     */
    returnConsumedCapacity?: CONSUMED_CAPACITY_TYPE;
}
export declare class EntityManager {
    protected connection: Connection;
    private _dcReqTransformer;
    private _entityTransformer;
    constructor(connection: Connection);
    /**
     * Creates new record in table with given entity
     * @param entity Entity to add to table as a new record
     */
    create<Entity>(entity: EntityInstance, options?: EntityManagerCreateOptions<Entity>, metadataOptions?: MetadataOptions): Promise<Entity>;
    /**
     * Finds an record by given primary key, when table uses composite primary key,
     * props must include both partition and sort key attributes
     * @param entityClass Entity to get value of
     * @param props attributes of entity
     */
    findOne<Entity, PrimaryKey = Partial<Entity>>(entityClass: EntityTarget<Entity>, primaryKeyAttributes: PrimaryKey, options?: EntityManagerFindOneOptions<Entity>, metadataOptions?: MetadataOptions): Promise<Entity | undefined>;
    /**
     * Checks if item with given attribute/primary key exists in the table
     * @param entityClass Entity class
     * @param attributes attributes to find items by, must be primary key attributes or attribute marked as unique
     */
    exists<Entity, KeyAttributes = Partial<Entity>>(entityClass: EntityTarget<Entity>, attributes: KeyAttributes, options?: EntityManagerExistsOptions, metadataOptions?: MetadataOptions): Promise<boolean>;
    /**
     *
     * @param entityClass Entity class to update
     * @param primaryKeyAttributes Primary key
     * @param body Attributes to update
     * @param options update options
     */
    update<Entity, PrimaryKey = Partial<Entity>, AdditionalProperties = Entity>(entityClass: EntityTarget<Entity>, primaryKeyAttributes: PrimaryKey, body: UpdateBody<Entity, AdditionalProperties>, options?: EntityManagerUpdateOptions<Entity>, metadataOptions?: MetadataOptions): Promise<Entity | undefined>;
    /**
     * Deletes an entity by primary key
     * @param entityClass Entity Class to delete
     * @param primaryKeyAttributes Entity Primary key
     */
    delete<Entity, PrimaryKeyAttributes = Partial<Entity>>(entityClass: EntityTarget<Entity>, primaryKeyAttributes: PrimaryKeyAttributes, options?: EntityManagerDeleteOptions<Entity>, metadataOptions?: MetadataOptions): Promise<{
        success: boolean;
    }>;
    /**
     * Find items using declarative query options
     * @param entityClass Entity to query
     * @param partitionKey Partition key attributes, If querying an index,
     * this is the partition key attributes of that index
     * @param queryOptions Query Options
     */
    find<Entity, PartitionKey = Partial<EntityAttributes<Entity>> | string>(entityClass: EntityTarget<Entity>, partitionKey: PartitionKey, queryOptions?: EntityManagerFindOptions<Entity, PartitionKey>, metadataOptions?: MetadataOptions): Promise<{
        items: Entity[];
        cursor?: DocumentClientTypes.Key | undefined;
    }>;
    /**
     * Returns a count of total items matching ther query
     * @param entityClass Entity to query
     * @param partitionKey Partition key attributes, If querying an index,
     * this is the partition key attributes of that index
     * @param queryOptions Count Query Options
     */
    count<Entity, PartitionKey = Partial<EntityAttributes<Entity>> | string>(entityClass: EntityTarget<Entity>, partitionKey: PartitionKey, queryOptions?: EntityManagerCountOptions<Entity, PartitionKey>, metadataOptions?: MetadataOptions): Promise<number>;
    /**
     * Recursively queries all items from table
     * @param param Query params
     */
    private _internalRecursiveQuery;
    /**
     * Recursively counts all items from table
     * @param param Query params
     */
    private _internalRecursiveCount;
}
