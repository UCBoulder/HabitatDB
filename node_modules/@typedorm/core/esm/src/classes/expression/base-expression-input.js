import { nestedKeyAccessRegex } from '../../helpers/constants';
const lastCharSpaceMatcher = /\s$/;
export var MERGE_STRATEGY;
(function (MERGE_STRATEGY) {
    MERGE_STRATEGY["AND"] = "AND";
    MERGE_STRATEGY["OR"] = "OR";
})(MERGE_STRATEGY || (MERGE_STRATEGY = {}));
export class BaseExpressionInput {
    expression;
    _names;
    _values;
    constructor() {
        this.expression = '';
    }
    set names(value) {
        this._names = {
            ...this.names,
            ...value,
        };
    }
    get names() {
        return this._names ?? {};
    }
    set values(value) {
        this._values = {
            ...this.values,
            ...value,
        };
    }
    get values() {
        return this._values ?? {};
    }
    appendToExpression(segment) {
        if (!segment) {
            return;
        }
        if (this.expression.length === 0) {
            this.expression += segment;
            return;
        }
        if (!this.hasSpaceInLastChar(this.expression)) {
            this.expression += ' '; // append empty space if does not exist
        }
        this.expression += segment;
    }
    addExpressionName(name) {
        // when trying to access nested prop i.e profile.name, replace . with appropriate expression safe string
        const nestedKeys = name.split('.');
        const topKey = nestedKeys.shift();
        if (!topKey) {
            throw new Error('Expression attribute name can not be empty');
        }
        const topLevelPropKey = this.innerAddExpressionName(topKey);
        return nestedKeys.reduce((acc, keySeg) => {
            let { prefix } = acc;
            // make sure that prefix does not contain any nested value reference
            prefix = prefix.replace(nestedKeyAccessRegex, '');
            const currentSegPropKey = this.innerAddExpressionName(`${prefix}_${keySeg}`, keySeg);
            acc.prefix += `_${keySeg}`;
            acc.encoded += `.${currentSegPropKey}`;
            return acc;
        }, { prefix: topKey, encoded: topLevelPropKey }).encoded;
    }
    innerAddExpressionName(nameKey, nameValue) {
        // match any nested list item reference, and update it to be valid expression
        // i.e key such as addresses[0] will be name #addresses with expression #addresses[0]
        let match = '';
        nameKey = nameKey.replace(nestedKeyAccessRegex, substr => {
            match = substr;
            return '';
        });
        nameValue = nameValue?.replace(match, '');
        const expressionPrefixedName = this.getExpNameKey(nameKey);
        if (this.names[expressionPrefixedName]) {
            throw new Error(`There is already an expression name with key ${expressionPrefixedName}.`);
        }
        this.names = {
            ...this.names,
            [expressionPrefixedName]: nameValue ?? nameKey,
        };
        return expressionPrefixedName + match;
    }
    addExpressionValue(name, value) {
        const expressionSafeName = name.replace(/\./g, '_');
        return this.innerAddExpressionValue(expressionSafeName, value);
    }
    innerAddExpressionValue(name, value) {
        // remove any nested list item reference, it will be handled by names matcher
        // i.e key such as addresses[0]
        name = name.replace(nestedKeyAccessRegex, '');
        const expressionPrefixedValue = this.getExpValueKey(name);
        if (this.values[expressionPrefixedValue]) {
            throw new Error(`There is already an expression value with key ${expressionPrefixedValue}.`);
        }
        this.values = {
            ...this.values,
            [expressionPrefixedValue]: value,
        };
        return expressionPrefixedValue;
    }
    merge(condition, strategy = MERGE_STRATEGY.AND) {
        const { expression, names, values } = condition;
        // if merging condition does not have anything to merge return
        if (!expression) {
            return this;
        }
        // if base condition does not have any expression replace
        if (!this.expression) {
            this.expression += expression;
            this.names = names;
            this.values = values;
            return this;
        }
        if (strategy === MERGE_STRATEGY.OR) {
            this.or().appendToExpression(`(${expression})`);
        }
        else {
            this.and().appendToExpression(`(${expression})`);
        }
        Object.keys(names).forEach(nameKey => {
            if (this.names[nameKey]) {
                throw new Error(`Failed to merge expression attribute names, there are multiple attributes names with key "${nameKey}"`);
            }
        });
        Object.keys(values).forEach(valueKey => {
            if (this.names[valueKey]) {
                throw new Error(`Failed to merge expression attribute values, there are multiple attributes values with key "${valueKey}"`);
            }
        });
        this.names = { ...this.names, ...names };
        this.values = { ...this.values, ...values };
        return this;
    }
    mergeMany(inputs, strategy) {
        // check if base expression has any value
        if (this.expression) {
            this.expression = `(${this.expression})`;
            this.appendToExpression(strategy);
        }
        inputs.forEach((input, index) => {
            this.appendToExpression(`(${input.expression})`);
            if (index !== inputs.length - 1) {
                this.appendToExpression(strategy);
            }
            Object.keys(input.names).forEach(nameKey => {
                if (this.names[nameKey]) {
                    throw new Error(`Failed to merge expression attribute names, there are multiple attributes names with key "${nameKey}"`);
                }
            });
            Object.keys(input.values).forEach(valueKey => {
                if (this.names[valueKey]) {
                    throw new Error(`Failed to merge expression attribute values, there are multiple attributes values with key "${valueKey}"`);
                }
            });
            this.names = { ...this.names, ...input.names };
            this.values = { ...this.values, ...input.values };
        });
        return this;
    }
    /** Use merge instead
     * @deprecated
     */
    and() {
        this.expression = `(${this.expression})`;
        this.appendToExpression('AND');
        return this;
    }
    not(condition) {
        if (condition) {
            this.expression = `NOT (${condition.expression})`;
            this.names = condition.names;
            this.values = condition.values;
            return this;
        }
        else {
            if (!this.expression) {
                return this;
            }
            this.expression = `NOT (${this.expression})`;
            return this;
        }
    }
    /**
     * Use merge instead
     * @deprecated
     */
    or() {
        this.expression = `(${this.expression})`;
        this.appendToExpression('OR');
        return this;
    }
    beginsWith(key, substring) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, substring);
        this.appendToExpression(`begins_with(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    contains(key, value) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        this.appendToExpression(`contains(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    attributeType(key, type) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, type);
        this.appendToExpression(`attribute_type(${attrExpName}, ${attrExpValue})`);
        return this;
    }
    attributeExists(attr) {
        const attrName = this.addExpressionName(attr);
        this.appendToExpression(`attribute_exists(${attrName})`);
        return this;
    }
    attributeNotExists(attr) {
        const attrName = this.addExpressionName(attr);
        this.appendToExpression(`attribute_not_exists(${attrName})`);
        return this;
    }
    equals(key, value) {
        return this.addBaseOperator('EQ', key, value);
    }
    lessThan(key, value) {
        return this.addBaseOperator('LT', key, value);
    }
    lessThanAndEqualTo(key, value) {
        return this.addBaseOperator('LE', key, value);
    }
    greaterThan(key, value) {
        return this.addBaseOperator('GT', key, value);
    }
    greaterThanAndEqualTo(key, value) {
        return this.addBaseOperator('GE', key, value);
    }
    notEquals(key, value) {
        return this.addBaseOperator('NE', key, value);
    }
    between(key, value) {
        if (value.length !== 2) {
            throw new Error('Incorrect query value for BETWEEN operator, it requires array containing two values.');
        }
        const [startIncluding, endIncluding] = value;
        const attrExpName = this.addExpressionName(key);
        const attrExpValueStart = this.addExpressionValue(`${key}_start`, startIncluding);
        const attrExpValueEnd = this.addExpressionValue(`${key}_end`, endIncluding);
        this.appendToExpression(`${attrExpName} BETWEEN ${attrExpValueStart} AND ${attrExpValueEnd}`);
        return this;
    }
    in(key, values) {
        if (values.length < 1) {
            throw new Error('Incorrect value for IN operator, it requires array containing at lease one SCALAR type value.');
        }
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = values.reduce((acc, value, index) => {
            const attrExpValueStart = this.addExpressionValue(`${key}_${index}`, value);
            acc += attrExpValueStart;
            if (index !== values.length - 1) {
                // if not last index append separator followed by space
                acc += ', ';
            }
            return acc;
        }, '');
        this.appendToExpression(`${attrExpName} IN (${attrExpValue})`);
        return this;
    }
    size(key) {
        const attrExpName = this.getExpNameKey(key);
        this.expression = this.expression.replace(attrExpName, `size(${attrExpName})`);
        return this;
    }
    addBaseOperator(operator, key, value) {
        const attrExpName = this.addExpressionName(key);
        const attrExpValue = this.addExpressionValue(key, value);
        this.appendToExpression(`${attrExpName} ${this.getSymbolForOperator(operator)} ${attrExpValue}`);
        return this;
    }
    getSymbolForOperator(operator) {
        const symbolMap = {
            EQ: '=',
            LE: '<=',
            LT: '<',
            GE: '>=',
            GT: '>',
            NE: '<>',
        };
        return symbolMap[operator];
    }
    hasSpaceInLastChar(match) {
        return lastCharSpaceMatcher.test(match);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1leHByZXNzaW9uLWlucHV0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY2xhc3Nlcy9leHByZXNzaW9uL2Jhc2UtZXhwcmVzc2lvbi1pbnB1dC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUU3RCxNQUFNLG9CQUFvQixHQUFHLEtBQUssQ0FBQztBQUNuQyxNQUFNLENBQU4sSUFBWSxjQUdYO0FBSEQsV0FBWSxjQUFjO0lBQ3hCLDZCQUFXLENBQUE7SUFDWCwyQkFBUyxDQUFBO0FBQ1gsQ0FBQyxFQUhXLGNBQWMsS0FBZCxjQUFjLFFBR3pCO0FBRUQsTUFBTSxPQUFnQixtQkFBbUI7SUFDdkMsVUFBVSxDQUFTO0lBQ1QsTUFBTSxDQUF3QjtJQUM5QixPQUFPLENBQXdCO0lBRXpDO1FBQ0UsSUFBSSxDQUFDLFVBQVUsR0FBRyxFQUFFLENBQUM7SUFDdkIsQ0FBQztJQUVELElBQUksS0FBSyxDQUFDLEtBQVU7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRztZQUNaLEdBQUcsSUFBSSxDQUFDLEtBQUs7WUFDYixHQUFHLEtBQUs7U0FDVCxDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVELElBQUksTUFBTSxDQUFDLEtBQVU7UUFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRztZQUNiLEdBQUcsSUFBSSxDQUFDLE1BQU07WUFDZCxHQUFHLEtBQUs7U0FDVCxDQUFDO0lBQ0osQ0FBQztJQUVELElBQUksTUFBTTtRQUNSLE9BQU8sSUFBSSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUM7SUFDNUIsQ0FBQztJQU1TLGtCQUFrQixDQUFDLE9BQWU7UUFDMUMsSUFBSSxDQUFDLE9BQU8sRUFB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VTtRQUVWLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNoRCxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxrQkFBa0IsQ0FDckIsR0FBRyxXQUFXLElBQUksSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxJQUFJLFlBQVksRUFBRSxDQUN4RSxDQUFDO1FBQ0YsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRVMsb0JBQW9CLENBQUMsUUFBd0I7UUFDckQsTUFBTSxTQUFTLEdBQUc7WUFDaEIsRUFBRSxFQUFFLEdBQUc7WUFDUCxFQUFFLEVBQUUsSUFBSTtZQUNSLEVBQUUsRUFBRSxHQUFHO1lBQ1AsRUFBRSxFQUFFLElBQUk7WUFDUixFQUFFLEVBQUUsR0FBRztZQUNQLEVBQUUsRUFBRSxJQUFJO1NBQ1QsQ0FBQztRQUNGLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxLQUFhO1FBQ3RDLE9BQU8sb0JBQW9CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QVRUUklCVVRFX1RZUEUsIFNjYWxhclR5cGUsIFNpbXBsZU9wZXJhdG9yfSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCB7bmVzdGVkS2V5QWNjZXNzUmVnZXh9IGZyb20gJy4uLy4uL2hlbHBlcnMvY29uc3RhbnRzJztcblxuY29uc3QgbGFzdENoYXJTcGFjZU1hdGNoZXIgPSAvXFxzJC87XG5leHBvcnQgZW51bSBNRVJHRV9TVFJBVEVHWSB7XG4gIEFORCA9ICdBTkQnLFxuICBPUiA9ICdPUicsXG59XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlRXhwcmVzc2lvbklucHV0IHtcbiAgZXhwcmVzc2lvbjogc3RyaW5nO1xuICBwcm90ZWN0ZWQgX25hbWVzPzoge1trZXk6IHN0cmluZ106IGFueX07XG4gIHByb3RlY3RlZCBfdmFsdWVzPzoge1trZXk6IHN0cmluZ106IGFueX07XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5leHByZXNzaW9uID0gJyc7XG4gIH1cblxuICBzZXQgbmFtZXModmFsdWU6IGFueSkge1xuICAgIHRoaXMuX25hbWVzID0ge1xuICAgICAgLi4udGhpcy5uYW1lcyxcbiAgICAgIC4uLnZhbHVlLFxuICAgIH07XG4gIH1cblxuICBnZXQgbmFtZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25hbWVzID8/IHt9O1xuICB9XG5cbiAgc2V0IHZhbHVlcyh2YWx1ZTogYW55KSB7XG4gICAgdGhpcy5fdmFsdWVzID0ge1xuICAgICAgLi4udGhpcy52YWx1ZXMsXG4gICAgICAuLi52YWx1ZSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IHZhbHVlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWVzID8/IHt9O1xuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEV4cE5hbWVLZXkoa2V5OiBzdHJpbmcpOiBzdHJpbmc7XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IGdldEV4cFZhbHVlS2V5KGtleTogc3RyaW5nKTogc3RyaW5nO1xuXG4gIHByb3RlY3RlZCBhcHBlbmRUb0V4cHJlc3Npb24oc2VnbWVudDogc3RyaW5nKSB7XG4gICAgaWYgKCFzZWdtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZXhwcmVzc2lvbi5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiArPSBzZWdtZW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5oYXNTcGFjZUluTGFzdENoYXIodGhpcy5leHByZXNzaW9uKSkge1xuICAgICAgdGhpcy5leHByZXNzaW9uICs9ICcgJzsgLy8gYXBwZW5kIGVtcHR5IHNwYWNlIGlmIGRvZXMgbm90IGV4aXN0XG4gICAgfVxuXG4gICAgdGhpcy5leHByZXNzaW9uICs9IHNlZ21lbnQ7XG4gIH1cblxuICBwcm90ZWN0ZWQgYWRkRXhwcmVzc2lvbk5hbWUobmFtZTogc3RyaW5nKSB7XG4gICAgLy8gd2hlbiB0cnlpbmcgdG8gYWNjZXNzIG5lc3RlZCBwcm9wIGkuZSBwcm9maWxlLm5hbWUsIHJlcGxhY2UgLiB3aXRoIGFwcHJvcHJpYXRlIGV4cHJlc3Npb24gc2FmZSBzdHJpbmdcbiAgICBjb25zdCBuZXN0ZWRLZXlzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIGNvbnN0IHRvcEtleSA9IG5lc3RlZEtleXMuc2hpZnQoKTtcblxuICAgIGlmICghdG9wS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cHJlc3Npb24gYXR0cmlidXRlIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICAgIH1cblxuICAgIGNvbnN0IHRvcExldmVsUHJvcEtleSA9IHRoaXMuaW5uZXJBZGRFeHByZXNzaW9uTmFtZSh0b3BLZXkpO1xuICAgIHJldHVybiBuZXN0ZWRLZXlzLnJlZHVjZShcbiAgICAgIChhY2MsIGtleVNlZykgPT4ge1xuICAgICAgICBsZXQge3ByZWZpeH0gPSBhY2M7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHByZWZpeCBkb2VzIG5vdCBjb250YWluIGFueSBuZXN0ZWQgdmFsdWUgcmVmZXJlbmNlXG4gICAgICAgIHByZWZpeCA9IHByZWZpeC5yZXBsYWNlKG5lc3RlZEtleUFjY2Vzc1JlZ2V4LCAnJyk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFNlZ1Byb3BLZXkgPSB0aGlzLmlubmVyQWRkRXhwcmVzc2lvbk5hbWUoXG4gICAgICAgICAgYCR7cHJlZml4fV8ke2tleVNlZ31gLFxuICAgICAgICAgIGtleVNlZ1xuICAgICAgICApO1xuXG4gICAgICAgIGFjYy5wcmVmaXggKz0gYF8ke2tleVNlZ31gO1xuICAgICAgICBhY2MuZW5jb2RlZCArPSBgLiR7Y3VycmVudFNlZ1Byb3BLZXl9YDtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7cHJlZml4OiB0b3BLZXksIGVuY29kZWQ6IHRvcExldmVsUHJvcEtleX1cbiAgICApLmVuY29kZWQ7XG4gIH1cblxuICBwcml2YXRlIGlubmVyQWRkRXhwcmVzc2lvbk5hbWUobmFtZUtleTogc3RyaW5nLCBuYW1lVmFsdWU/OiBzdHJpbmcpIHtcbiAgICAvLyBtYXRjaCBhbnkgbmVzdGVkIGxpc3QgaXRlbSByZWZlcmVuY2UsIGFuZCB1cGRhdGUgaXQgdG8gYmUgdmFsaWQgZXhwcmVzc2lvblxuICAgIC8vIGkuZSBrZXkgc3VjaCBhcyBhZGRyZXNzZXNbMF0gd2lsbCBiZSBuYW1lICNhZGRyZXNzZXMgd2l0aCBleHByZXNzaW9uICNhZGRyZXNzZXNbMF1cblxuICAgIGxldCBtYXRjaCA9ICcnO1xuICAgIG5hbWVLZXkgPSBuYW1lS2V5LnJlcGxhY2UobmVzdGVkS2V5QWNjZXNzUmVnZXgsIHN1YnN0ciA9PiB7XG4gICAgICBtYXRjaCA9IHN1YnN0cjtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICBuYW1lVmFsdWUgPSBuYW1lVmFsdWU/LnJlcGxhY2UobWF0Y2gsICcnKTtcblxuICAgIGNvbnN0IGV4cHJlc3Npb25QcmVmaXhlZE5hbWUgPSB0aGlzLmdldEV4cE5hbWVLZXkobmFtZUtleSk7XG4gICAgaWYgKHRoaXMubmFtZXNbZXhwcmVzc2lvblByZWZpeGVkTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gZXhwcmVzc2lvbiBuYW1lIHdpdGgga2V5ICR7ZXhwcmVzc2lvblByZWZpeGVkTmFtZX0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lcyA9IHtcbiAgICAgIC4uLnRoaXMubmFtZXMsXG4gICAgICBbZXhwcmVzc2lvblByZWZpeGVkTmFtZV06IG5hbWVWYWx1ZSA/PyBuYW1lS2V5LFxuICAgIH07XG4gICAgcmV0dXJuIGV4cHJlc3Npb25QcmVmaXhlZE5hbWUgKyBtYXRjaDtcbiAgfVxuXG4gIHByb3RlY3RlZCBhZGRFeHByZXNzaW9uVmFsdWUobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgY29uc3QgZXhwcmVzc2lvblNhZmVOYW1lID0gbmFtZS5yZXBsYWNlKC9cXC4vZywgJ18nKTtcbiAgICByZXR1cm4gdGhpcy5pbm5lckFkZEV4cHJlc3Npb25WYWx1ZShleHByZXNzaW9uU2FmZU5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5uZXJBZGRFeHByZXNzaW9uVmFsdWUobmFtZTogc3RyaW5nLCB2YWx1ZTogYW55KSB7XG4gICAgLy8gcmVtb3ZlIGFueSBuZXN0ZWQgbGlzdCBpdGVtIHJlZmVyZW5jZSwgaXQgd2lsbCBiZSBoYW5kbGVkIGJ5IG5hbWVzIG1hdGNoZXJcbiAgICAvLyBpLmUga2V5IHN1Y2ggYXMgYWRkcmVzc2VzWzBdXG4gICAgbmFtZSA9IG5hbWUucmVwbGFjZShuZXN0ZWRLZXlBY2Nlc3NSZWdleCwgJycpO1xuXG4gICAgY29uc3QgZXhwcmVzc2lvblByZWZpeGVkVmFsdWUgPSB0aGlzLmdldEV4cFZhbHVlS2V5KG5hbWUpO1xuICAgIGlmICh0aGlzLnZhbHVlc1tleHByZXNzaW9uUHJlZml4ZWRWYWx1ZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYFRoZXJlIGlzIGFscmVhZHkgYW4gZXhwcmVzc2lvbiB2YWx1ZSB3aXRoIGtleSAke2V4cHJlc3Npb25QcmVmaXhlZFZhbHVlfS5gXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlcyA9IHtcbiAgICAgIC4uLnRoaXMudmFsdWVzLFxuICAgICAgW2V4cHJlc3Npb25QcmVmaXhlZFZhbHVlXTogdmFsdWUsXG4gICAgfTtcbiAgICByZXR1cm4gZXhwcmVzc2lvblByZWZpeGVkVmFsdWU7XG4gIH1cblxuICBtZXJnZShcbiAgICBjb25kaXRpb246IEJhc2VFeHByZXNzaW9uSW5wdXQsXG4gICAgc3RyYXRlZ3k6IE1FUkdFX1NUUkFURUdZID0gTUVSR0VfU1RSQVRFR1kuQU5EXG4gICk6IHRoaXMge1xuICAgIGNvbnN0IHtleHByZXNzaW9uLCBuYW1lcywgdmFsdWVzfSA9IGNvbmRpdGlvbjtcblxuICAgIC8vIGlmIG1lcmdpbmcgY29uZGl0aW9uIGRvZXMgbm90IGhhdmUgYW55dGhpbmcgdG8gbWVyZ2UgcmV0dXJuXG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBpZiBiYXNlIGNvbmRpdGlvbiBkb2VzIG5vdCBoYXZlIGFueSBleHByZXNzaW9uIHJlcGxhY2VcbiAgICBpZiAoIXRoaXMuZXhwcmVzc2lvbikge1xuICAgICAgdGhpcy5leHByZXNzaW9uICs9IGV4cHJlc3Npb247XG4gICAgICB0aGlzLm5hbWVzID0gbmFtZXM7XG4gICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChzdHJhdGVneSA9PT0gTUVSR0VfU1RSQVRFR1kuT1IpIHtcbiAgICAgIHRoaXMub3IoKS5hcHBlbmRUb0V4cHJlc3Npb24oYCgke2V4cHJlc3Npb259KWApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFuZCgpLmFwcGVuZFRvRXhwcmVzc2lvbihgKCR7ZXhwcmVzc2lvbn0pYCk7XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMobmFtZXMpLmZvckVhY2gobmFtZUtleSA9PiB7XG4gICAgICBpZiAodGhpcy5uYW1lc1tuYW1lS2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBtZXJnZSBleHByZXNzaW9uIGF0dHJpYnV0ZSBuYW1lcywgdGhlcmUgYXJlIG11bHRpcGxlIGF0dHJpYnV0ZXMgbmFtZXMgd2l0aCBrZXkgXCIke25hbWVLZXl9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXModmFsdWVzKS5mb3JFYWNoKHZhbHVlS2V5ID0+IHtcbiAgICAgIGlmICh0aGlzLm5hbWVzW3ZhbHVlS2V5XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBtZXJnZSBleHByZXNzaW9uIGF0dHJpYnV0ZSB2YWx1ZXMsIHRoZXJlIGFyZSBtdWx0aXBsZSBhdHRyaWJ1dGVzIHZhbHVlcyB3aXRoIGtleSBcIiR7dmFsdWVLZXl9XCJgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5uYW1lcyA9IHsuLi50aGlzLm5hbWVzLCAuLi5uYW1lc307XG4gICAgdGhpcy52YWx1ZXMgPSB7Li4udGhpcy52YWx1ZXMsIC4uLnZhbHVlc307XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG1lcmdlTWFueTxUIGV4dGVuZHMgQmFzZUV4cHJlc3Npb25JbnB1dD4oXG4gICAgaW5wdXRzOiBUW10sXG4gICAgc3RyYXRlZ3k6IE1FUkdFX1NUUkFURUdZXG4gICkge1xuICAgIC8vIGNoZWNrIGlmIGJhc2UgZXhwcmVzc2lvbiBoYXMgYW55IHZhbHVlXG4gICAgaWYgKHRoaXMuZXhwcmVzc2lvbikge1xuICAgICAgdGhpcy5leHByZXNzaW9uID0gYCgke3RoaXMuZXhwcmVzc2lvbn0pYDtcbiAgICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKHN0cmF0ZWd5KTtcbiAgICB9XG5cbiAgICBpbnB1dHMuZm9yRWFjaCgoaW5wdXQsIGluZGV4KSA9PiB7XG4gICAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihgKCR7aW5wdXQuZXhwcmVzc2lvbn0pYCk7XG5cbiAgICAgIGlmIChpbmRleCAhPT0gaW5wdXRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oc3RyYXRlZ3kpO1xuICAgICAgfVxuXG4gICAgICBPYmplY3Qua2V5cyhpbnB1dC5uYW1lcykuZm9yRWFjaChuYW1lS2V5ID0+IHtcbiAgICAgICAgaWYgKHRoaXMubmFtZXNbbmFtZUtleV0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRmFpbGVkIHRvIG1lcmdlIGV4cHJlc3Npb24gYXR0cmlidXRlIG5hbWVzLCB0aGVyZSBhcmUgbXVsdGlwbGUgYXR0cmlidXRlcyBuYW1lcyB3aXRoIGtleSBcIiR7bmFtZUtleX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5rZXlzKGlucHV0LnZhbHVlcykuZm9yRWFjaCh2YWx1ZUtleSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm5hbWVzW3ZhbHVlS2V5XSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBGYWlsZWQgdG8gbWVyZ2UgZXhwcmVzc2lvbiBhdHRyaWJ1dGUgdmFsdWVzLCB0aGVyZSBhcmUgbXVsdGlwbGUgYXR0cmlidXRlcyB2YWx1ZXMgd2l0aCBrZXkgXCIke3ZhbHVlS2V5fVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLm5hbWVzID0gey4uLnRoaXMubmFtZXMsIC4uLmlucHV0Lm5hbWVzfTtcbiAgICAgIHRoaXMudmFsdWVzID0gey4uLnRoaXMudmFsdWVzLCAuLi5pbnB1dC52YWx1ZXN9O1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVXNlIG1lcmdlIGluc3RlYWRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGFuZCgpOiB0aGlzIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gPSBgKCR7dGhpcy5leHByZXNzaW9ufSlgO1xuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKCdBTkQnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG5vdDxUIGV4dGVuZHMgQmFzZUV4cHJlc3Npb25JbnB1dD4oY29uZGl0aW9uPzogVCk6IHRoaXMge1xuICAgIGlmIChjb25kaXRpb24pIHtcbiAgICAgIHRoaXMuZXhwcmVzc2lvbiA9IGBOT1QgKCR7Y29uZGl0aW9uLmV4cHJlc3Npb259KWA7XG4gICAgICB0aGlzLm5hbWVzID0gY29uZGl0aW9uLm5hbWVzO1xuICAgICAgdGhpcy52YWx1ZXMgPSBjb25kaXRpb24udmFsdWVzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdGhpcy5leHByZXNzaW9uID0gYE5PVCAoJHt0aGlzLmV4cHJlc3Npb259KWA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlIG1lcmdlIGluc3RlYWRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIG9yKCk6IHRoaXMge1xuICAgIHRoaXMuZXhwcmVzc2lvbiA9IGAoJHt0aGlzLmV4cHJlc3Npb259KWA7XG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oJ09SJyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBiZWdpbnNXaXRoKGtleTogc3RyaW5nLCBzdWJzdHJpbmc6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWUgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShrZXksIHN1YnN0cmluZyk7XG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oYGJlZ2luc193aXRoKCR7YXR0ckV4cE5hbWV9LCAke2F0dHJFeHBWYWx1ZX0pYCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjb250YWlucyhrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWUgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihgY29udGFpbnMoJHthdHRyRXhwTmFtZX0sICR7YXR0ckV4cFZhbHVlfSlgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGF0dHJpYnV0ZVR5cGUoa2V5OiBzdHJpbmcsIHR5cGU6IEFUVFJJQlVURV9UWVBFKTogdGhpcyB7XG4gICAgY29uc3QgYXR0ckV4cE5hbWUgPSB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKGtleSk7XG4gICAgY29uc3QgYXR0ckV4cFZhbHVlID0gdGhpcy5hZGRFeHByZXNzaW9uVmFsdWUoa2V5LCB0eXBlKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihgYXR0cmlidXRlX3R5cGUoJHthdHRyRXhwTmFtZX0sICR7YXR0ckV4cFZhbHVlfSlgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGF0dHJpYnV0ZUV4aXN0cyhhdHRyOiBzdHJpbmcpOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoYXR0cik7XG4gICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oYGF0dHJpYnV0ZV9leGlzdHMoJHthdHRyTmFtZX0pYCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhdHRyaWJ1dGVOb3RFeGlzdHMoYXR0cjogc3RyaW5nKTogdGhpcyB7XG4gICAgY29uc3QgYXR0ck5hbWUgPSB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKGF0dHIpO1xuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKGBhdHRyaWJ1dGVfbm90X2V4aXN0cygke2F0dHJOYW1lfSlgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGVxdWFscyhrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCYXNlT3BlcmF0b3IoJ0VRJywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBsZXNzVGhhbihrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCYXNlT3BlcmF0b3IoJ0xUJywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBsZXNzVGhhbkFuZEVxdWFsVG8oa2V5OiBzdHJpbmcsIHZhbHVlOiBTY2FsYXJUeXBlKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQmFzZU9wZXJhdG9yKCdMRScsIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgZ3JlYXRlclRoYW4oa2V5OiBzdHJpbmcsIHZhbHVlOiBTY2FsYXJUeXBlKTogdGhpcyB7XG4gICAgcmV0dXJuIHRoaXMuYWRkQmFzZU9wZXJhdG9yKCdHVCcsIGtleSwgdmFsdWUpO1xuICB9XG5cbiAgZ3JlYXRlclRoYW5BbmRFcXVhbFRvKGtleTogc3RyaW5nLCB2YWx1ZTogU2NhbGFyVHlwZSk6IHRoaXMge1xuICAgIHJldHVybiB0aGlzLmFkZEJhc2VPcGVyYXRvcignR0UnLCBrZXksIHZhbHVlKTtcbiAgfVxuXG4gIG5vdEVxdWFscyhrZXk6IHN0cmluZywgdmFsdWU6IFNjYWxhclR5cGUpOiB0aGlzIHtcbiAgICByZXR1cm4gdGhpcy5hZGRCYXNlT3BlcmF0b3IoJ05FJywga2V5LCB2YWx1ZSk7XG4gIH1cblxuICBiZXR3ZWVuKGtleTogc3RyaW5nLCB2YWx1ZTogW1NjYWxhclR5cGUsIFNjYWxhclR5cGVdKTogdGhpcyB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSW5jb3JyZWN0IHF1ZXJ5IHZhbHVlIGZvciBCRVRXRUVOIG9wZXJhdG9yLCBpdCByZXF1aXJlcyBhcnJheSBjb250YWluaW5nIHR3byB2YWx1ZXMuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgW3N0YXJ0SW5jbHVkaW5nLCBlbmRJbmNsdWRpbmddID0gdmFsdWU7XG4gICAgY29uc3QgYXR0ckV4cE5hbWUgPSB0aGlzLmFkZEV4cHJlc3Npb25OYW1lKGtleSk7XG4gICAgY29uc3QgYXR0ckV4cFZhbHVlU3RhcnQgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShcbiAgICAgIGAke2tleX1fc3RhcnRgLFxuICAgICAgc3RhcnRJbmNsdWRpbmdcbiAgICApO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZUVuZCA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKGAke2tleX1fZW5kYCwgZW5kSW5jbHVkaW5nKTtcblxuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKFxuICAgICAgYCR7YXR0ckV4cE5hbWV9IEJFVFdFRU4gJHthdHRyRXhwVmFsdWVTdGFydH0gQU5EICR7YXR0ckV4cFZhbHVlRW5kfWBcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaW4oa2V5OiBzdHJpbmcsIHZhbHVlczogU2NhbGFyVHlwZVtdKTogdGhpcyB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJbmNvcnJlY3QgdmFsdWUgZm9yIElOIG9wZXJhdG9yLCBpdCByZXF1aXJlcyBhcnJheSBjb250YWluaW5nIGF0IGxlYXNlIG9uZSBTQ0FMQVIgdHlwZSB2YWx1ZS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5hZGRFeHByZXNzaW9uTmFtZShrZXkpO1xuICAgIGNvbnN0IGF0dHJFeHBWYWx1ZSA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCBhdHRyRXhwVmFsdWVTdGFydCA9IHRoaXMuYWRkRXhwcmVzc2lvblZhbHVlKFxuICAgICAgICBgJHtrZXl9XyR7aW5kZXh9YCxcbiAgICAgICAgdmFsdWVcbiAgICAgICk7XG4gICAgICBhY2MgKz0gYXR0ckV4cFZhbHVlU3RhcnQ7XG4gICAgICBpZiAoaW5kZXggIT09IHZhbHVlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIC8vIGlmIG5vdCBsYXN0IGluZGV4IGFwcGVuZCBzZXBhcmF0b3IgZm9sbG93ZWQgYnkgc3BhY2VcbiAgICAgICAgYWNjICs9ICcsICc7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sICcnKTtcblxuICAgIHRoaXMuYXBwZW5kVG9FeHByZXNzaW9uKGAke2F0dHJFeHBOYW1lfSBJTiAoJHthdHRyRXhwVmFsdWV9KWApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgc2l6ZShrZXk6IHN0cmluZyk6IHRoaXMge1xuICAgIGNvbnN0IGF0dHJFeHBOYW1lID0gdGhpcy5nZXRFeHBOYW1lS2V5KGtleSk7XG4gICAgdGhpcy5leHByZXNzaW9uID0gdGhpcy5leHByZXNzaW9uLnJlcGxhY2UoXG4gICAgICBhdHRyRXhwTmFtZSxcbiAgICAgIGBzaXplKCR7YXR0ckV4cE5hbWV9KWBcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFkZEJhc2VPcGVyYXRvcihcbiAgICBvcGVyYXRvcjogU2ltcGxlT3BlcmF0b3IsXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IGFueVxuICApOiB0aGlzIHtcbiAgICBjb25zdCBhdHRyRXhwTmFtZSA9IHRoaXMuYWRkRXhwcmVzc2lvbk5hbWUoa2V5KTtcbiAgICBjb25zdCBhdHRyRXhwVmFsdWUgPSB0aGlzLmFkZEV4cHJlc3Npb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihcbiAgICAgIGAke2F0dHJFeHBOYW1lfSAke3RoaXMuZ2V0U3ltYm9sRm9yT3BlcmF0b3Iob3BlcmF0b3IpfSAke2F0dHJFeHBWYWx1ZX1gXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTeW1ib2xGb3JPcGVyYXRvcihvcGVyYXRvcjogU2ltcGxlT3BlcmF0b3IpOiBzdHJpbmcge1xuICAgIGNvbnN0IHN5bWJvbE1hcCA9IHtcbiAgICAgIEVROiAnPScsXG4gICAgICBMRTogJzw9JyxcbiAgICAgIExUOiAnPCcsXG4gICAgICBHRTogJz49JyxcbiAgICAgIEdUOiAnPicsXG4gICAgICBORTogJzw+JyxcbiAgICB9O1xuICAgIHJldHVybiBzeW1ib2xNYXBbb3BlcmF0b3JdO1xuICB9XG5cbiAgcHJpdmF0ZSBoYXNTcGFjZUluTGFzdENoYXIobWF0Y2g6IHN0cmluZykge1xuICAgIHJldHVybiBsYXN0Q2hhclNwYWNlTWF0Y2hlci50ZXN0KG1hdGNoKTtcbiAgfVxufVxuIl19