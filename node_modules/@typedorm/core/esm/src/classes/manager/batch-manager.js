import { DocumentClientBatchTransformer } from '../transformer/document-client-batch-transformer';
import pLimit from 'p-limit';
import { BATCH_READ_MAX_ALLOWED_ATTEMPTS, BATCH_WRITE_CONCURRENCY_LIMIT, BATCH_WRITE_MAX_ALLOWED_ATTEMPTS, INTERNAL_ENTITY_ATTRIBUTE, MANAGER_NAME, STATS_TYPE, } from '@typedorm/common';
import { isEmptyObject } from '../../helpers/is-empty-object';
import { getUniqueRequestId } from '../../helpers/get-unique-request-id';
export var REQUEST_TYPE;
(function (REQUEST_TYPE) {
    REQUEST_TYPE["TRANSACT_WRITE"] = "TRANSACT_WRITE";
    REQUEST_TYPE["BATCH_WRITE"] = "BATCH_WRITE";
    REQUEST_TYPE["BATCH_READ"] = "BATCH_READ";
})(REQUEST_TYPE || (REQUEST_TYPE = {}));
export class BatchManager {
    connection;
    _dcBatchTransformer;
    _errorQueue;
    limit = pLimit(BATCH_WRITE_CONCURRENCY_LIMIT);
    constructor(connection) {
        this.connection = connection;
        this._dcBatchTransformer = new DocumentClientBatchTransformer(connection);
        this.resetErrorQueue();
    }
    /**
     * Writes all given items to dynamodb using either batch or transaction api.
     * _Note_: Transaction api is always used when item being written is using a unique attribute
     * @param batch
     */
    async write(batch, options, metadataOptions) {
        this.resetErrorQueue();
        const requestId = getUniqueRequestId(metadataOptions?.requestId);
        if (options?.requestsConcurrencyLimit) {
            this.limit = pLimit(options?.requestsConcurrencyLimit);
        }
        this.connection.logger.logInfo({
            requestId,
            scope: MANAGER_NAME.BATCH_MANAGER,
            log: `Running a batch write request for ${batch.items.length} items`,
        });
        // 0. transform batch request
        const { batchWriteRequestMapItems, lazyTransactionWriteItemListLoaderItems, transactionListItems, metadata, } = this._dcBatchTransformer.toDynamoWriteBatchItems(batch, {
            requestId,
        });
        // 1.1. get transaction write items limits
        const transactionRequests = transactionListItems.map(({ rawInput, transformedInput }) => {
            // make all promises in pLimitable so their concurrency can be controlled properly
            return this.toLimited(() => this.connection.transactionManger.writeRaw(transformedInput, {
                requestId,
                returnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            }), 
            // return original item when failed to process
            rawInput, REQUEST_TYPE.TRANSACT_WRITE);
        });
        // 1.2. get all the lazy loaded promises
        // these are basically all the delete requests that uses unique keys
        const lazyTransactionRequests = lazyTransactionWriteItemListLoaderItems.map(({ rawInput, transformedInput }) => {
            return this.toLimited(async () => {
                const existingItem = await this.connection.entityManager.findOne(transformedInput.entityClass, transformedInput.primaryKeyAttributes, undefined, {
                    requestId,
                    returnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
                });
                const deleteTransactionItemList = transformedInput.lazyLoadTransactionWriteItems(existingItem);
                return this.connection.transactionManger.writeRaw(deleteTransactionItemList, {
                    requestId,
                    returnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
                });
            }, 
            // default item to return if failed to process
            rawInput, REQUEST_TYPE.TRANSACT_WRITE);
        });
        // 1.3. get all batch toLimited promises
        const batchRequests = batchWriteRequestMapItems.map(batchRequestMap => {
            return this.toLimited(async () => this.connection.documentClient.batchWrite({
                RequestItems: { ...batchRequestMap },
                ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            }), 
            // for batch requests this returning item will be transformed to
            // original input items later
            batchRequestMap, REQUEST_TYPE.BATCH_WRITE);
        });
        const allRequests = [
            ...transactionRequests,
            ...lazyTransactionRequests,
            ...batchRequests,
        ];
        // 2. wait for all promises to finish
        const responses = await Promise.all(allRequests);
        // log stats
        responses.forEach((response, index) => {
            if (response.ConsumedCapacity) {
                this.connection.logger.logStats({
                    scope: MANAGER_NAME.BATCH_MANAGER,
                    requestId,
                    requestSegment: index,
                    statsType: STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: response.ConsumedCapacity,
                });
            }
        });
        // 3. run retry attempts
        // process all unprocessed items recursively until all are either done
        // or reached the retry limit
        const unprocessedItems = await this.recursiveHandleBatchWriteItemsResponse(responses, 0, // initially set the attempts counter to 0,
        options, {
            requestId,
            returnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
        });
        // 4.1. reverse parse all failed inputs to original user inputs
        // filter or drop any empty values
        const transformedUnprocessedItems = unprocessedItems.flatMap((unprocessedItemInput) => this._dcBatchTransformer.toWriteBatchInputList(unprocessedItemInput, metadata));
        // 4.2. reverse parse all unprocessed inputs to original user inputs
        // parse failed items to original input
        const failedItemsOriginalInput = this._errorQueue.flatMap(item => {
            if (item.requestType === REQUEST_TYPE.BATCH_WRITE) {
                return this._dcBatchTransformer.toWriteBatchInputList(item.requestInput, metadata);
            }
            else if (item.requestType === REQUEST_TYPE.TRANSACT_WRITE) {
                return item.requestInput;
            }
            else {
                throw new Error('Unsupported request type, if this continues please file an issue on github');
            }
        });
        // 5. return unProcessable or failed items to user
        return {
            unprocessedItems: transformedUnprocessedItems,
            failedItems: failedItemsOriginalInput,
        };
    }
    /**
     * Reads all items given in batch with default eventually consistent read type
     * _Note_: Returned items are not guaranteed to be in the same sequence as requested
     */
    async read(batch, options, metadataOptions) {
        this.resetErrorQueue();
        const requestId = getUniqueRequestId(metadataOptions?.requestId);
        if (options?.requestsConcurrencyLimit) {
            this.limit = pLimit(options?.requestsConcurrencyLimit);
        }
        this.connection.logger.logInfo({
            requestId,
            scope: MANAGER_NAME.BATCH_MANAGER,
            log: `Running a batch read request for ${batch.items.length} items`,
        });
        // 0. transform batch request
        const { batchRequestItemsList, metadata } = this._dcBatchTransformer.toDynamoReadBatchItems(batch, {
            requestId,
        });
        // 1. get items requests with concurrency applied
        const batchRequests = batchRequestItemsList.map(batchRequestItems => {
            return this.toLimited(async () => this.connection.documentClient.batchGet({
                RequestItems: { ...batchRequestItems },
                ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            }), batchRequestItems, REQUEST_TYPE.BATCH_READ);
        });
        // 2. wait for all promises to finish, either failed or hit the limit
        const initialResponses = await Promise.all(batchRequests);
        // log stats
        initialResponses.forEach((response, index) => {
            if (response.ConsumedCapacity) {
                this.connection.logger.logStats({
                    scope: MANAGER_NAME.BATCH_MANAGER,
                    requestId,
                    requestSegment: index,
                    statsType: STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: response.ConsumedCapacity,
                });
            }
        });
        // 3. run retries
        const { items, unprocessedItemsList } = await this.recursiveHandleBatchReadItemsResponse(initialResponses, 0, options, [], {
            requestId,
            returnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
        });
        // 4.1 transform responses to look like model
        const transformedItems = items.map(item => {
            const entityPhysicalName = item[INTERNAL_ENTITY_ATTRIBUTE.ENTITY_NAME];
            if (!entityPhysicalName) {
                this.connection.logger.logWarn({
                    requestId,
                    scope: MANAGER_NAME.ENTITY_MANAGER,
                    log: `Item ${JSON.stringify(item)} is not known to TypeDORM there for transform was not run`,
                });
                return item;
            }
            const { target } = this.connection.getEntityByPhysicalName(entityPhysicalName);
            return this._dcBatchTransformer.fromDynamoEntity(target, item, {
                requestId,
            });
        });
        // 4.2 transform unprocessed items
        const unprocessedTransformedItems = unprocessedItemsList?.flatMap((item) => this._dcBatchTransformer.toReadBatchInputList(item, metadata));
        // 4.3 transform failed items
        const failedTransformedItems = this._errorQueue.flatMap(item => {
            this.connection.logger.logError({
                requestId,
                scope: MANAGER_NAME.BATCH_MANAGER,
                log: item.error,
            });
            return this._dcBatchTransformer.toReadBatchInputList(item.requestInput, metadata);
        });
        // 5. return all items
        return {
            items: transformedItems ?? [],
            unprocessedItems: unprocessedTransformedItems ?? [],
            failedItems: failedTransformedItems ?? [],
        };
    }
    /**
     * Recursively parse batch requests until either all items are in or has reached retry limit
     * @param batchWriteItemOutputItems
     */
    async recursiveHandleBatchWriteItemsResponse(batchWriteItemOutputItems, totalAttemptsSoFar, options, metadataOptions) {
        const unProcessedListItems = batchWriteItemOutputItems
            .filter((response) => response.UnprocessedItems && !isEmptyObject(response.UnprocessedItems))
            .map(item => item.UnprocessedItems);
        // if there are no unprocessed items, return
        if (!unProcessedListItems.length) {
            return unProcessedListItems;
        }
        // abort when reached max attempts count
        // if no retry attempts are given, use default attempts limit
        if (totalAttemptsSoFar ===
            (options?.maxRetryAttempts ?? BATCH_WRITE_MAX_ALLOWED_ATTEMPTS)) {
            this.connection.logger.logInfo({
                scope: MANAGER_NAME.BATCH_MANAGER,
                log: `Reached max allowed attempts ${totalAttemptsSoFar}, aborting...`,
                requestId: metadataOptions?.requestId,
            });
            return unProcessedListItems;
        }
        // backoff for x ms before retrying for unprocessed items
        await this.waitForExponentialBackoff(totalAttemptsSoFar, undefined, metadataOptions);
        // organize unprocessed items into single "tableName-item" map
        const sortedUnprocessedItems = unProcessedListItems.reduce((acc, unprocessedItems) => {
            Object.entries(unprocessedItems).forEach(([tableName, unprocessedRequests]) => {
                if (!acc[tableName]) {
                    acc[tableName] = [];
                }
                // merge all items by tableName
                acc[tableName] = [...acc[tableName], ...unprocessedRequests];
            });
            return acc;
        }, {});
        const batchRequestsItems = this._dcBatchTransformer.mapTableWriteItemsToBatchWriteItems(sortedUnprocessedItems);
        // apply limit on all parallel requests
        const batchRequests = batchRequestsItems.map(batchRequestMap => {
            return this.toLimited(async () => this.connection.documentClient.batchWrite({
                RequestItems: { ...batchRequestMap },
                ReturnItemCollectionMetrics: metadataOptions?.returnConsumedCapacity,
            }), batchRequestMap, REQUEST_TYPE.BATCH_WRITE);
        });
        const batchRequestsResponses = (await Promise.all(batchRequests));
        // log stats
        batchRequestsResponses.forEach((response, index) => {
            if (response.ConsumedCapacity) {
                this.connection.logger.logStats({
                    requestId: metadataOptions?.requestId,
                    scope: MANAGER_NAME.BATCH_MANAGER,
                    requestSegment: index,
                    statsType: STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: response.ConsumedCapacity,
                });
            }
        });
        return this.recursiveHandleBatchWriteItemsResponse(batchRequestsResponses, ++totalAttemptsSoFar, options, metadataOptions);
    }
    async recursiveHandleBatchReadItemsResponse(batchReadItemOutputList, totalAttemptsSoFar, options, responsesStore = [], metadataOptions) {
        // save all responses from api to responses store
        const batchReadResponses = batchReadItemOutputList
            .filter((response) => response.Responses && !isEmptyObject(response.Responses))
            .map((response) => response.Responses);
        if (batchReadResponses.length) {
            const mappedResponsesItemList = batchReadResponses.flatMap(batchGetResponse => this.mapBatchGetResponseToItemList(batchGetResponse));
            responsesStore.push(...mappedResponsesItemList);
        }
        // recursively process all unprocessed items
        const unprocessedItemsList = batchReadItemOutputList.filter((response) => response.UnprocessedKeys && !isEmptyObject(response.UnprocessedKeys));
        // if all items were successfully processed, return
        if (!unprocessedItemsList.length) {
            return {
                items: responsesStore,
            };
        }
        // abort when reached max attempt count
        // if no retries provided use default BATCH_READ_MAX_ALLOWED_ATTEMPTS
        if (totalAttemptsSoFar ===
            (options?.maxRetryAttempts ?? BATCH_READ_MAX_ALLOWED_ATTEMPTS)) {
            this.connection.logger.logInfo({
                requestId: metadataOptions?.requestId,
                scope: MANAGER_NAME.BATCH_MANAGER,
                log: `Reached max allowed attempts ${totalAttemptsSoFar}, aborting...`,
            });
            return {
                items: responsesStore,
                unprocessedItemsList: unprocessedItemsList.map(item => item.UnprocessedKeys),
            };
        }
        // backoff before retrying
        await this.waitForExponentialBackoff(totalAttemptsSoFar, undefined, metadataOptions);
        // aggregate all requests by table name
        const sortedUnprocessedItems = unprocessedItemsList.reduce((acc, { UnprocessedKeys }) => {
            Object.entries(UnprocessedKeys).forEach(([tableName, unprocessedRequests]) => {
                if (!acc[tableName]) {
                    acc[tableName] = {
                        Keys: [],
                    };
                }
                acc[tableName].Keys?.push(...unprocessedRequests.Keys);
            });
            return acc;
        }, {});
        const batchRequestsItemsList = this._dcBatchTransformer.mapTableReadItemsToBatchReadItems(sortedUnprocessedItems);
        // apply limit
        const batchRequests = batchRequestsItemsList.map(batchRequestMap => {
            return this.toLimited(async () => this.connection.documentClient.batchGet({
                RequestItems: { ...batchRequestMap },
                ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            }), batchRequestMap, REQUEST_TYPE.BATCH_READ);
        });
        const batchRequestsResponses = (await Promise.all(batchRequests));
        // log stats
        batchRequestsResponses.forEach((response, index) => {
            if (response.ConsumedCapacity) {
                this.connection.logger.logStats({
                    requestId: metadataOptions?.requestId,
                    scope: MANAGER_NAME.BATCH_MANAGER,
                    requestSegment: index,
                    statsType: STATS_TYPE.CONSUMED_CAPACITY,
                    consumedCapacityData: response.ConsumedCapacity,
                });
            }
        });
        return this.recursiveHandleBatchReadItemsResponse(batchRequestsResponses, ++totalAttemptsSoFar, options, 
        // responses store containing responses from all requests
        responsesStore, metadataOptions);
    }
    resetErrorQueue() {
        this._errorQueue = [];
    }
    mapBatchGetResponseToItemList(batchGetResponse) {
        return Object.entries(batchGetResponse).flatMap(([, batchResponse]) => batchResponse);
    }
    /**
     * Returns promise that is Promise.all safe and also can be managed by p-limit
     * @param anyPromiseFactory
     * @param requestItem // request item input
     * @param requestType // request type
     */
    toLimited(anyPromiseFactory, requestItem, requestType) {
        return this.limit(async () => {
            try {
                const response = await anyPromiseFactory();
                return response;
            }
            catch (err) {
                this._errorQueue.push({
                    requestInput: requestItem,
                    error: err,
                    requestType,
                });
                // when any error is thrown while promises are running, return it
                // instead of throwing it to have other requests run as is without
                // interruptions
                return err;
            }
        });
    }
    waitForExponentialBackoff(attempts, multiplicationFactor = 1, metadataOptions) {
        multiplicationFactor = multiplicationFactor < 1 ? 1 : multiplicationFactor;
        return new Promise(resolve => {
            const backoffTime = this.exponentialBackoff(attempts, multiplicationFactor);
            this.connection.logger.logInfo({
                requestId: metadataOptions?.requestId,
                scope: MANAGER_NAME.BATCH_MANAGER,
                log: `${attempts} attempts so far, sleeping ${backoffTime}ms before retrying...`,
            });
            setTimeout(resolve, backoffTime);
        });
    }
    /**
     * @param attempts
     */
    exponentialBackoff(attempts, multiplicationFactor) {
        return Math.floor(Math.random() * 10 * Math.pow(2, attempts || 1) * multiplicationFactor);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmF0Y2gtbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2NsYXNzZXMvbWFuYWdlci9iYXRjaC1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUdBLE9BQU8sRUFBQyw4QkFBOEIsRUFBQyxNQUFNLGtEQUFrRCxDQUFDO0FBQ2hHLE9BQU8sTUFBTSxNQUFNLFNBQVMsQ0FBQztBQUM3QixPQUFPLEVBQ0wsK0JBQStCLEVBQy9CLDZCQUE2QixFQUM3QixnQ0FBZ0MsRUFDaEMseUJBQXlCLEVBQ3pCLFlBQVksRUFDWixVQUFVLEdBQ1gsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sK0JBQStCLENBQUM7QUFHNUQsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0scUNBQXFDLENBQUM7QUFFdkUsTUFBTSxDQUFOLElBQVksWUFJWDtBQUpELFdBQVksWUFBWTtJQUN0QixpREFBaUMsQ0FBQTtJQUNqQywyQ0FBMkIsQ0FBQTtJQUMzQix5Q0FBeUIsQ0FBQTtBQUMzQixDQUFDLEVBSlcsWUFBWSxLQUFaLFlBQVksUUFJdkI7QUFnQ0QsTUFBTSxPQUFPLFlBQVk7SUFTSDtJQVJaLG1CQUFtQixDQUFpQztJQUNwRCxXQUFXLENBSWY7SUFDSSxLQUFLLEdBQUcsTUFBTSxDQUFDLDZCQUE2QixDQUFDLENBQUM7SUFFdEQsWUFBb0IsVUFBc0I7UUFBdEIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN4QyxJQUFJLENBQUMsbUJBQW1CLEdBQUcsSUFBSSw4QkFBOEIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMxRSxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxLQUFLLENBQUMsS0FBSyxDQUNULEtBQWlCLEVBQ2pCLE9BQWtDLEVBQ2xDLGVBQWlDO1FBRWpDLElBQUksQ0FB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dkUsQ0FBQztJQUNKLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RG9jdW1lbnRDbGllbnRUeXBlc30gZnJvbSAnQHR5cGVkb3JtL2RvY3VtZW50LWNsaWVudCc7XG5pbXBvcnQge1dyaXRlQmF0Y2h9IGZyb20gJy4uL2JhdGNoL3dyaXRlLWJhdGNoJztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbi9jb25uZWN0aW9uJztcbmltcG9ydCB7RG9jdW1lbnRDbGllbnRCYXRjaFRyYW5zZm9ybWVyfSBmcm9tICcuLi90cmFuc2Zvcm1lci9kb2N1bWVudC1jbGllbnQtYmF0Y2gtdHJhbnNmb3JtZXInO1xuaW1wb3J0IHBMaW1pdCBmcm9tICdwLWxpbWl0JztcbmltcG9ydCB7XG4gIEJBVENIX1JFQURfTUFYX0FMTE9XRURfQVRURU1QVFMsXG4gIEJBVENIX1dSSVRFX0NPTkNVUlJFTkNZX0xJTUlULFxuICBCQVRDSF9XUklURV9NQVhfQUxMT1dFRF9BVFRFTVBUUyxcbiAgSU5URVJOQUxfRU5USVRZX0FUVFJJQlVURSxcbiAgTUFOQUdFUl9OQU1FLFxuICBTVEFUU19UWVBFLFxufSBmcm9tICdAdHlwZWRvcm0vY29tbW9uJztcbmltcG9ydCB7aXNFbXB0eU9iamVjdH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1lbXB0eS1vYmplY3QnO1xuaW1wb3J0IHtSZWFkQmF0Y2h9IGZyb20gJy4uL2JhdGNoL3JlYWQtYmF0Y2gnO1xuaW1wb3J0IHtNZXRhZGF0YU9wdGlvbnN9IGZyb20gJy4uL3RyYW5zZm9ybWVyL2Jhc2UtdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtnZXRVbmlxdWVSZXF1ZXN0SWR9IGZyb20gJy4uLy4uL2hlbHBlcnMvZ2V0LXVuaXF1ZS1yZXF1ZXN0LWlkJztcblxuZXhwb3J0IGVudW0gUkVRVUVTVF9UWVBFIHtcbiAgVFJBTlNBQ1RfV1JJVEUgPSAnVFJBTlNBQ1RfV1JJVEUnLFxuICBCQVRDSF9XUklURSA9ICdCQVRDSF9XUklURScsXG4gIEJBVENIX1JFQUQgPSAnQkFUQ0hfUkVBRCcsXG59XG5cbi8qKlxuICogQmF0Y2ggbWFuYWdlciB3cml0ZSBvcHRpb25zXG4gKi9cbmV4cG9ydCB0eXBlIEJhdGNoTWFuYWdlcldyaXRlT3B0aW9ucyA9IEJhdGNoTWFuYWdlQmFzZU9wdGlvbnM7XG5cbi8qKlxuICogQmF0Y2ggbWFuYWdlciByZWFkIG9wdGlvbnNcbiAqL1xuZXhwb3J0IHR5cGUgQmF0Y2hNYW5hZ2VyUmVhZE9wdGlvbnMgPSBCYXRjaE1hbmFnZUJhc2VPcHRpb25zO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJhdGNoTWFuYWdlQmFzZU9wdGlvbnMge1xuICAvKipcbiAgICogTWF4IG51bWJlciBvZiByZXRyaWVzIHRvIHBlcmZvcm0gYmVmb3JlIHJldHVybmluZyB0byBjbGllbnRcbiAgICogQGRlZmF1bHQgQkFUQ0hfV1JJVEVfTUFYX0FMTE9XRURfQVRURU1QVFNcbiAgICovXG4gIG1heFJldHJ5QXR0ZW1wdHM/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgcmVxdWVzdHMgdG8gcnVuIGluIHBhcmFsbGVsXG4gICAqIEBkZWZhdWx0IEJBVENIX1dSSVRFX0NPTkNVUlJFTkNZX0xJTUlUXG4gICAqL1xuICByZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEV4cG9uZW50aWFsIGJhY2tvZmYgbXVsdGlwbGljYXRpb24gZmFjdG9yIHRvIGFwcGx5IG9uIGJhY2sgb2ZmIGFsZ29yaXRobVxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBiYWNrb2ZmTXVsdGlwbGljYXRpb25GYWN0b3I/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBCYXRjaE1hbmFnZXIge1xuICBwcml2YXRlIF9kY0JhdGNoVHJhbnNmb3JtZXI6IERvY3VtZW50Q2xpZW50QmF0Y2hUcmFuc2Zvcm1lcjtcbiAgcHJpdmF0ZSBfZXJyb3JRdWV1ZToge1xuICAgIHJlcXVlc3RJbnB1dDogYW55O1xuICAgIGVycm9yOiBFcnJvcjtcbiAgICByZXF1ZXN0VHlwZTogUkVRVUVTVF9UWVBFO1xuICB9W107XG4gIHByaXZhdGUgbGltaXQgPSBwTGltaXQoQkFUQ0hfV1JJVEVfQ09OQ1VSUkVOQ1lfTElNSVQpO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29ubmVjdGlvbjogQ29ubmVjdGlvbikge1xuICAgIHRoaXMuX2RjQmF0Y2hUcmFuc2Zvcm1lciA9IG5ldyBEb2N1bWVudENsaWVudEJhdGNoVHJhbnNmb3JtZXIoY29ubmVjdGlvbik7XG4gICAgdGhpcy5yZXNldEVycm9yUXVldWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZXMgYWxsIGdpdmVuIGl0ZW1zIHRvIGR5bmFtb2RiIHVzaW5nIGVpdGhlciBiYXRjaCBvciB0cmFuc2FjdGlvbiBhcGkuXG4gICAqIF9Ob3RlXzogVHJhbnNhY3Rpb24gYXBpIGlzIGFsd2F5cyB1c2VkIHdoZW4gaXRlbSBiZWluZyB3cml0dGVuIGlzIHVzaW5nIGEgdW5pcXVlIGF0dHJpYnV0ZVxuICAgKiBAcGFyYW0gYmF0Y2hcbiAgICovXG4gIGFzeW5jIHdyaXRlKFxuICAgIGJhdGNoOiBXcml0ZUJhdGNoLFxuICAgIG9wdGlvbnM/OiBCYXRjaE1hbmFnZXJXcml0ZU9wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICkge1xuICAgIHRoaXMucmVzZXRFcnJvclF1ZXVlKCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gZ2V0VW5pcXVlUmVxdWVzdElkKG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkKTtcblxuICAgIGlmIChvcHRpb25zPy5yZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXQpIHtcbiAgICAgIHRoaXMubGltaXQgPSBwTGltaXQob3B0aW9ucz8ucmVxdWVzdHNDb25jdXJyZW5jeUxpbWl0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ0luZm8oe1xuICAgICAgcmVxdWVzdElkLFxuICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgbG9nOiBgUnVubmluZyBhIGJhdGNoIHdyaXRlIHJlcXVlc3QgZm9yICR7YmF0Y2guaXRlbXMubGVuZ3RofSBpdGVtc2AsXG4gICAgfSk7XG5cbiAgICAvLyAwLiB0cmFuc2Zvcm0gYmF0Y2ggcmVxdWVzdFxuICAgIGNvbnN0IHtcbiAgICAgIGJhdGNoV3JpdGVSZXF1ZXN0TWFwSXRlbXMsXG4gICAgICBsYXp5VHJhbnNhY3Rpb25Xcml0ZUl0ZW1MaXN0TG9hZGVySXRlbXMsXG4gICAgICB0cmFuc2FjdGlvbkxpc3RJdGVtcyxcbiAgICAgIG1ldGFkYXRhLFxuICAgIH0gPSB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9EeW5hbW9Xcml0ZUJhdGNoSXRlbXMoYmF0Y2gsIHtcbiAgICAgIHJlcXVlc3RJZCxcbiAgICB9KTtcblxuICAgIC8vIDEuMS4gZ2V0IHRyYW5zYWN0aW9uIHdyaXRlIGl0ZW1zIGxpbWl0c1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVxdWVzdHMgPSB0cmFuc2FjdGlvbkxpc3RJdGVtcy5tYXAoXG4gICAgICAoe3Jhd0lucHV0LCB0cmFuc2Zvcm1lZElucHV0fSkgPT4ge1xuICAgICAgICAvLyBtYWtlIGFsbCBwcm9taXNlcyBpbiBwTGltaXRhYmxlIHNvIHRoZWlyIGNvbmN1cnJlbmN5IGNhbiBiZSBjb250cm9sbGVkIHByb3Blcmx5XG4gICAgICAgIHJldHVybiB0aGlzLnRvTGltaXRlZChcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLnRyYW5zYWN0aW9uTWFuZ2VyLndyaXRlUmF3KHRyYW5zZm9ybWVkSW5wdXQsIHtcbiAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICByZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAvLyByZXR1cm4gb3JpZ2luYWwgaXRlbSB3aGVuIGZhaWxlZCB0byBwcm9jZXNzXG4gICAgICAgICAgcmF3SW5wdXQsXG4gICAgICAgICAgUkVRVUVTVF9UWVBFLlRSQU5TQUNUX1dSSVRFXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIDEuMi4gZ2V0IGFsbCB0aGUgbGF6eSBsb2FkZWQgcHJvbWlzZXNcbiAgICAvLyB0aGVzZSBhcmUgYmFzaWNhbGx5IGFsbCB0aGUgZGVsZXRlIHJlcXVlc3RzIHRoYXQgdXNlcyB1bmlxdWUga2V5c1xuICAgIGNvbnN0IGxhenlUcmFuc2FjdGlvblJlcXVlc3RzID0gbGF6eVRyYW5zYWN0aW9uV3JpdGVJdGVtTGlzdExvYWRlckl0ZW1zLm1hcChcbiAgICAgICh7cmF3SW5wdXQsIHRyYW5zZm9ybWVkSW5wdXR9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvTGltaXRlZChcbiAgICAgICAgICBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0l0ZW0gPSBhd2FpdCB0aGlzLmNvbm5lY3Rpb24uZW50aXR5TWFuYWdlci5maW5kT25lKFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1lZElucHV0LmVudGl0eUNsYXNzLFxuICAgICAgICAgICAgICB0cmFuc2Zvcm1lZElucHV0LnByaW1hcnlLZXlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgcmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBjb25zdCBkZWxldGVUcmFuc2FjdGlvbkl0ZW1MaXN0ID1cbiAgICAgICAgICAgICAgdHJhbnNmb3JtZWRJbnB1dC5sYXp5TG9hZFRyYW5zYWN0aW9uV3JpdGVJdGVtcyhleGlzdGluZ0l0ZW0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnRyYW5zYWN0aW9uTWFuZ2VyLndyaXRlUmF3KFxuICAgICAgICAgICAgICBkZWxldGVUcmFuc2FjdGlvbkl0ZW1MaXN0LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgICAgICAgIHJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgLy8gZGVmYXVsdCBpdGVtIHRvIHJldHVybiBpZiBmYWlsZWQgdG8gcHJvY2Vzc1xuICAgICAgICAgIHJhd0lucHV0LFxuICAgICAgICAgIFJFUVVFU1RfVFlQRS5UUkFOU0FDVF9XUklURVxuICAgICAgICApO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyAxLjMuIGdldCBhbGwgYmF0Y2ggdG9MaW1pdGVkIHByb21pc2VzXG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0cyA9IGJhdGNoV3JpdGVSZXF1ZXN0TWFwSXRlbXMubWFwKGJhdGNoUmVxdWVzdE1hcCA9PiB7XG4gICAgICByZXR1cm4gdGhpcy50b0xpbWl0ZWQoXG4gICAgICAgIGFzeW5jICgpID0+XG4gICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmRvY3VtZW50Q2xpZW50LmJhdGNoV3JpdGUoe1xuICAgICAgICAgICAgUmVxdWVzdEl0ZW1zOiB7Li4uYmF0Y2hSZXF1ZXN0TWFwfSxcbiAgICAgICAgICAgIFJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgLy8gZm9yIGJhdGNoIHJlcXVlc3RzIHRoaXMgcmV0dXJuaW5nIGl0ZW0gd2lsbCBiZSB0cmFuc2Zvcm1lZCB0b1xuICAgICAgICAvLyBvcmlnaW5hbCBpbnB1dCBpdGVtcyBsYXRlclxuICAgICAgICBiYXRjaFJlcXVlc3RNYXAsXG4gICAgICAgIFJFUVVFU1RfVFlQRS5CQVRDSF9XUklURVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFsbFJlcXVlc3RzID0gW1xuICAgICAgLi4udHJhbnNhY3Rpb25SZXF1ZXN0cyxcbiAgICAgIC4uLmxhenlUcmFuc2FjdGlvblJlcXVlc3RzLFxuICAgICAgLi4uYmF0Y2hSZXF1ZXN0cyxcbiAgICBdIGFzXG4gICAgICB8IFByb21pc2U8RG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbU91dHB1dD5bXVxuICAgICAgfCBQcm9taXNlPERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hXcml0ZUl0ZW1PdXRwdXQ+W107XG5cbiAgICAvLyAyLiB3YWl0IGZvciBhbGwgcHJvbWlzZXMgdG8gZmluaXNoXG4gICAgY29uc3QgcmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxsUmVxdWVzdHMpO1xuXG4gICAgLy8gbG9nIHN0YXRzXG4gICAgcmVzcG9uc2VzLmZvckVhY2goKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLkNvbnN1bWVkQ2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dTdGF0cyh7XG4gICAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICByZXF1ZXN0U2VnbWVudDogaW5kZXgsXG4gICAgICAgICAgc3RhdHNUeXBlOiBTVEFUU19UWVBFLkNPTlNVTUVEX0NBUEFDSVRZLFxuICAgICAgICAgIGNvbnN1bWVkQ2FwYWNpdHlEYXRhOiByZXNwb25zZS5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDMuIHJ1biByZXRyeSBhdHRlbXB0c1xuICAgIC8vIHByb2Nlc3MgYWxsIHVucHJvY2Vzc2VkIGl0ZW1zIHJlY3Vyc2l2ZWx5IHVudGlsIGFsbCBhcmUgZWl0aGVyIGRvbmVcbiAgICAvLyBvciByZWFjaGVkIHRoZSByZXRyeSBsaW1pdFxuICAgIGNvbnN0IHVucHJvY2Vzc2VkSXRlbXMgPSBhd2FpdCB0aGlzLnJlY3Vyc2l2ZUhhbmRsZUJhdGNoV3JpdGVJdGVtc1Jlc3BvbnNlKFxuICAgICAgcmVzcG9uc2VzLFxuICAgICAgMCwgLy8gaW5pdGlhbGx5IHNldCB0aGUgYXR0ZW1wdHMgY291bnRlciB0byAwLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHtcbiAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICByZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIDQuMS4gcmV2ZXJzZSBwYXJzZSBhbGwgZmFpbGVkIGlucHV0cyB0byBvcmlnaW5hbCB1c2VyIGlucHV0c1xuICAgIC8vIGZpbHRlciBvciBkcm9wIGFueSBlbXB0eSB2YWx1ZXNcbiAgICBjb25zdCB0cmFuc2Zvcm1lZFVucHJvY2Vzc2VkSXRlbXMgPSB1bnByb2Nlc3NlZEl0ZW1zLmZsYXRNYXAoXG4gICAgICAodW5wcm9jZXNzZWRJdGVtSW5wdXQ6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hXcml0ZUl0ZW1SZXF1ZXN0TWFwKSA9PlxuICAgICAgICB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9Xcml0ZUJhdGNoSW5wdXRMaXN0KFxuICAgICAgICAgIHVucHJvY2Vzc2VkSXRlbUlucHV0LFxuICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgIClcbiAgICApO1xuXG4gICAgLy8gNC4yLiByZXZlcnNlIHBhcnNlIGFsbCB1bnByb2Nlc3NlZCBpbnB1dHMgdG8gb3JpZ2luYWwgdXNlciBpbnB1dHNcbiAgICAvLyBwYXJzZSBmYWlsZWQgaXRlbXMgdG8gb3JpZ2luYWwgaW5wdXRcbiAgICBjb25zdCBmYWlsZWRJdGVtc09yaWdpbmFsSW5wdXQgPSB0aGlzLl9lcnJvclF1ZXVlLmZsYXRNYXAoaXRlbSA9PiB7XG4gICAgICBpZiAoaXRlbS5yZXF1ZXN0VHlwZSA9PT0gUkVRVUVTVF9UWVBFLkJBVENIX1dSSVRFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9Xcml0ZUJhdGNoSW5wdXRMaXN0KFxuICAgICAgICAgIGl0ZW0ucmVxdWVzdElucHV0LFxuICAgICAgICAgIG1ldGFkYXRhXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW0ucmVxdWVzdFR5cGUgPT09IFJFUVVFU1RfVFlQRS5UUkFOU0FDVF9XUklURSkge1xuICAgICAgICByZXR1cm4gaXRlbS5yZXF1ZXN0SW5wdXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1Vuc3VwcG9ydGVkIHJlcXVlc3QgdHlwZSwgaWYgdGhpcyBjb250aW51ZXMgcGxlYXNlIGZpbGUgYW4gaXNzdWUgb24gZ2l0aHViJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gNS4gcmV0dXJuIHVuUHJvY2Vzc2FibGUgb3IgZmFpbGVkIGl0ZW1zIHRvIHVzZXJcbiAgICByZXR1cm4ge1xuICAgICAgdW5wcm9jZXNzZWRJdGVtczogdHJhbnNmb3JtZWRVbnByb2Nlc3NlZEl0ZW1zLFxuICAgICAgZmFpbGVkSXRlbXM6IGZhaWxlZEl0ZW1zT3JpZ2luYWxJbnB1dCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBpdGVtcyBnaXZlbiBpbiBiYXRjaCB3aXRoIGRlZmF1bHQgZXZlbnR1YWxseSBjb25zaXN0ZW50IHJlYWQgdHlwZVxuICAgKiBfTm90ZV86IFJldHVybmVkIGl0ZW1zIGFyZSBub3QgZ3VhcmFudGVlZCB0byBiZSBpbiB0aGUgc2FtZSBzZXF1ZW5jZSBhcyByZXF1ZXN0ZWRcbiAgICovXG4gIGFzeW5jIHJlYWQoXG4gICAgYmF0Y2g6IFJlYWRCYXRjaCxcbiAgICBvcHRpb25zPzogQmF0Y2hNYW5hZ2VyUmVhZE9wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICkge1xuICAgIHRoaXMucmVzZXRFcnJvclF1ZXVlKCk7XG4gICAgY29uc3QgcmVxdWVzdElkID0gZ2V0VW5pcXVlUmVxdWVzdElkKG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkKTtcblxuICAgIGlmIChvcHRpb25zPy5yZXF1ZXN0c0NvbmN1cnJlbmN5TGltaXQpIHtcbiAgICAgIHRoaXMubGltaXQgPSBwTGltaXQob3B0aW9ucz8ucmVxdWVzdHNDb25jdXJyZW5jeUxpbWl0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ0luZm8oe1xuICAgICAgcmVxdWVzdElkLFxuICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgbG9nOiBgUnVubmluZyBhIGJhdGNoIHJlYWQgcmVxdWVzdCBmb3IgJHtiYXRjaC5pdGVtcy5sZW5ndGh9IGl0ZW1zYCxcbiAgICB9KTtcblxuICAgIC8vIDAuIHRyYW5zZm9ybSBiYXRjaCByZXF1ZXN0XG4gICAgY29uc3Qge2JhdGNoUmVxdWVzdEl0ZW1zTGlzdCwgbWV0YWRhdGF9ID1cbiAgICAgIHRoaXMuX2RjQmF0Y2hUcmFuc2Zvcm1lci50b0R5bmFtb1JlYWRCYXRjaEl0ZW1zKGJhdGNoLCB7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgIH0pO1xuXG4gICAgLy8gMS4gZ2V0IGl0ZW1zIHJlcXVlc3RzIHdpdGggY29uY3VycmVuY3kgYXBwbGllZFxuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHMgPSBiYXRjaFJlcXVlc3RJdGVtc0xpc3QubWFwKGJhdGNoUmVxdWVzdEl0ZW1zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnRvTGltaXRlZChcbiAgICAgICAgYXN5bmMgKCkgPT5cbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZG9jdW1lbnRDbGllbnQuYmF0Y2hHZXQoe1xuICAgICAgICAgICAgUmVxdWVzdEl0ZW1zOiB7Li4uYmF0Y2hSZXF1ZXN0SXRlbXN9LFxuICAgICAgICAgICAgUmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICAgIH0pLFxuICAgICAgICBiYXRjaFJlcXVlc3RJdGVtcyxcbiAgICAgICAgUkVRVUVTVF9UWVBFLkJBVENIX1JFQURcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICAvLyAyLiB3YWl0IGZvciBhbGwgcHJvbWlzZXMgdG8gZmluaXNoLCBlaXRoZXIgZmFpbGVkIG9yIGhpdCB0aGUgbGltaXRcbiAgICBjb25zdCBpbml0aWFsUmVzcG9uc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoYmF0Y2hSZXF1ZXN0cyk7XG5cbiAgICAvLyBsb2cgc3RhdHNcbiAgICBpbml0aWFsUmVzcG9uc2VzLmZvckVhY2goKHJlc3BvbnNlLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLkNvbnN1bWVkQ2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dTdGF0cyh7XG4gICAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICByZXF1ZXN0U2VnbWVudDogaW5kZXgsXG4gICAgICAgICAgc3RhdHNUeXBlOiBTVEFUU19UWVBFLkNPTlNVTUVEX0NBUEFDSVRZLFxuICAgICAgICAgIGNvbnN1bWVkQ2FwYWNpdHlEYXRhOiByZXNwb25zZS5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIDMuIHJ1biByZXRyaWVzXG4gICAgY29uc3Qge2l0ZW1zLCB1bnByb2Nlc3NlZEl0ZW1zTGlzdH0gPVxuICAgICAgYXdhaXQgdGhpcy5yZWN1cnNpdmVIYW5kbGVCYXRjaFJlYWRJdGVtc1Jlc3BvbnNlKFxuICAgICAgICBpbml0aWFsUmVzcG9uc2VzLFxuICAgICAgICAwLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBbXSxcbiAgICAgICAge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICByZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgIH1cbiAgICAgICk7XG5cbiAgICAvLyA0LjEgdHJhbnNmb3JtIHJlc3BvbnNlcyB0byBsb29rIGxpa2UgbW9kZWxcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEl0ZW1zID0gaXRlbXMubWFwKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgZW50aXR5UGh5c2ljYWxOYW1lID0gaXRlbVtJTlRFUk5BTF9FTlRJVFlfQVRUUklCVVRFLkVOVElUWV9OQU1FXTtcbiAgICAgIGlmICghZW50aXR5UGh5c2ljYWxOYW1lKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nV2Fybih7XG4gICAgICAgICAgcmVxdWVzdElkLFxuICAgICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuRU5USVRZX01BTkFHRVIsXG4gICAgICAgICAgbG9nOiBgSXRlbSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgaXRlbVxuICAgICAgICAgICl9IGlzIG5vdCBrbm93biB0byBUeXBlRE9STSB0aGVyZSBmb3IgdHJhbnNmb3JtIHdhcyBub3QgcnVuYCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7dGFyZ2V0fSA9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVBoeXNpY2FsTmFtZShlbnRpdHlQaHlzaWNhbE5hbWUpO1xuICAgICAgcmV0dXJuIHRoaXMuX2RjQmF0Y2hUcmFuc2Zvcm1lci5mcm9tRHluYW1vRW50aXR5KHRhcmdldCwgaXRlbSwge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICB9KTtcbiAgICB9KSBhcyB1bmtub3duW107XG5cbiAgICAvLyA0LjIgdHJhbnNmb3JtIHVucHJvY2Vzc2VkIGl0ZW1zXG4gICAgY29uc3QgdW5wcm9jZXNzZWRUcmFuc2Zvcm1lZEl0ZW1zID0gdW5wcm9jZXNzZWRJdGVtc0xpc3Q/LmZsYXRNYXAoXG4gICAgICAoaXRlbTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldFJlcXVlc3RNYXApID0+XG4gICAgICAgIHRoaXMuX2RjQmF0Y2hUcmFuc2Zvcm1lci50b1JlYWRCYXRjaElucHV0TGlzdChpdGVtLCBtZXRhZGF0YSlcbiAgICApO1xuXG4gICAgLy8gNC4zIHRyYW5zZm9ybSBmYWlsZWQgaXRlbXNcbiAgICBjb25zdCBmYWlsZWRUcmFuc2Zvcm1lZEl0ZW1zID0gdGhpcy5fZXJyb3JRdWV1ZS5mbGF0TWFwKGl0ZW0gPT4ge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dFcnJvcih7XG4gICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICBsb2c6IGl0ZW0uZXJyb3IsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIudG9SZWFkQmF0Y2hJbnB1dExpc3QoXG4gICAgICAgIGl0ZW0ucmVxdWVzdElucHV0LFxuICAgICAgICBtZXRhZGF0YVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIC8vIDUuIHJldHVybiBhbGwgaXRlbXNcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbXM6IHRyYW5zZm9ybWVkSXRlbXMgPz8gW10sXG4gICAgICB1bnByb2Nlc3NlZEl0ZW1zOiB1bnByb2Nlc3NlZFRyYW5zZm9ybWVkSXRlbXMgPz8gW10sXG4gICAgICBmYWlsZWRJdGVtczogZmFpbGVkVHJhbnNmb3JtZWRJdGVtcyA/PyBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHBhcnNlIGJhdGNoIHJlcXVlc3RzIHVudGlsIGVpdGhlciBhbGwgaXRlbXMgYXJlIGluIG9yIGhhcyByZWFjaGVkIHJldHJ5IGxpbWl0XG4gICAqIEBwYXJhbSBiYXRjaFdyaXRlSXRlbU91dHB1dEl0ZW1zXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHJlY3Vyc2l2ZUhhbmRsZUJhdGNoV3JpdGVJdGVtc1Jlc3BvbnNlKFxuICAgIGJhdGNoV3JpdGVJdGVtT3V0cHV0SXRlbXM6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hXcml0ZUl0ZW1PdXRwdXRMaXN0LFxuICAgIHRvdGFsQXR0ZW1wdHNTb0ZhcjogbnVtYmVyLFxuICAgIG9wdGlvbnM/OiBCYXRjaE1hbmFnZXJXcml0ZU9wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6IFByb21pc2U8RG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaFdyaXRlSXRlbVJlcXVlc3RNYXBMaXN0PiB7XG4gICAgY29uc3QgdW5Qcm9jZXNzZWRMaXN0SXRlbXMgPSBiYXRjaFdyaXRlSXRlbU91dHB1dEl0ZW1zXG4gICAgICAuZmlsdGVyKFxuICAgICAgICAocmVzcG9uc2U6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hXcml0ZUl0ZW1PdXRwdXQpID0+XG4gICAgICAgICAgcmVzcG9uc2UuVW5wcm9jZXNzZWRJdGVtcyAmJiAhaXNFbXB0eU9iamVjdChyZXNwb25zZS5VbnByb2Nlc3NlZEl0ZW1zKVxuICAgICAgKVxuICAgICAgLm1hcChpdGVtID0+IGl0ZW0uVW5wcm9jZXNzZWRJdGVtcyEpO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHVucHJvY2Vzc2VkIGl0ZW1zLCByZXR1cm5cbiAgICBpZiAoIXVuUHJvY2Vzc2VkTGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuUHJvY2Vzc2VkTGlzdEl0ZW1zO1xuICAgIH1cblxuICAgIC8vIGFib3J0IHdoZW4gcmVhY2hlZCBtYXggYXR0ZW1wdHMgY291bnRcbiAgICAvLyBpZiBubyByZXRyeSBhdHRlbXB0cyBhcmUgZ2l2ZW4sIHVzZSBkZWZhdWx0IGF0dGVtcHRzIGxpbWl0XG4gICAgaWYgKFxuICAgICAgdG90YWxBdHRlbXB0c1NvRmFyID09PVxuICAgICAgKG9wdGlvbnM/Lm1heFJldHJ5QXR0ZW1wdHMgPz8gQkFUQ0hfV1JJVEVfTUFYX0FMTE9XRURfQVRURU1QVFMpXG4gICAgKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ0luZm8oe1xuICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLkJBVENIX01BTkFHRVIsXG4gICAgICAgIGxvZzogYFJlYWNoZWQgbWF4IGFsbG93ZWQgYXR0ZW1wdHMgJHt0b3RhbEF0dGVtcHRzU29GYXJ9LCBhYm9ydGluZy4uLmAsXG4gICAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB1blByb2Nlc3NlZExpc3RJdGVtcztcbiAgICB9XG5cbiAgICAvLyBiYWNrb2ZmIGZvciB4IG1zIGJlZm9yZSByZXRyeWluZyBmb3IgdW5wcm9jZXNzZWQgaXRlbXNcbiAgICBhd2FpdCB0aGlzLndhaXRGb3JFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICB0b3RhbEF0dGVtcHRzU29GYXIsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICBtZXRhZGF0YU9wdGlvbnNcbiAgICApO1xuXG4gICAgLy8gb3JnYW5pemUgdW5wcm9jZXNzZWQgaXRlbXMgaW50byBzaW5nbGUgXCJ0YWJsZU5hbWUtaXRlbVwiIG1hcFxuICAgIGNvbnN0IHNvcnRlZFVucHJvY2Vzc2VkSXRlbXMgPSB1blByb2Nlc3NlZExpc3RJdGVtcy5yZWR1Y2UoXG4gICAgICAoYWNjLCB1bnByb2Nlc3NlZEl0ZW1zKSA9PiB7XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHVucHJvY2Vzc2VkSXRlbXMhKS5mb3JFYWNoKFxuICAgICAgICAgIChbdGFibGVOYW1lLCB1bnByb2Nlc3NlZFJlcXVlc3RzXSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFhY2NbdGFibGVOYW1lXSkge1xuICAgICAgICAgICAgICBhY2NbdGFibGVOYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbWVyZ2UgYWxsIGl0ZW1zIGJ5IHRhYmxlTmFtZVxuICAgICAgICAgICAgYWNjW3RhYmxlTmFtZV0gPSBbLi4uYWNjW3RhYmxlTmFtZV0sIC4uLnVucHJvY2Vzc2VkUmVxdWVzdHNdO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtUmVxdWVzdE1hcFxuICAgICk7XG5cbiAgICBjb25zdCBiYXRjaFJlcXVlc3RzSXRlbXMgPVxuICAgICAgdGhpcy5fZGNCYXRjaFRyYW5zZm9ybWVyLm1hcFRhYmxlV3JpdGVJdGVtc1RvQmF0Y2hXcml0ZUl0ZW1zKFxuICAgICAgICBzb3J0ZWRVbnByb2Nlc3NlZEl0ZW1zXG4gICAgICApO1xuXG4gICAgLy8gYXBwbHkgbGltaXQgb24gYWxsIHBhcmFsbGVsIHJlcXVlc3RzXG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0cyA9IGJhdGNoUmVxdWVzdHNJdGVtcy5tYXAoYmF0Y2hSZXF1ZXN0TWFwID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnRvTGltaXRlZChcbiAgICAgICAgYXN5bmMgKCkgPT5cbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZG9jdW1lbnRDbGllbnQuYmF0Y2hXcml0ZSh7XG4gICAgICAgICAgICBSZXF1ZXN0SXRlbXM6IHsuLi5iYXRjaFJlcXVlc3RNYXB9LFxuICAgICAgICAgICAgUmV0dXJuSXRlbUNvbGxlY3Rpb25NZXRyaWNzOlxuICAgICAgICAgICAgICBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgfSksXG4gICAgICAgIGJhdGNoUmVxdWVzdE1hcCxcbiAgICAgICAgUkVRVUVTVF9UWVBFLkJBVENIX1dSSVRFXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0c1Jlc3BvbnNlcyA9IChhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGJhdGNoUmVxdWVzdHNcbiAgICApKSBhcyBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoV3JpdGVJdGVtT3V0cHV0TGlzdDtcblxuICAgIC8vIGxvZyBzdGF0c1xuICAgIGJhdGNoUmVxdWVzdHNSZXNwb25zZXMuZm9yRWFjaCgocmVzcG9uc2UsIGluZGV4KSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2UuQ29uc3VtZWRDYXBhY2l0eSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1N0YXRzKHtcbiAgICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICAgIHNjb3BlOiBNQU5BR0VSX05BTUUuQkFUQ0hfTUFOQUdFUixcbiAgICAgICAgICByZXF1ZXN0U2VnbWVudDogaW5kZXgsXG4gICAgICAgICAgc3RhdHNUeXBlOiBTVEFUU19UWVBFLkNPTlNVTUVEX0NBUEFDSVRZLFxuICAgICAgICAgIGNvbnN1bWVkQ2FwYWNpdHlEYXRhOiByZXNwb25zZS5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzLnJlY3Vyc2l2ZUhhbmRsZUJhdGNoV3JpdGVJdGVtc1Jlc3BvbnNlKFxuICAgICAgYmF0Y2hSZXF1ZXN0c1Jlc3BvbnNlcyxcbiAgICAgICsrdG90YWxBdHRlbXB0c1NvRmFyLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG1ldGFkYXRhT3B0aW9uc1xuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlY3Vyc2l2ZUhhbmRsZUJhdGNoUmVhZEl0ZW1zUmVzcG9uc2UoXG4gICAgYmF0Y2hSZWFkSXRlbU91dHB1dExpc3Q6IERvY3VtZW50Q2xpZW50VHlwZXMuQmF0Y2hHZXRJdGVtT3V0cHV0TGlzdCxcbiAgICB0b3RhbEF0dGVtcHRzU29GYXI6IG51bWJlcixcbiAgICBvcHRpb25zPzogQmF0Y2hNYW5hZ2VyUmVhZE9wdGlvbnMsXG4gICAgcmVzcG9uc2VzU3RvcmU6IERvY3VtZW50Q2xpZW50VHlwZXMuSXRlbUxpc3QgPSBbXSxcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKTogUHJvbWlzZTx7XG4gICAgaXRlbXM6IERvY3VtZW50Q2xpZW50VHlwZXMuSXRlbUxpc3Q7XG4gICAgdW5wcm9jZXNzZWRJdGVtc0xpc3Q/OiBEb2N1bWVudENsaWVudFR5cGVzLkJhdGNoR2V0UmVxdWVzdE1hcExpc3Q7XG4gIH0+IHtcbiAgICAvLyBzYXZlIGFsbCByZXNwb25zZXMgZnJvbSBhcGkgdG8gcmVzcG9uc2VzIHN0b3JlXG4gICAgY29uc3QgYmF0Y2hSZWFkUmVzcG9uc2VzID0gYmF0Y2hSZWFkSXRlbU91dHB1dExpc3RcbiAgICAgIC5maWx0ZXIoXG4gICAgICAgIChyZXNwb25zZTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldEl0ZW1PdXRwdXQpID0+XG4gICAgICAgICAgcmVzcG9uc2UuUmVzcG9uc2VzICYmICFpc0VtcHR5T2JqZWN0KHJlc3BvbnNlLlJlc3BvbnNlcylcbiAgICAgIClcbiAgICAgIC5tYXAoXG4gICAgICAgIChyZXNwb25zZTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldEl0ZW1PdXRwdXQpID0+XG4gICAgICAgICAgcmVzcG9uc2UuUmVzcG9uc2VzIVxuICAgICAgKTtcbiAgICBpZiAoYmF0Y2hSZWFkUmVzcG9uc2VzLmxlbmd0aCkge1xuICAgICAgY29uc3QgbWFwcGVkUmVzcG9uc2VzSXRlbUxpc3QgPSBiYXRjaFJlYWRSZXNwb25zZXMuZmxhdE1hcChcbiAgICAgICAgYmF0Y2hHZXRSZXNwb25zZSA9PiB0aGlzLm1hcEJhdGNoR2V0UmVzcG9uc2VUb0l0ZW1MaXN0KGJhdGNoR2V0UmVzcG9uc2UpXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VzU3RvcmUucHVzaCguLi5tYXBwZWRSZXNwb25zZXNJdGVtTGlzdCk7XG4gICAgfVxuXG4gICAgLy8gcmVjdXJzaXZlbHkgcHJvY2VzcyBhbGwgdW5wcm9jZXNzZWQgaXRlbXNcbiAgICBjb25zdCB1bnByb2Nlc3NlZEl0ZW1zTGlzdCA9IGJhdGNoUmVhZEl0ZW1PdXRwdXRMaXN0LmZpbHRlcihcbiAgICAgIChyZXNwb25zZTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldEl0ZW1PdXRwdXQpID0+XG4gICAgICAgIHJlc3BvbnNlLlVucHJvY2Vzc2VkS2V5cyAmJiAhaXNFbXB0eU9iamVjdChyZXNwb25zZS5VbnByb2Nlc3NlZEtleXMpXG4gICAgKTtcblxuICAgIC8vIGlmIGFsbCBpdGVtcyB3ZXJlIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQsIHJldHVyblxuICAgIGlmICghdW5wcm9jZXNzZWRJdGVtc0xpc3QubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpdGVtczogcmVzcG9uc2VzU3RvcmUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGFib3J0IHdoZW4gcmVhY2hlZCBtYXggYXR0ZW1wdCBjb3VudFxuICAgIC8vIGlmIG5vIHJldHJpZXMgcHJvdmlkZWQgdXNlIGRlZmF1bHQgQkFUQ0hfUkVBRF9NQVhfQUxMT1dFRF9BVFRFTVBUU1xuICAgIGlmIChcbiAgICAgIHRvdGFsQXR0ZW1wdHNTb0ZhciA9PT1cbiAgICAgIChvcHRpb25zPy5tYXhSZXRyeUF0dGVtcHRzID8/IEJBVENIX1JFQURfTUFYX0FMTE9XRURfQVRURU1QVFMpXG4gICAgKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ0luZm8oe1xuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICBzY29wZTogTUFOQUdFUl9OQU1FLkJBVENIX01BTkFHRVIsXG4gICAgICAgIGxvZzogYFJlYWNoZWQgbWF4IGFsbG93ZWQgYXR0ZW1wdHMgJHt0b3RhbEF0dGVtcHRzU29GYXJ9LCBhYm9ydGluZy4uLmAsXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IHJlc3BvbnNlc1N0b3JlLFxuICAgICAgICB1bnByb2Nlc3NlZEl0ZW1zTGlzdDogdW5wcm9jZXNzZWRJdGVtc0xpc3QubWFwKFxuICAgICAgICAgIGl0ZW0gPT4gaXRlbS5VbnByb2Nlc3NlZEtleXMhXG4gICAgICAgICksXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGJhY2tvZmYgYmVmb3JlIHJldHJ5aW5nXG4gICAgYXdhaXQgdGhpcy53YWl0Rm9yRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgdG90YWxBdHRlbXB0c1NvRmFyLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgbWV0YWRhdGFPcHRpb25zXG4gICAgKTtcblxuICAgIC8vIGFnZ3JlZ2F0ZSBhbGwgcmVxdWVzdHMgYnkgdGFibGUgbmFtZVxuICAgIGNvbnN0IHNvcnRlZFVucHJvY2Vzc2VkSXRlbXMgPSB1bnByb2Nlc3NlZEl0ZW1zTGlzdC5yZWR1Y2UoXG4gICAgICAoYWNjLCB7VW5wcm9jZXNzZWRLZXlzfTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldEl0ZW1PdXRwdXQpID0+IHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoVW5wcm9jZXNzZWRLZXlzISkuZm9yRWFjaChcbiAgICAgICAgICAoW3RhYmxlTmFtZSwgdW5wcm9jZXNzZWRSZXF1ZXN0c10pID0+IHtcbiAgICAgICAgICAgIGlmICghYWNjW3RhYmxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgYWNjW3RhYmxlTmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgS2V5czogW10sXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFjY1t0YWJsZU5hbWVdLktleXM/LnB1c2goLi4udW5wcm9jZXNzZWRSZXF1ZXN0cy5LZXlzKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldFJlcXVlc3RNYXBcbiAgICApO1xuXG4gICAgY29uc3QgYmF0Y2hSZXF1ZXN0c0l0ZW1zTGlzdCA9XG4gICAgICB0aGlzLl9kY0JhdGNoVHJhbnNmb3JtZXIubWFwVGFibGVSZWFkSXRlbXNUb0JhdGNoUmVhZEl0ZW1zKFxuICAgICAgICBzb3J0ZWRVbnByb2Nlc3NlZEl0ZW1zXG4gICAgICApO1xuXG4gICAgLy8gYXBwbHkgbGltaXRcbiAgICBjb25zdCBiYXRjaFJlcXVlc3RzID0gYmF0Y2hSZXF1ZXN0c0l0ZW1zTGlzdC5tYXAoYmF0Y2hSZXF1ZXN0TWFwID0+IHtcbiAgICAgIHJldHVybiB0aGlzLnRvTGltaXRlZChcbiAgICAgICAgYXN5bmMgKCkgPT5cbiAgICAgICAgICB0aGlzLmNvbm5lY3Rpb24uZG9jdW1lbnRDbGllbnQuYmF0Y2hHZXQoe1xuICAgICAgICAgICAgUmVxdWVzdEl0ZW1zOiB7Li4uYmF0Y2hSZXF1ZXN0TWFwfSxcbiAgICAgICAgICAgIFJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgYmF0Y2hSZXF1ZXN0TWFwLFxuICAgICAgICBSRVFVRVNUX1RZUEUuQkFUQ0hfUkVBRFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGJhdGNoUmVxdWVzdHNSZXNwb25zZXMgPSAoYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBiYXRjaFJlcXVlc3RzXG4gICAgKSkgYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldEl0ZW1PdXRwdXRMaXN0O1xuXG4gICAgLy8gbG9nIHN0YXRzXG4gICAgYmF0Y2hSZXF1ZXN0c1Jlc3BvbnNlcy5mb3JFYWNoKChyZXNwb25zZSwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5Db25zdW1lZENhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nU3RhdHMoe1xuICAgICAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICAgIHJlcXVlc3RTZWdtZW50OiBpbmRleCxcbiAgICAgICAgICBzdGF0c1R5cGU6IFNUQVRTX1RZUEUuQ09OU1VNRURfQ0FQQUNJVFksXG4gICAgICAgICAgY29uc3VtZWRDYXBhY2l0eURhdGE6IHJlc3BvbnNlLkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlSGFuZGxlQmF0Y2hSZWFkSXRlbXNSZXNwb25zZShcbiAgICAgIGJhdGNoUmVxdWVzdHNSZXNwb25zZXMsXG4gICAgICArK3RvdGFsQXR0ZW1wdHNTb0ZhcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICAvLyByZXNwb25zZXMgc3RvcmUgY29udGFpbmluZyByZXNwb25zZXMgZnJvbSBhbGwgcmVxdWVzdHNcbiAgICAgIHJlc3BvbnNlc1N0b3JlLFxuICAgICAgbWV0YWRhdGFPcHRpb25zXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRFcnJvclF1ZXVlKCkge1xuICAgIHRoaXMuX2Vycm9yUXVldWUgPSBbXTtcbiAgfVxuXG4gIHByaXZhdGUgbWFwQmF0Y2hHZXRSZXNwb25zZVRvSXRlbUxpc3QoXG4gICAgYmF0Y2hHZXRSZXNwb25zZTogRG9jdW1lbnRDbGllbnRUeXBlcy5CYXRjaEdldFJlc3BvbnNlTWFwXG4gICkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhiYXRjaEdldFJlc3BvbnNlKS5mbGF0TWFwKFxuICAgICAgKFssIGJhdGNoUmVzcG9uc2VdKSA9PiBiYXRjaFJlc3BvbnNlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByb21pc2UgdGhhdCBpcyBQcm9taXNlLmFsbCBzYWZlIGFuZCBhbHNvIGNhbiBiZSBtYW5hZ2VkIGJ5IHAtbGltaXRcbiAgICogQHBhcmFtIGFueVByb21pc2VGYWN0b3J5XG4gICAqIEBwYXJhbSByZXF1ZXN0SXRlbSAvLyByZXF1ZXN0IGl0ZW0gaW5wdXRcbiAgICogQHBhcmFtIHJlcXVlc3RUeXBlIC8vIHJlcXVlc3QgdHlwZVxuICAgKi9cbiAgcHJpdmF0ZSB0b0xpbWl0ZWQ8VD4oXG4gICAgYW55UHJvbWlzZUZhY3Rvcnk6ICgpID0+IFByb21pc2U8VD4sXG4gICAgcmVxdWVzdEl0ZW06IGFueSxcbiAgICByZXF1ZXN0VHlwZTogUkVRVUVTVF9UWVBFXG4gICkge1xuICAgIHJldHVybiB0aGlzLmxpbWl0KGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYW55UHJvbWlzZUZhY3RvcnkoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yUXVldWUucHVzaCh7XG4gICAgICAgICAgcmVxdWVzdElucHV0OiByZXF1ZXN0SXRlbSxcbiAgICAgICAgICBlcnJvcjogZXJyIGFzIGFueSxcbiAgICAgICAgICByZXF1ZXN0VHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHdoZW4gYW55IGVycm9yIGlzIHRocm93biB3aGlsZSBwcm9taXNlcyBhcmUgcnVubmluZywgcmV0dXJuIGl0XG4gICAgICAgIC8vIGluc3RlYWQgb2YgdGhyb3dpbmcgaXQgdG8gaGF2ZSBvdGhlciByZXF1ZXN0cyBydW4gYXMgaXMgd2l0aG91dFxuICAgICAgICAvLyBpbnRlcnJ1cHRpb25zXG4gICAgICAgIHJldHVybiBlcnIgYXMgVDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgd2FpdEZvckV4cG9uZW50aWFsQmFja29mZihcbiAgICBhdHRlbXB0czogbnVtYmVyLFxuICAgIG11bHRpcGxpY2F0aW9uRmFjdG9yID0gMSxcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKSB7XG4gICAgbXVsdGlwbGljYXRpb25GYWN0b3IgPSBtdWx0aXBsaWNhdGlvbkZhY3RvciA8IDEgPyAxIDogbXVsdGlwbGljYXRpb25GYWN0b3I7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgYmFja29mZlRpbWUgPSB0aGlzLmV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgYXR0ZW1wdHMsXG4gICAgICAgIG11bHRpcGxpY2F0aW9uRmFjdG9yXG4gICAgICApO1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dJbmZvKHtcbiAgICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgICAgc2NvcGU6IE1BTkFHRVJfTkFNRS5CQVRDSF9NQU5BR0VSLFxuICAgICAgICBsb2c6IGAke2F0dGVtcHRzfSBhdHRlbXB0cyBzbyBmYXIsIHNsZWVwaW5nICR7YmFja29mZlRpbWV9bXMgYmVmb3JlIHJldHJ5aW5nLi4uYCxcbiAgICAgIH0pO1xuICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmVGltZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIGF0dGVtcHRzXG4gICAqL1xuICBwcml2YXRlIGV4cG9uZW50aWFsQmFja29mZihhdHRlbXB0czogbnVtYmVyLCBtdWx0aXBsaWNhdGlvbkZhY3RvcjogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoXG4gICAgICBNYXRoLnJhbmRvbSgpICogMTAgKiBNYXRoLnBvdygyLCBhdHRlbXB0cyB8fCAxKSAqIG11bHRpcGxpY2F0aW9uRmFjdG9yXG4gICAgKTtcbiAgfVxufVxuIl19