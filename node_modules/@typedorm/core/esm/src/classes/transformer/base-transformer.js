import { SparseIndexParseError, InvalidDynamicUpdateAttributeValueError, } from '@typedorm/common';
import { getConstructorForInstance } from '../../helpers/get-constructor-for-instance';
import { isEmptyObject } from '../../helpers/is-empty-object';
import { isScalarType } from '../../helpers/is-scalar-type';
import { parseKey } from '../../helpers/parse-key';
import { IsAutoGeneratedAttributeMetadata } from '../metadata/auto-generated-attribute-metadata';
import { isDynamoEntityKeySchema } from '../../helpers/is-dynamo-entity-key-schema';
import { isKeyOfTypeAliasSchema } from '../../helpers/is-key-of-type-alias-schema';
import { classToPlain } from 'class-transformer';
import { ExpressionInputParser } from '../expression/expression-input-parser';
export class BaseTransformer {
    connection;
    _expressionInputParser;
    constructor(connection) {
        this.connection = connection;
        this._expressionInputParser = new ExpressionInputParser();
    }
    /**
     * Returns table name decorated for given entity class
     * @param entityClass Entity Class
     */
    getTableNameForEntity(entityClass) {
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        return entityMetadata.table.name;
    }
    applyClassTransformerFormations(entity) {
        const transformedPlainEntity = classToPlain(entity, {
            enableImplicitConversion: true,
            excludePrefixes: ['__'], // exclude internal attributes
        });
        return transformedPlainEntity;
    }
    /**
     * Transforms entity to dynamo db entity schema
     * @param entity Entity to transform to DynamoDB entity type
     */
    toDynamoEntity(entity) {
        const entityClass = getConstructorForInstance(entity);
        // retrieve metadata and parse it to schema
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        this.connection.getAttributesForEntity(entityClass).forEach(attr => {
            // if no explicit value was provided, look for default/autoGenerate values
            if (!Object.keys(entity).includes(attr.name)) {
                //  auto populate generated values
                if (IsAutoGeneratedAttributeMetadata(attr)) {
                    entity = Object.assign(entity, {
                        [attr.name]: attr.value,
                    });
                }
                const attributeDefaultValue = attr?.default;
                // include attribute with default value
                if (attributeDefaultValue &&
                    typeof attributeDefaultValue === 'function') {
                    const attrDefaultValue = attributeDefaultValue(entity);
                    entity = Object.assign(entity, {
                        [attr.name]: attrDefaultValue,
                    });
                }
            }
        });
        // pass through entity to class transformer to have all the metadata applied
        const parsedEntity = this.applyClassTransformerFormations(entity);
        const parsedPrimaryKey = this.recursiveParseEntity(entityMetadata.schema.primaryKey.attributes, parsedEntity);
        const indexesToParse = entityMetadata.schema.indexes ?? {};
        const rawParsedIndexes = this.recursiveParseEntity(indexesToParse, parsedEntity);
        const parsedIndexes = Object.keys(rawParsedIndexes).reduce((acc, currIndexKey) => {
            const { metadata, attributes } = indexesToParse[currIndexKey];
            const currentParsedIndex = rawParsedIndexes[currIndexKey];
            // validate if there are any duplicated attribute names
            Object.keys(currentParsedIndex).forEach(attr => {
                if (acc[attr]) {
                    throw new Error(`Failed to parse entity "${entityMetadata.name}", duplicate attribute "${attr}".`);
                }
            });
            // if current index marked as sparse and one or more attribute is missing value, do not add it to schema
            if (metadata.isSparse) {
                const doesAllAttributesHaveValue = Object.keys(attributes).every(attr => {
                    if (!currentParsedIndex[attr]) {
                        return false;
                    }
                    return true;
                });
                if (!doesAllAttributesHaveValue) {
                    return acc;
                }
            }
            acc = { ...acc, ...currentParsedIndex };
            return acc;
        }, {});
        // clone and cleanup any redundant keys
        const formattedSchema = {
            ...parsedPrimaryKey,
            ...parsedIndexes,
        };
        return { ...parsedEntity, ...formattedSchema };
    }
    getAffectedPrimaryKeyAttributes(entityClass, attributes, attributesTypeMetadata, options) {
        const { schema: { primaryKey }, } = this.connection.getEntityByTarget(entityClass);
        const interpolations = primaryKey.metadata._interpolations;
        // if none of partition or sort key has any referenced attributes, return
        if (!interpolations || isEmptyObject(interpolations)) {
            return;
        }
        const affectedKeyAttributes = Object.entries(attributes).reduce((acc, [attrKey, attrValue]) => {
            // bail early if current attribute type is not of type scalar
            if (!isScalarType(attrValue)) {
                return acc;
            }
            // resolve all interpolations
            Object.entries(interpolations).forEach(([primaryKeyAttrName, primaryKeyAttrRefs]) => {
                // if no attributes are referenced for current primary key attribute, return
                if (!primaryKeyAttrRefs.includes(attrKey)) {
                    return;
                }
                // if parsed value was of type we can not auto resolve indexes
                // this must be resolved by the dev
                if (attributesTypeMetadata[attrKey] === 'dynamic') {
                    throw new InvalidDynamicUpdateAttributeValueError(attrKey, attrValue);
                }
                const parsedKey = parseKey(primaryKey.attributes[primaryKeyAttrName], { ...options?.additionalAttributesDict, ...attributes });
                acc[primaryKeyAttrName] = parsedKey;
            });
            return acc;
        }, {});
        return affectedKeyAttributes;
    }
    /**
     * Returns all affected indexes for given attributes
     * @param entityClass Entity class
     * @param attributes Attributes to check affected indexes for
     * @param options
     */
    getAffectedIndexesForAttributes(entityClass, attributes, attributesTypeMetadata, options) {
        const nestedKeySeparator = options?.nestedKeySeparator ?? '.';
        const { schema: { indexes }, } = this.connection.getEntityByTarget(entityClass);
        const affectedIndexes = Object.entries(attributes).reduce((acc, [attrKey, currAttrValue]) => {
            // if current value is not of scalar type skip checking index
            if (attrKey.includes(nestedKeySeparator) ||
                !isScalarType(currAttrValue)) {
                return acc;
            }
            if (!indexes) {
                return acc;
            }
            Object.keys(indexes).forEach(key => {
                const currIndex = indexes[key];
                const interpolationsForCurrIndex = currIndex.metadata._interpolations ?? {};
                // if current index does not have any interpolations to resolve, move onto next one
                if (isEmptyObject(interpolationsForCurrIndex)) {
                    return acc;
                }
                // check if attribute we are looking to update is referenced by any index
                Object.keys(interpolationsForCurrIndex).forEach(interpolationKey => {
                    const currentInterpolation = interpolationsForCurrIndex[interpolationKey];
                    if (currentInterpolation.includes(attrKey)) {
                        // if parsed value was of type we can not auto resolve indexes
                        // this must be resolved by the dev
                        if (attributesTypeMetadata[attrKey] === 'dynamic') {
                            throw new InvalidDynamicUpdateAttributeValueError(attrKey, currAttrValue);
                        }
                        try {
                            const parsedIndex = parseKey(currIndex.attributes[interpolationKey], { ...options?.additionalAttributesDict, ...attributes });
                            acc[interpolationKey] = parsedIndex;
                        }
                        catch (err) {
                            // if there was an error parsing sparse index, ignore
                            if (!(err instanceof SparseIndexParseError)) {
                                throw err;
                            }
                        }
                    }
                });
            });
            return acc;
        }, {});
        return affectedIndexes;
    }
    /**
     * Returns a primary key of an entity
     * @param entityClass Class of entity
     * @param attributes Attributes to parse into primary key
     */
    getParsedPrimaryKey(table, primaryKey, attributes) {
        return this.recursiveParseEntity(primaryKey.attributes, attributes);
    }
    /**
     * Recursively parses all keys of given object and replaces placeholders with matching values
     * @private
     * @param schema schema to resolve
     * @param entity entity to resolve schema against
     */
    recursiveParseEntity(schema, entity, isSparse = false) {
        const parsedSchema = Object.keys(schema).reduce((acc, key) => {
            const currentValue = schema[key];
            if (typeof currentValue === 'string' ||
                isKeyOfTypeAliasSchema(currentValue)) {
                try {
                    acc[key] = parseKey(currentValue, entity, {
                        isSparseIndex: isSparse,
                    });
                }
                catch (err) {
                    // if there was an error parsing sparse index, ignore
                    if (!(err instanceof SparseIndexParseError)) {
                        throw err;
                    }
                }
            }
            else if (isDynamoEntityKeySchema(currentValue)) {
                acc[key] = this.recursiveParseEntity(currentValue.attributes, entity, !!currentValue.metadata?.isSparse);
            }
            else {
                acc[key] = this.recursiveParseEntity(currentValue, entity);
            }
            return acc;
        }, {});
        return parsedSchema;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS10cmFuc2Zvcm1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2NsYXNzZXMvdHJhbnNmb3JtZXIvYmFzZS10cmFuc2Zvcm1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFLQSxPQUFPLEVBR0wscUJBQXFCLEVBRXJCLHVDQUF1QyxHQUN4QyxNQUFNLGtCQUFrQixDQUFDO0FBQzFCLE9BQU8sRUFBQyx5QkFBeUIsRUFBQyxNQUFNLDRDQUE0QyxDQUFDO0FBQ3JGLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSwrQkFBK0IsQ0FBQztBQUM1RCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDMUQsT0FBTyxFQUFDLFFBQVEsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBRWpELE9BQU8sRUFBQyxnQ0FBZ0MsRUFBQyxNQUFNLCtDQUErQyxDQUFDO0FBRS9GLE9BQU8sRUFBQyx1QkFBdUIsRUFBQyxNQUFNLDJDQUEyQyxDQUFDO0FBQ2xGLE9BQU8sRUFBQyxzQkFBc0IsRUFBQyxNQUFNLDJDQUEyQyxDQUFDO0FBQ2pGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUMvQyxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSx1Q0FBdUMsQ0FBQztBQVk1RSxNQUFNLE9BQWdCLGVBQWU7SUFHYjtJQUZaLHNCQUFzQixDQUF3QjtJQUV4RCxZQUFzQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQzFDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLHFCQUFxQixFQUFFLENBQUM7SUFDNUQsQ0FBQztJQUNEOzs7T0FHRztJQUNILHFCQUFxQixDQUFTLFdBQWlDO1FBQzdELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdEUsT0FBTyxj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LENBQUMsR0FBRyxRQUFRLENBQUMsWUFBWSxFQUFFLE1BQU0sRUFBRTt3QkFDeEMsYUFBYSxFQUFFLFFBQVE7cUJBQ3hCLENBQUMsQ0FBQztpQkFDSjtnQkFBQyxPQUFPLEdBQUcsRUFBRTtvQkFDWixxREFBcUQ7b0JBQ3JELElBQUksQ0FBQyxDQUFDLEdBQUcsWUFBWSxxQkFBcUIsQ0FBQyxFQUFFO3dCQUMzQyxNQUFNLEdBQUcsQ0FBQztxQkFDWDtpQkFDRjthQUNGO2lCQUFNLElBQUksdUJBQXVCLENBQUMsWUFBWSxDQUFDLEVBQUU7Z0JBQ2hELEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQ2xDLFlBQVksQ0FBQyxVQUFVLEVBQ3ZCLE1BQU0sRUFDTixDQUFDLENBQUUsWUFBWSxDQUFDLFFBQW9DLEVBQUUsUUFBUSxDQUMvRCxDQUFDO2FBQ0g7aUJBQU07Z0JBQ0wsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDNUQ7WUFDRCxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxFQUFTLENBQUMsQ0FBQztRQUVkLE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QXR0cmlidXRlTWV0YWRhdGF9IGZyb20gJy4vLi4vbWV0YWRhdGEvYXR0cmlidXRlLW1ldGFkYXRhJztcbmltcG9ydCB7XG4gIER5bmFtb0VudGl0eUluZGV4ZXNTY2hlbWEsXG4gIER5bmFtb0VudGl0eUluZGV4U2NoZW1hLFxufSBmcm9tICcuLy4uL21ldGFkYXRhL2VudGl0eS1tZXRhZGF0YSc7XG5pbXBvcnQge1xuICBFbnRpdHlUYXJnZXQsXG4gIFRhYmxlLFxuICBTcGFyc2VJbmRleFBhcnNlRXJyb3IsXG4gIENPTlNVTUVEX0NBUEFDSVRZX1RZUEUsXG4gIEludmFsaWREeW5hbWljVXBkYXRlQXR0cmlidXRlVmFsdWVFcnJvcixcbn0gZnJvbSAnQHR5cGVkb3JtL2NvbW1vbic7XG5pbXBvcnQge2dldENvbnN0cnVjdG9yRm9ySW5zdGFuY2V9IGZyb20gJy4uLy4uL2hlbHBlcnMvZ2V0LWNvbnN0cnVjdG9yLWZvci1pbnN0YW5jZSc7XG5pbXBvcnQge2lzRW1wdHlPYmplY3R9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtZW1wdHktb2JqZWN0JztcbmltcG9ydCB7aXNTY2FsYXJUeXBlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLXNjYWxhci10eXBlJztcbmltcG9ydCB7cGFyc2VLZXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvcGFyc2Uta2V5JztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbi9jb25uZWN0aW9uJztcbmltcG9ydCB7SXNBdXRvR2VuZXJhdGVkQXR0cmlidXRlTWV0YWRhdGF9IGZyb20gJy4uL21ldGFkYXRhL2F1dG8tZ2VuZXJhdGVkLWF0dHJpYnV0ZS1tZXRhZGF0YSc7XG5pbXBvcnQge0R5bmFtb0VudGl0eVNjaGVtYVByaW1hcnlLZXl9IGZyb20gJy4uL21ldGFkYXRhL2VudGl0eS1tZXRhZGF0YSc7XG5pbXBvcnQge2lzRHluYW1vRW50aXR5S2V5U2NoZW1hfSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLWR5bmFtby1lbnRpdHkta2V5LXNjaGVtYSc7XG5pbXBvcnQge2lzS2V5T2ZUeXBlQWxpYXNTY2hlbWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMta2V5LW9mLXR5cGUtYWxpYXMtc2NoZW1hJztcbmltcG9ydCB7Y2xhc3NUb1BsYWlufSBmcm9tICdjbGFzcy10cmFuc2Zvcm1lcic7XG5pbXBvcnQge0V4cHJlc3Npb25JbnB1dFBhcnNlcn0gZnJvbSAnLi4vZXhwcmVzc2lvbi9leHByZXNzaW9uLWlucHV0LXBhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFPcHRpb25zIHtcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xuICByZXR1cm5Db25zdW1lZENhcGFjaXR5PzogQ09OU1VNRURfQ0FQQUNJVFlfVFlQRTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YU9wdGlvbnMge1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIHJldHVybkNvbnN1bWVkQ2FwYWNpdHk/OiBDT05TVU1FRF9DQVBBQ0lUWV9UWVBFO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVRyYW5zZm9ybWVyIHtcbiAgcHJvdGVjdGVkIF9leHByZXNzaW9uSW5wdXRQYXJzZXI6IEV4cHJlc3Npb25JbnB1dFBhcnNlcjtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29ubmVjdGlvbjogQ29ubmVjdGlvbikge1xuICAgIHRoaXMuX2V4cHJlc3Npb25JbnB1dFBhcnNlciA9IG5ldyBFeHByZXNzaW9uSW5wdXRQYXJzZXIoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0YWJsZSBuYW1lIGRlY29yYXRlZCBmb3IgZ2l2ZW4gZW50aXR5IGNsYXNzXG4gICAqIEBwYXJhbSBlbnRpdHlDbGFzcyBFbnRpdHkgQ2xhc3NcbiAgICovXG4gIGdldFRhYmxlTmFtZUZvckVudGl0eTxFbnRpdHk+KGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5Pikge1xuICAgIGNvbnN0IGVudGl0eU1ldGFkYXRhID0gdGhpcy5jb25uZWN0aW9uLmdldEVudGl0eUJ5VGFyZ2V0KGVudGl0eUNsYXNzKTtcblxuICAgIHJldHVybiBlbnRpdHlNZXRhZGF0YS50YWJsZS5uYW1lO1xuICB9XG5cbiAgYXBwbHlDbGFzc1RyYW5zZm9ybWVyRm9ybWF0aW9uczxFbnRpdHk+KGVudGl0eTogRW50aXR5KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQbGFpbkVudGl0eSA9IGNsYXNzVG9QbGFpbjxFbnRpdHk+KGVudGl0eSwge1xuICAgICAgZW5hYmxlSW1wbGljaXRDb252ZXJzaW9uOiB0cnVlLFxuICAgICAgZXhjbHVkZVByZWZpeGVzOiBbJ19fJ10sIC8vIGV4Y2x1ZGUgaW50ZXJuYWwgYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkUGxhaW5FbnRpdHkgYXMgRW50aXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgZW50aXR5IHRvIGR5bmFtbyBkYiBlbnRpdHkgc2NoZW1hXG4gICAqIEBwYXJhbSBlbnRpdHkgRW50aXR5IHRvIHRyYW5zZm9ybSB0byBEeW5hbW9EQiBlbnRpdHkgdHlwZVxuICAgKi9cbiAgdG9EeW5hbW9FbnRpdHk8RW50aXR5PihlbnRpdHk6IEVudGl0eSkge1xuICAgIGNvbnN0IGVudGl0eUNsYXNzID0gZ2V0Q29uc3RydWN0b3JGb3JJbnN0YW5jZShlbnRpdHkpO1xuXG4gICAgLy8gcmV0cmlldmUgbWV0YWRhdGEgYW5kIHBhcnNlIGl0IHRvIHNjaGVtYVxuICAgIGNvbnN0IGVudGl0eU1ldGFkYXRhID0gdGhpcy5jb25uZWN0aW9uLmdldEVudGl0eUJ5VGFyZ2V0KGVudGl0eUNsYXNzKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5nZXRBdHRyaWJ1dGVzRm9yRW50aXR5KGVudGl0eUNsYXNzKS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgLy8gaWYgbm8gZXhwbGljaXQgdmFsdWUgd2FzIHByb3ZpZGVkLCBsb29rIGZvciBkZWZhdWx0L2F1dG9HZW5lcmF0ZSB2YWx1ZXNcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZW50aXR5IGFzIG9iamVjdCkuaW5jbHVkZXMoYXR0ci5uYW1lKSkge1xuICAgICAgICAvLyAgYXV0byBwb3B1bGF0ZSBnZW5lcmF0ZWQgdmFsdWVzXG4gICAgICAgIGlmIChJc0F1dG9HZW5lcmF0ZWRBdHRyaWJ1dGVNZXRhZGF0YShhdHRyKSkge1xuICAgICAgICAgIGVudGl0eSA9IE9iamVjdC5hc3NpZ24oZW50aXR5IGFzIG9iamVjdCwge1xuICAgICAgICAgICAgW2F0dHIubmFtZV06IGF0dHIudmFsdWUsXG4gICAgICAgICAgfSkgYXMgRW50aXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXR0cmlidXRlRGVmYXVsdFZhbHVlID0gKGF0dHIgYXMgQXR0cmlidXRlTWV0YWRhdGEpPy5kZWZhdWx0O1xuXG4gICAgICAgIC8vIGluY2x1ZGUgYXR0cmlidXRlIHdpdGggZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0cmlidXRlRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZURlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhdHRyRGVmYXVsdFZhbHVlID0gYXR0cmlidXRlRGVmYXVsdFZhbHVlKGVudGl0eSk7XG4gICAgICAgICAgZW50aXR5ID0gT2JqZWN0LmFzc2lnbihlbnRpdHkgYXMgb2JqZWN0LCB7XG4gICAgICAgICAgICBbYXR0ci5uYW1lXTogYXR0ckRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICB9KSBhcyBFbnRpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBhc3MgdGhyb3VnaCBlbnRpdHkgdG8gY2xhc3MgdHJhbnNmb3JtZXIgdG8gaGF2ZSBhbGwgdGhlIG1ldGFkYXRhIGFwcGxpZWRcbiAgICBjb25zdCBwYXJzZWRFbnRpdHkgPSB0aGlzLmFwcGx5Q2xhc3NUcmFuc2Zvcm1lckZvcm1hdGlvbnMoZW50aXR5KTtcblxuICAgIGNvbnN0IHBhcnNlZFByaW1hcnlLZXkgPSB0aGlzLnJlY3Vyc2l2ZVBhcnNlRW50aXR5KFxuICAgICAgZW50aXR5TWV0YWRhdGEuc2NoZW1hLnByaW1hcnlLZXkuYXR0cmlidXRlcyxcbiAgICAgIHBhcnNlZEVudGl0eVxuICAgICk7XG5cbiAgICBjb25zdCBpbmRleGVzVG9QYXJzZSA9IGVudGl0eU1ldGFkYXRhLnNjaGVtYS5pbmRleGVzID8/IHt9O1xuICAgIGNvbnN0IHJhd1BhcnNlZEluZGV4ZXMgPSB0aGlzLnJlY3Vyc2l2ZVBhcnNlRW50aXR5KFxuICAgICAgaW5kZXhlc1RvUGFyc2UsXG4gICAgICBwYXJzZWRFbnRpdHlcbiAgICApO1xuXG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IE9iamVjdC5rZXlzKHJhd1BhcnNlZEluZGV4ZXMpLnJlZHVjZShcbiAgICAgIChhY2MsIGN1cnJJbmRleEtleSkgPT4ge1xuICAgICAgICBjb25zdCB7bWV0YWRhdGEsIGF0dHJpYnV0ZXN9ID0gaW5kZXhlc1RvUGFyc2VbY3VyckluZGV4S2V5XTtcbiAgICAgICAgY29uc3QgY3VycmVudFBhcnNlZEluZGV4ID0gcmF3UGFyc2VkSW5kZXhlc1tjdXJySW5kZXhLZXldO1xuXG4gICAgICAgIC8vIHZhbGlkYXRlIGlmIHRoZXJlIGFyZSBhbnkgZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgT2JqZWN0LmtleXMoY3VycmVudFBhcnNlZEluZGV4KS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChhY2NbYXR0cl0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBwYXJzZSBlbnRpdHkgXCIke2VudGl0eU1ldGFkYXRhLm5hbWV9XCIsIGR1cGxpY2F0ZSBhdHRyaWJ1dGUgXCIke2F0dHJ9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgaW5kZXggbWFya2VkIGFzIHNwYXJzZSBhbmQgb25lIG9yIG1vcmUgYXR0cmlidXRlIGlzIG1pc3NpbmcgdmFsdWUsIGRvIG5vdCBhZGQgaXQgdG8gc2NoZW1hXG4gICAgICAgIGlmIChtZXRhZGF0YS5pc1NwYXJzZSkge1xuICAgICAgICAgIGNvbnN0IGRvZXNBbGxBdHRyaWJ1dGVzSGF2ZVZhbHVlID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZXZlcnkoXG4gICAgICAgICAgICBhdHRyID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFyc2VkSW5kZXhbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghZG9lc0FsbEF0dHJpYnV0ZXNIYXZlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjID0gey4uLmFjYywgLi4uY3VycmVudFBhcnNlZEluZGV4fTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyB7W2tleTogc3RyaW5nXTogc3RyaW5nfVxuICAgICk7XG5cbiAgICAvLyBjbG9uZSBhbmQgY2xlYW51cCBhbnkgcmVkdW5kYW50IGtleXNcbiAgICBjb25zdCBmb3JtYXR0ZWRTY2hlbWEgPSB7XG4gICAgICAuLi5wYXJzZWRQcmltYXJ5S2V5LFxuICAgICAgLi4ucGFyc2VkSW5kZXhlcyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsuLi5wYXJzZWRFbnRpdHksIC4uLmZvcm1hdHRlZFNjaGVtYX07XG4gIH1cblxuICBnZXRBZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzPEVudGl0eT4oXG4gICAgZW50aXR5Q2xhc3M6IEVudGl0eVRhcmdldDxFbnRpdHk+LFxuICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgYXR0cmlidXRlc1R5cGVNZXRhZGF0YTogUmVjb3JkPHN0cmluZywgJ3N0YXRpYycgfCAnZHluYW1pYyc+LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBhZGRpdGlvbmFsQXR0cmlidXRlc0RpY3Q/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIH1cbiAgKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NoZW1hOiB7cHJpbWFyeUtleX0sXG4gICAgfSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9ucyA9IHByaW1hcnlLZXkubWV0YWRhdGEuX2ludGVycG9sYXRpb25zO1xuXG4gICAgLy8gaWYgbm9uZSBvZiBwYXJ0aXRpb24gb3Igc29ydCBrZXkgaGFzIGFueSByZWZlcmVuY2VkIGF0dHJpYnV0ZXMsIHJldHVyblxuICAgIGlmICghaW50ZXJwb2xhdGlvbnMgfHwgaXNFbXB0eU9iamVjdChpbnRlcnBvbGF0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhZmZlY3RlZEtleUF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBbYXR0cktleSwgYXR0clZhbHVlXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAvLyBiYWlsIGVhcmx5IGlmIGN1cnJlbnQgYXR0cmlidXRlIHR5cGUgaXMgbm90IG9mIHR5cGUgc2NhbGFyXG4gICAgICAgIGlmICghaXNTY2FsYXJUeXBlKGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgaW50ZXJwb2xhdGlvbnNcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoaW50ZXJwb2xhdGlvbnMpLmZvckVhY2goXG4gICAgICAgICAgKFtwcmltYXJ5S2V5QXR0ck5hbWUsIHByaW1hcnlLZXlBdHRyUmVmc10pID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vIGF0dHJpYnV0ZXMgYXJlIHJlZmVyZW5jZWQgZm9yIGN1cnJlbnQgcHJpbWFyeSBrZXkgYXR0cmlidXRlLCByZXR1cm5cbiAgICAgICAgICAgIGlmICghcHJpbWFyeUtleUF0dHJSZWZzLmluY2x1ZGVzKGF0dHJLZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgcGFyc2VkIHZhbHVlIHdhcyBvZiB0eXBlIHdlIGNhbiBub3QgYXV0byByZXNvbHZlIGluZGV4ZXNcbiAgICAgICAgICAgIC8vIHRoaXMgbXVzdCBiZSByZXNvbHZlZCBieSB0aGUgZGV2XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1R5cGVNZXRhZGF0YVthdHRyS2V5XSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZVZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICAgYXR0cktleSxcbiAgICAgICAgICAgICAgICBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gcGFyc2VLZXkoXG4gICAgICAgICAgICAgIHByaW1hcnlLZXkuYXR0cmlidXRlc1twcmltYXJ5S2V5QXR0ck5hbWVdLFxuICAgICAgICAgICAgICB7Li4ub3B0aW9ucz8uYWRkaXRpb25hbEF0dHJpYnV0ZXNEaWN0LCAuLi5hdHRyaWJ1dGVzfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFjY1twcmltYXJ5S2V5QXR0ck5hbWVdID0gcGFyc2VkS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICApO1xuXG4gICAgcmV0dXJuIGFmZmVjdGVkS2V5QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhZmZlY3RlZCBpbmRleGVzIGZvciBnaXZlbiBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSBlbnRpdHlDbGFzcyBFbnRpdHkgY2xhc3NcbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgQXR0cmlidXRlcyB0byBjaGVjayBhZmZlY3RlZCBpbmRleGVzIGZvclxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgZ2V0QWZmZWN0ZWRJbmRleGVzRm9yQXR0cmlidXRlczxFbnRpdHk+KFxuICAgIGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5PixcbiAgICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIGF0dHJpYnV0ZXNUeXBlTWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsICdzdGF0aWMnIHwgJ2R5bmFtaWMnPixcbiAgICBvcHRpb25zPzoge1xuICAgICAgbmVzdGVkS2V5U2VwYXJhdG9yPzogc3RyaW5nO1xuICAgICAgYWRkaXRpb25hbEF0dHJpYnV0ZXNEaWN0PzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB9XG4gICkge1xuICAgIGNvbnN0IG5lc3RlZEtleVNlcGFyYXRvciA9IG9wdGlvbnM/Lm5lc3RlZEtleVNlcGFyYXRvciA/PyAnLic7XG4gICAgY29uc3Qge1xuICAgICAgc2NoZW1hOiB7aW5kZXhlc30sXG4gICAgfSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG5cbiAgICBjb25zdCBhZmZlY3RlZEluZGV4ZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBbYXR0cktleSwgY3VyckF0dHJWYWx1ZV0pID0+IHtcbiAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBub3Qgb2Ygc2NhbGFyIHR5cGUgc2tpcCBjaGVja2luZyBpbmRleFxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0cktleS5pbmNsdWRlcyhuZXN0ZWRLZXlTZXBhcmF0b3IpIHx8XG4gICAgICAgICAgIWlzU2NhbGFyVHlwZShjdXJyQXR0clZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGluZGV4ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJySW5kZXggPSBpbmRleGVzW2tleV07XG4gICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXggPVxuICAgICAgICAgICAgY3VyckluZGV4Lm1ldGFkYXRhLl9pbnRlcnBvbGF0aW9ucyA/PyB7fTtcblxuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgaW5kZXggZG9lcyBub3QgaGF2ZSBhbnkgaW50ZXJwb2xhdGlvbnMgdG8gcmVzb2x2ZSwgbW92ZSBvbnRvIG5leHQgb25lXG4gICAgICAgICAgaWYgKGlzRW1wdHlPYmplY3QoaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGF0dHJpYnV0ZSB3ZSBhcmUgbG9va2luZyB0byB1cGRhdGUgaXMgcmVmZXJlbmNlZCBieSBhbnkgaW5kZXhcbiAgICAgICAgICBPYmplY3Qua2V5cyhpbnRlcnBvbGF0aW9uc0ZvckN1cnJJbmRleCkuZm9yRWFjaChpbnRlcnBvbGF0aW9uS2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnBvbGF0aW9uID1cbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXhbaW50ZXJwb2xhdGlvbktleV07XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJwb2xhdGlvbi5pbmNsdWRlcyhhdHRyS2V5KSkge1xuICAgICAgICAgICAgICAvLyBpZiBwYXJzZWQgdmFsdWUgd2FzIG9mIHR5cGUgd2UgY2FuIG5vdCBhdXRvIHJlc29sdmUgaW5kZXhlc1xuICAgICAgICAgICAgICAvLyB0aGlzIG11c3QgYmUgcmVzb2x2ZWQgYnkgdGhlIGRldlxuICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1R5cGVNZXRhZGF0YVthdHRyS2V5XSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWREeW5hbWljVXBkYXRlQXR0cmlidXRlVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgICAgIGF0dHJLZXksXG4gICAgICAgICAgICAgICAgICBjdXJyQXR0clZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSW5kZXggPSBwYXJzZUtleShcbiAgICAgICAgICAgICAgICAgIGN1cnJJbmRleC5hdHRyaWJ1dGVzW2ludGVycG9sYXRpb25LZXldLFxuICAgICAgICAgICAgICAgICAgey4uLm9wdGlvbnM/LmFkZGl0aW9uYWxBdHRyaWJ1dGVzRGljdCwgLi4uYXR0cmlidXRlc31cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFjY1tpbnRlcnBvbGF0aW9uS2V5XSA9IHBhcnNlZEluZGV4O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgcGFyc2luZyBzcGFyc2UgaW5kZXgsIGlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFNwYXJzZUluZGV4UGFyc2VFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyBhbnlcbiAgICApO1xuICAgIHJldHVybiBhZmZlY3RlZEluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByaW1hcnkga2V5IG9mIGFuIGVudGl0eVxuICAgKiBAcGFyYW0gZW50aXR5Q2xhc3MgQ2xhc3Mgb2YgZW50aXR5XG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgdG8gcGFyc2UgaW50byBwcmltYXJ5IGtleVxuICAgKi9cbiAgZ2V0UGFyc2VkUHJpbWFyeUtleTxFbnRpdHk+KFxuICAgIHRhYmxlOiBUYWJsZSxcbiAgICBwcmltYXJ5S2V5OiBEeW5hbW9FbnRpdHlTY2hlbWFQcmltYXJ5S2V5LFxuICAgIGF0dHJpYnV0ZXM6IFBhcnRpYWw8RW50aXR5PlxuICApIHtcbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShwcmltYXJ5S2V5LmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHBhcnNlcyBhbGwga2V5cyBvZiBnaXZlbiBvYmplY3QgYW5kIHJlcGxhY2VzIHBsYWNlaG9sZGVycyB3aXRoIG1hdGNoaW5nIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gc2NoZW1hIHNjaGVtYSB0byByZXNvbHZlXG4gICAqIEBwYXJhbSBlbnRpdHkgZW50aXR5IHRvIHJlc29sdmUgc2NoZW1hIGFnYWluc3RcbiAgICovXG4gIHByb3RlY3RlZCByZWN1cnNpdmVQYXJzZUVudGl0eTxFbnRpdHkgPSBhbnk+KFxuICAgIHNjaGVtYTogRHluYW1vRW50aXR5U2NoZW1hUHJpbWFyeUtleSB8IER5bmFtb0VudGl0eUluZGV4ZXNTY2hlbWEsXG4gICAgZW50aXR5OiBFbnRpdHksXG4gICAgaXNTcGFyc2UgPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCBwYXJzZWRTY2hlbWEgPSBPYmplY3Qua2V5cyhzY2hlbWEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IChzY2hlbWEgYXMgYW55KVtrZXldO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIGlzS2V5T2ZUeXBlQWxpYXNTY2hlbWEoY3VycmVudFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBwYXJzZUtleShjdXJyZW50VmFsdWUsIGVudGl0eSwge1xuICAgICAgICAgICAgaXNTcGFyc2VJbmRleDogaXNTcGFyc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHNwYXJzZSBpbmRleCwgaWdub3JlXG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgU3BhcnNlSW5kZXhQYXJzZUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0R5bmFtb0VudGl0eUtleVNjaGVtYShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIGFjY1trZXldID0gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShcbiAgICAgICAgICBjdXJyZW50VmFsdWUuYXR0cmlidXRlcyxcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgISEoY3VycmVudFZhbHVlLm1ldGFkYXRhIGFzIER5bmFtb0VudGl0eUluZGV4U2NoZW1hKT8uaXNTcGFyc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1trZXldID0gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShjdXJyZW50VmFsdWUsIGVudGl0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9IGFzIGFueSk7XG5cbiAgICByZXR1cm4gcGFyc2VkU2NoZW1hO1xuICB9XG59XG4iXX0=