import { INDEX_TYPE, QUERY_ORDER, RETURN_VALUES, TRANSFORM_TYPE, QUERY_SELECT_TYPE, NoSuchIndexFoundError, InvalidFilterInputError, InvalidSelectInputError, InvalidUniqueAttributeUpdateError, InvalidDynamicUpdateAttributeValueError, } from '@typedorm/common';
import { dropProp } from '../../helpers/drop-prop';
import { getConstructorForInstance } from '../../helpers/get-constructor-for-instance';
import { isEmptyObject } from '../../helpers/is-empty-object';
import { parseKey } from '../../helpers/parse-key';
import { KeyCondition } from '../expression/key-condition';
import { ExpressionBuilder } from '../expression/expression-builder';
import { BaseTransformer } from './base-transformer';
import { isObject } from '../../helpers/is-object';
import { autoGenerateValue } from '../../helpers/auto-generate-attribute-value';
export class DocumentClientRequestTransformer extends BaseTransformer {
    _expressionBuilder;
    constructor(connection) {
        super(connection);
        this._expressionBuilder = new ExpressionBuilder();
    }
    get expressionBuilder() {
        return this._expressionBuilder;
    }
    get expressionInputParser() {
        return this._expressionInputParser;
    }
    toDynamoPutItem(entity, options, metadataOptions) {
        const entityClass = getConstructorForInstance(entity);
        const { table, internalAttributes, name } = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.PUT,
            prefix: 'Before',
            entityName: name,
            primaryKey: null,
            body: entity,
            options,
        });
        const uniqueAttributes = this.connection.getUniqueAttributesForEntity(entityClass);
        // include attributes with default values in
        const dynamoEntity = this.toDynamoEntity(entity);
        const entityInternalAttributes = internalAttributes.reduce((acc, attr) => {
            acc[attr.name] = attr.value;
            return acc;
        }, {});
        let dynamoPutItem = {
            Item: {
                ...entityInternalAttributes,
                ...dynamoEntity,
            },
            TableName: table.name,
            ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
        };
        // apply attribute not exist condition when creating unique
        const uniqueRecordConditionExpression = this.expressionBuilder.buildUniqueRecordConditionExpression(table);
        // always prevent overwriting data until explicitly told to do otherwise
        if (!options?.overwriteIfExists) {
            dynamoPutItem = {
                ...dynamoPutItem,
                ...uniqueRecordConditionExpression,
            };
        }
        // if there is `where` condition options exists, build condition expression
        if (options?.where && !isEmptyObject(options?.where)) {
            const condition = this.expressionInputParser.parseToCondition(options?.where);
            if (!condition) {
                throw new Error(`Failed to build condition expression for input: ${JSON.stringify(options?.where)}`);
            }
            const { ConditionExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildConditionExpression(condition);
            // by default, entity manger appends unique record condition expression to avoid overwriting items if they already exist
            // so handle that
            const mergedExp = this._expressionBuilder.andMergeConditionExpressions({
                ConditionExpression: dynamoPutItem.ConditionExpression,
                ExpressionAttributeNames: dynamoPutItem.ExpressionAttributeNames,
                ExpressionAttributeValues: dynamoPutItem.ExpressionAttributeValues,
            }, {
                ConditionExpression,
                ExpressionAttributeNames,
                ExpressionAttributeValues,
            });
            dynamoPutItem.ConditionExpression = mergedExp.ConditionExpression;
            dynamoPutItem.ExpressionAttributeNames =
                mergedExp.ExpressionAttributeNames;
            dynamoPutItem.ExpressionAttributeValues =
                mergedExp.ExpressionAttributeValues;
        }
        // no unique attributes exist, so return early
        if (!uniqueAttributes.length) {
            this.connection.logger.logTransform({
                requestId: metadataOptions?.requestId,
                operation: TRANSFORM_TYPE.PUT,
                prefix: 'After',
                entityName: name,
                primaryKey: null,
                body: dynamoPutItem,
            });
            return dynamoPutItem;
        }
        // if there are unique attributes, return transaction list item
        let uniqueAttributePutItems = [];
        if (uniqueAttributes.length) {
            uniqueAttributePutItems = uniqueAttributes.map(attr => {
                const attributeValue = entity[attr.name];
                if (!attributeValue) {
                    throw new Error(`All unique attributes are required, Could not resolve value for unique attribute "${attr.name}."`);
                }
                if (!attr.unique) {
                    throw new Error('All unique attributes metadata must be marked unique.');
                }
                const uniqueItemPrimaryKey = this.getParsedPrimaryKey(table, attr.unique, entity);
                return {
                    Put: {
                        Item: uniqueItemPrimaryKey,
                        TableName: table.name,
                        ...uniqueRecordConditionExpression,
                    },
                };
            });
        }
        const uniqueAttributesPutItems = [
            { Put: dynamoPutItem },
            ...uniqueAttributePutItems,
        ];
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.PUT,
            prefix: 'After',
            entityName: name,
            primaryKey: null,
            body: uniqueAttributesPutItems,
        });
        return uniqueAttributesPutItems;
    }
    toDynamoGetItem(entityClass, primaryKey, options, metadataOptions) {
        const metadata = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.GET,
            prefix: 'Before',
            entityName: metadata.name,
            primaryKey,
        });
        const tableName = this.getTableNameForEntity(entityClass);
        const parsedPrimaryKey = this.getParsedPrimaryKey(metadata.table, metadata.schema.primaryKey, primaryKey);
        if (isEmptyObject(parsedPrimaryKey)) {
            throw new Error('Primary could not be resolved');
        }
        let transformBody = {
            TableName: tableName,
            Key: {
                ...parsedPrimaryKey,
            },
            ConsistentRead: options?.consistentRead,
            ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
        };
        // if restricted item projection was requested
        if (options?.select?.length) {
            const projection = this.expressionInputParser.parseToProjection(options.select);
            if (!projection) {
                throw new Error(`Failed to build projection expression for input: ${JSON.stringify(options.select)}`);
            }
            const { ProjectionExpression, ExpressionAttributeNames } = this.expressionBuilder.buildProjectionExpression(projection);
            transformBody = {
                ...transformBody,
                ProjectionExpression,
                ExpressionAttributeNames: {
                    ...transformBody.ExpressionAttributeNames,
                    ...ExpressionAttributeNames,
                },
            };
        }
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.GET,
            prefix: 'After',
            entityName: metadata.name,
            primaryKey: null,
            body: transformBody,
        });
        return transformBody;
    }
    toDynamoUpdateItem(entityClass, primaryKeyAttributes, body, options = {}, metadataOptions) {
        // default values
        const { nestedKeySeparator = '.' } = options;
        if (!this.connection.hasMetadata(entityClass)) {
            throw new Error(`No metadata found for class "${entityClass.name}".`);
        }
        const metadata = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.UPDATE,
            prefix: 'Before',
            entityName: metadata.name,
            primaryKey: primaryKeyAttributes,
            body,
            options,
        });
        const tableName = metadata.table.name;
        // FIXME: correctly apply decorated transformations on the primary key attributes
        // apply class transformation on attributes before further processing
        // primaryKeyAttributes = this.applyClassTransformerFormations(
        //   primaryKeyAttributes
        // ) as PrimaryKey;
        const parsedPrimaryKey = this.getParsedPrimaryKey(metadata.table, metadata.schema.primaryKey, primaryKeyAttributes);
        if (isEmptyObject(parsedPrimaryKey)) {
            throw new Error('Primary could not be resolved');
        }
        // get all the attributes for entity that are marked as to be auto update
        const autoUpdateAttributes = this.connection.getAutoUpdateAttributes(entityClass);
        // check if auto update attributes are not referenced by primary key
        const formattedAutoUpdateAttributes = autoUpdateAttributes.reduce((acc, attr) => {
            acc[attr.name] = autoGenerateValue(attr.strategy);
            return acc;
        }, {});
        const rawAttributesToUpdate = {
            ...body,
            ...formattedAutoUpdateAttributes,
        };
        /**
         * 1.0 - analyze attributes' value type (static/dynamic)
         *
         * Here we parse all attributes to it's update value and determine
         * if it's value can be statically inferred
         * and also omit all attributes
         * from body that has the same defined in primary key
         *
         */
        const staticOrDynamicUpdateAttributesWithMetadata = Object.entries({
            ...rawAttributesToUpdate,
        }).reduce((acc, [attrName, attrValue]) => {
            const valueWithType = this.expressionInputParser.parseAttributeToUpdateValue(attrName, attrValue);
            acc.transformed[attrName] = valueWithType.value;
            acc.typeMetadata[attrName] = valueWithType.type;
            return acc;
        }, { transformed: {}, typeMetadata: {} });
        /**
         * 2.0 - apply custom class transformation on static attributes
         *
         * we manually need to replace the constructor of the attributes to update
         * with the entity class, so that we can pass it through to class-transformer
         * to have all transformer metadata applied.
         */
        const onlyStaticAttributes = Object.entries(staticOrDynamicUpdateAttributesWithMetadata.transformed).reduce((acc, [attrKey, attrValue]) => {
            if (staticOrDynamicUpdateAttributesWithMetadata.typeMetadata[attrKey] ===
                'static') {
                acc[attrKey] = attrValue;
            }
            return acc;
        }, {});
        onlyStaticAttributes.constructor = entityClass;
        const classTransformedStaticAttributes = this.applyClassTransformerFormations(onlyStaticAttributes);
        staticOrDynamicUpdateAttributesWithMetadata.transformed = {
            ...staticOrDynamicUpdateAttributesWithMetadata.transformed,
            ...classTransformedStaticAttributes,
        };
        /**
         * 3.0 - Get referenced unique attributes and validate that current update body can be safely applied
         */
        const uniqueAttributesToUpdate = this.connection
            .getUniqueAttributesForEntity(entityClass)
            .filter(attr => !!body[attr.name])
            .map(attr => {
            // TODO: support updating unique attributes with dynamic exp
            // we can't allow updating unique attributes when they contain dynamic update value
            if (staticOrDynamicUpdateAttributesWithMetadata.typeMetadata[attr.name] === 'dynamic') {
                throw new InvalidDynamicUpdateAttributeValueError(attr.name, staticOrDynamicUpdateAttributesWithMetadata.transformed[attr.name]);
            }
            return attr;
        });
        /**
         * 3.1 - Get referenced primary key attributes and validate that current update body can be safely applied
         */
        const explicitAttributesToUpdate = Object.entries({
            ...staticOrDynamicUpdateAttributesWithMetadata.transformed,
        }).reduce((acc, [attrKey, attrValue]) => {
            // Attribute in Body that are in primary key attributes and have the do not require any updates
            if (primaryKeyAttributes[attrKey] !== attrValue) {
                acc[attrKey] = attrValue;
            }
            return acc;
        }, {});
        const affectedPrimaryKeyAttributes = this.getAffectedPrimaryKeyAttributes(entityClass, explicitAttributesToUpdate, staticOrDynamicUpdateAttributesWithMetadata.typeMetadata, {
            additionalAttributesDict: staticOrDynamicUpdateAttributesWithMetadata.transformed,
        });
        // validate primary key attributes
        if (!isEmptyObject(affectedPrimaryKeyAttributes)) {
            // updates are not allowed for attributes that unique and also references primary key.
            if (uniqueAttributesToUpdate.length) {
                throw new InvalidUniqueAttributeUpdateError(affectedPrimaryKeyAttributes, uniqueAttributesToUpdate.map(attr => attr.name));
            }
        }
        /**
         * 3.2 - Get referenced indexes' attributes and validate that current update body can be safely applied
         */
        const affectedIndexes = this.getAffectedIndexesForAttributes(entityClass, staticOrDynamicUpdateAttributesWithMetadata.transformed, staticOrDynamicUpdateAttributesWithMetadata.typeMetadata, {
            nestedKeySeparator,
            additionalAttributesDict: {
                ...primaryKeyAttributes,
            },
        });
        /**
         * 4.0 - Build update Item body with given condition and options
         */
        const itemToUpdate = {
            TableName: tableName,
            Key: {
                ...parsedPrimaryKey,
            },
            ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            // request all new attributes
            ReturnValues: RETURN_VALUES.ALL_NEW,
        };
        /**
         * 4.1 - if 'where' was provided, build condition expression
         */
        if (options.where && !isEmptyObject(options.where)) {
            const condition = this.expressionInputParser.parseToCondition(options.where);
            if (!condition) {
                throw new Error(`Failed to build condition expression for input: ${JSON.stringify(options.where)}`);
            }
            const { ConditionExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildConditionExpression(condition);
            // append condition expression if one was built
            itemToUpdate.ConditionExpression = ConditionExpression;
            itemToUpdate.ExpressionAttributeNames = {
                ...ExpressionAttributeNames,
                ...itemToUpdate.ExpressionAttributeNames,
            };
            itemToUpdate.ExpressionAttributeValues = {
                ...ExpressionAttributeValues,
                ...itemToUpdate.ExpressionAttributeValues,
            };
        }
        /**
         * 5.0 - update contains primary key attributes so it must be lazily updated
         * This requires deleting old item and writing new item to the table both in a transaction
         */
        if (isObject(affectedPrimaryKeyAttributes) &&
            !isEmptyObject(affectedPrimaryKeyAttributes)) {
            const lazyLoadTransactionWriteItems = this.lazyToDynamoUpdatePrimaryKeyFactory(metadata.table, metadata.name, metadata.schema.primaryKey, {
                Item: {
                    ...affectedPrimaryKeyAttributes,
                    ...affectedIndexes,
                    ...staticOrDynamicUpdateAttributesWithMetadata.transformed,
                },
                TableName: metadata.table.name,
                ReturnConsumedCapacity: itemToUpdate.ReturnConsumedCapacity,
                ReturnValues: itemToUpdate.ReturnValues,
                ConditionExpression: itemToUpdate.ConditionExpression,
                ExpressionAttributeNames: itemToUpdate.ExpressionAttributeNames,
                ExpressionAttributeValues: itemToUpdate.ExpressionAttributeValues,
            }, metadataOptions);
            return {
                primaryKeyAttributes,
                entityClass,
                lazyLoadTransactionWriteItems,
            };
        }
        /**
         * 5.0.1 - build update expression with user provided body and all other auto transformation
         */
        const update = this.expressionInputParser.parseToUpdate({
            ...rawAttributesToUpdate,
            ...affectedIndexes,
        }, staticOrDynamicUpdateAttributesWithMetadata.transformed);
        const { UpdateExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildUpdateExpression(update);
        itemToUpdate.UpdateExpression = UpdateExpression;
        itemToUpdate.ExpressionAttributeNames = {
            ...ExpressionAttributeNames,
            ...itemToUpdate.ExpressionAttributeNames,
        };
        itemToUpdate.ExpressionAttributeValues = {
            ...ExpressionAttributeValues,
            ...itemToUpdate.ExpressionAttributeValues,
        };
        /**
         * 5.1 - Update contains unique attributes, build a lazy unique attributes loader and return
         */
        if (uniqueAttributesToUpdate.length) {
            // if there are unique attributes, return a lazy loader, which will return write item list
            const lazyLoadTransactionWriteItems = this.lazyToDynamoUpdateUniqueItemFactory(metadata.table, metadata.name, uniqueAttributesToUpdate, dropProp(itemToUpdate, 'ReturnValues'), staticOrDynamicUpdateAttributesWithMetadata.transformed, metadataOptions);
            return {
                primaryKeyAttributes,
                entityClass,
                lazyLoadTransactionWriteItems,
            };
        }
        /**
         * 5.2 - return simple update body
         */
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.UPDATE,
            prefix: 'After',
            entityName: metadata.name,
            primaryKey: null,
            body: itemToUpdate,
        });
        return itemToUpdate;
    }
    toDynamoDeleteItem(entityClass, primaryKey, options, metadataOptions) {
        const metadata = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.DELETE,
            prefix: 'Before',
            entityName: metadata.name,
            primaryKey,
        });
        const tableName = metadata.table.name;
        const parsedPrimaryKey = this.getParsedPrimaryKey(metadata.table, metadata.schema.primaryKey, primaryKey);
        if (isEmptyObject(parsedPrimaryKey)) {
            throw new Error('Primary could not be resolved');
        }
        const uniqueAttributesToRemove = this.connection.getUniqueAttributesForEntity(entityClass);
        const mainItemToRemove = {
            TableName: tableName,
            Key: {
                ...parsedPrimaryKey,
            },
            ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
        };
        if (options?.where && !isEmptyObject(options.where)) {
            const condition = this.expressionInputParser.parseToCondition(options?.where);
            if (!condition) {
                throw new Error(`Failed to build condition expression for input: ${JSON.stringify(options?.where)}`);
            }
            const { ConditionExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildConditionExpression(condition);
            mainItemToRemove.ConditionExpression = ConditionExpression;
            mainItemToRemove.ExpressionAttributeNames = {
                ...mainItemToRemove.ExpressionAttributeNames,
                ...ExpressionAttributeNames,
            };
            mainItemToRemove.ExpressionAttributeValues = {
                ...mainItemToRemove.ExpressionAttributeValues,
                ...ExpressionAttributeValues,
            };
        }
        if (!uniqueAttributesToRemove?.length) {
            // if item does not have any unique attributes return it as is
            this.connection.logger.logTransform({
                requestId: metadataOptions?.requestId,
                operation: TRANSFORM_TYPE.DELETE,
                prefix: 'After',
                entityName: metadata.name,
                primaryKey,
            });
            return mainItemToRemove;
        }
        // or return lazy resolver
        const lazyLoadTransactionWriteItems = this.lazyToDynamoRemoveItemFactory(metadata.table, metadata.name, uniqueAttributesToRemove, mainItemToRemove, metadataOptions);
        return {
            primaryKeyAttributes: primaryKey,
            entityClass,
            lazyLoadTransactionWriteItems,
        };
    }
    toDynamoQueryItem(entityClass, partitionKeyAttributes, queryOptions, metadataOptions) {
        const { table, schema, name } = this.connection.getEntityByTarget(entityClass);
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.QUERY,
            prefix: 'Before',
            entityName: name,
            primaryKey: partitionKeyAttributes,
            options: queryOptions,
        });
        const queryIndexName = queryOptions?.queryIndex;
        let indexToQuery;
        if (queryIndexName) {
            const matchingIndex = table.getIndexByKey(queryIndexName);
            if (!matchingIndex) {
                throw new NoSuchIndexFoundError(table.name, queryIndexName);
            }
            const matchingIndexOnEntity = schema.indexes && schema.indexes[queryIndexName];
            if (!matchingIndexOnEntity) {
                throw new Error(`Requested to query items from index "${queryIndexName}", but no such index exists on entity.`);
            }
            indexToQuery = matchingIndex;
        }
        // query will be executed against main table or
        // if querying local  index, then partition key will be same as main table
        const parsedPartitionKey = {};
        if (!queryIndexName ||
            !indexToQuery ||
            indexToQuery?.type === INDEX_TYPE.LSI) {
            parsedPartitionKey.name = table.partitionKey;
            parsedPartitionKey.value =
                typeof partitionKeyAttributes === 'string'
                    ? partitionKeyAttributes
                    : parseKey(schema.primaryKey.attributes[table.partitionKey], partitionKeyAttributes);
        }
        else {
            // query is to be executed against global secondary index
            parsedPartitionKey.name = indexToQuery.partitionKey;
            const schemaForIndexToQuery = (schema.indexes ?? {})[queryIndexName];
            parsedPartitionKey.value =
                typeof partitionKeyAttributes === 'string'
                    ? partitionKeyAttributes
                    : parseKey(schemaForIndexToQuery.attributes[indexToQuery.partitionKey], partitionKeyAttributes);
        }
        const partitionKeyCondition = new KeyCondition().equals(parsedPartitionKey.name, parsedPartitionKey.value);
        const partitionKeyConditionExpression = this.expressionBuilder.buildKeyConditionExpression(partitionKeyCondition);
        const parsedSortKey = {};
        // if no we are not querying against index, validate if table is using composite key
        if (!indexToQuery) {
            if (!table.usesCompositeKey()) {
                throw new Error(`Table ${table.name} does not use composite key, thus querying a sort key is not allowed`);
            }
            parsedSortKey.name = table.sortKey;
        }
        else {
            parsedSortKey.name = indexToQuery.sortKey;
        }
        // at this point we have resolved partition key and table to query
        let queryInputParams = {
            TableName: table.name,
            IndexName: queryIndexName,
            ReturnConsumedCapacity: metadataOptions?.returnConsumedCapacity,
            ...partitionKeyConditionExpression,
        };
        if (queryOptions && !isEmptyObject(queryOptions)) {
            const { orderBy: order, limit, keyCondition, where, select, onlyCount, consistentRead, } = queryOptions;
            queryInputParams = {
                ...queryInputParams,
                Limit: limit,
                ConsistentRead: consistentRead,
            };
            if (order) {
                queryInputParams.ScanIndexForward = order === QUERY_ORDER.ASC;
            }
            // if key condition was provided
            if (keyCondition && !isEmptyObject(keyCondition)) {
                // build sort key condition
                const sortKeyCondition = this.expressionInputParser.parseToKeyCondition(parsedSortKey.name, keyCondition);
                // if condition resolution was successful, we can merge both partition and sort key conditions now
                const { KeyConditionExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildKeyConditionExpression(partitionKeyCondition.merge(sortKeyCondition));
                queryInputParams = {
                    ...queryInputParams,
                    KeyConditionExpression,
                    ExpressionAttributeNames: {
                        ...queryInputParams.ExpressionAttributeNames,
                        ...ExpressionAttributeNames,
                    },
                    ExpressionAttributeValues: {
                        ...queryInputParams.ExpressionAttributeValues,
                        ...ExpressionAttributeValues,
                    },
                };
            }
            // when filter conditions are given generate filter expression
            if (where && !isEmptyObject(where)) {
                const filter = this.expressionInputParser.parseToFilter(where);
                if (!filter) {
                    throw new InvalidFilterInputError(where);
                }
                const { FilterExpression, ExpressionAttributeNames, ExpressionAttributeValues, } = this.expressionBuilder.buildFilterExpression(filter);
                queryInputParams = {
                    ...queryInputParams,
                    FilterExpression,
                    ExpressionAttributeNames: {
                        ...queryInputParams.ExpressionAttributeNames,
                        ...ExpressionAttributeNames,
                    },
                    ExpressionAttributeValues: {
                        ...queryInputParams.ExpressionAttributeValues,
                        ...ExpressionAttributeValues,
                    },
                };
            }
            // check if only the count was requested
            if (onlyCount) {
                if (select?.length) {
                    throw new Error('Attributes projection and count can not be used together');
                }
                // count and projection selection can not be used together
                queryInputParams.Select = QUERY_SELECT_TYPE.COUNT;
            }
            // when projection keys are provided
            if (select && select.length) {
                const projection = this.expressionInputParser.parseToProjection(select);
                if (!projection) {
                    throw new InvalidSelectInputError(select);
                }
                const { ProjectionExpression, ExpressionAttributeNames } = this.expressionBuilder.buildProjectionExpression(projection);
                queryInputParams = {
                    ...queryInputParams,
                    ProjectionExpression,
                    ExpressionAttributeNames: {
                        ...queryInputParams.ExpressionAttributeNames,
                        ...ExpressionAttributeNames,
                    },
                };
            }
        }
        this.connection.logger.logTransform({
            requestId: metadataOptions?.requestId,
            operation: TRANSFORM_TYPE.QUERY,
            prefix: 'After',
            entityName: name,
            primaryKey: partitionKeyAttributes,
            body: queryInputParams,
        });
        return queryInputParams;
    }
    lazyToDynamoUpdatePrimaryKeyFactory(table, entityName, primaryKeySchema, newItemBody, metadataOptions) {
        return (previousItemBody) => {
            const updateTransactionItems = [
                {
                    Put: {
                        ...newItemBody,
                        // import existing current item
                        Item: { ...previousItemBody, ...newItemBody.Item },
                    },
                },
            ];
            // if there was a previous existing item, basically remove it as part of this transaction
            if (previousItemBody && !isEmptyObject(previousItemBody)) {
                updateTransactionItems.push({
                    Delete: {
                        TableName: table.name,
                        Key: {
                            ...this.getParsedPrimaryKey(table, primaryKeySchema, previousItemBody),
                        },
                    },
                });
            }
            this.connection.logger.logTransform({
                requestId: metadataOptions?.requestId,
                operation: TRANSFORM_TYPE.UPDATE,
                prefix: 'After',
                entityName,
                primaryKey: null,
                body: updateTransactionItems,
            });
            return updateTransactionItems;
        };
    }
    /**
     * Lazy build update item input
     * This is helpful in cases where we don't you have all the attributes to build item input, and the caller will need to
     * to perform some sort of async call in order to fetch attributes and proceed with build
     *
     */
    lazyToDynamoUpdateUniqueItemFactory(table, entityName, uniqueAttributesToUpdate, mainItem, newBody, metadataOptions) {
        // returns transact write item list
        return (previousItemBody) => {
            // updating unique attributes also require checking if new value exists
            const uniqueRecordConditionExpression = this.expressionBuilder.buildUniqueRecordConditionExpression(table);
            // map all unique attributes to [put, delete] item tuple
            const uniqueAttributeInputs = uniqueAttributesToUpdate.flatMap(attr => {
                const uniqueAttributeWriteItems = [
                    {
                        Put: {
                            TableName: table.name,
                            Item: {
                                ...this.getParsedPrimaryKey(table, attr.unique, newBody),
                            },
                            ...uniqueRecordConditionExpression,
                        },
                    },
                ];
                // if unique attribute previously existed, remove it as part of the same transaction
                if (previousItemBody && previousItemBody[attr.name]) {
                    uniqueAttributeWriteItems.push({
                        Delete: {
                            TableName: table.name,
                            Key: {
                                ...this.getParsedPrimaryKey(table, attr.unique, previousItemBody),
                            },
                        },
                    });
                }
                return uniqueAttributeWriteItems;
            });
            // in order for update express to succeed, all listed must succeed in a transaction
            const updateTransactionItems = [
                { Update: mainItem },
                ...uniqueAttributeInputs,
            ];
            this.connection.logger.logTransform({
                requestId: metadataOptions?.requestId,
                operation: TRANSFORM_TYPE.UPDATE,
                prefix: 'After',
                entityName,
                primaryKey: null,
                body: updateTransactionItems,
            });
            return updateTransactionItems;
        };
    }
    /**
     * lazily resolve all unique attribute items to remove
     * @param table
     * @param uniqueAttributesToRemove
     * @param mainItem
     */
    lazyToDynamoRemoveItemFactory(table, entityName, uniqueAttributesToRemove, mainItem, metadataOptions) {
        return (existingItemBody) => {
            let uniqueAttributeInputs = [];
            if (existingItemBody) {
                uniqueAttributeInputs = uniqueAttributesToRemove.map(attr => {
                    return {
                        Delete: {
                            TableName: table.name,
                            Key: {
                                ...this.getParsedPrimaryKey(table, attr.unique, existingItemBody),
                            },
                        },
                    };
                });
            }
            const deleteTransactionItems = [
                {
                    Delete: mainItem,
                },
                ...uniqueAttributeInputs,
            ];
            this.connection.logger.logTransform({
                requestId: metadataOptions?.requestId,
                operation: TRANSFORM_TYPE.DELETE,
                prefix: 'After',
                entityName,
                primaryKey: null,
                body: deleteTransactionItems,
            });
            return deleteTransactionItems;
        };
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9jdW1lbnQtY2xpZW50LXJlcXVlc3QtdHJhbnNmb3JtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9jbGFzc2VzL3RyYW5zZm9ybWVyL2RvY3VtZW50LWNsaWVudC1yZXF1ZXN0LXRyYW5zZm9ybWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCxVQUFVLEVBQ1YsV0FBVyxFQUVYLGFBQWEsRUFFYixjQUFjLEVBRWQsaUJBQWlCLEVBQ2pCLHFCQUFxQixFQUNyQix1QkFBdUIsRUFDdkIsdUJBQXVCLEVBQ3ZCLGlDQUFpQyxFQUNqQyx1Q0FBdUMsR0FDeEMsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDakQsT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sNENBQTRDLENBQUM7QUFDckYsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLCtCQUErQixDQUFDO0FBQzVELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUNqRCxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFFekQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sa0NBQWtDLENBQUM7QUFHbkUsT0FBTyxFQUFDLGVBQWUsRUFBa0IsTUFBTSxvQkFBb0IsQ0FBQztBQUlwRSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFFakQsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sNkNBQTZDLENBQUM7QUE4RDlFLE1BQU0sT0FBTyxnQ0FBaUMsU0FBUSxlQUFlO0lBQ3pELGtCQUFrQixDQUFvQjtJQUVoRCxZQUFZLFVBQXNCO1FBQ2hDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxpQkFB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NkMsRUFDN0MsZUFBaUM7UUFFakMsT0FBTyxDQUFDLGdCQUFxQixFQUFFLEVBQUU7WUFDL0IsSUFBSSxxQkFBcUIsR0FBOEMsRUFBRSxDQUFDO1lBQzFFLElBQUksZ0JBQWdCLEVBQUU7Z0JBQ3BCLHFCQUFxQixHQUFHLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtvQkFDMUQsT0FBTzt3QkFDTCxNQUFNLEVBQUU7NEJBQ04sU0FBUyxFQUFFLEtBQUssQ0FBQyxJQUFJOzRCQUNyQixHQUFHLEVBQUU7Z0NBQ0gsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQ3pCLEtBQUssRUFDTCxJQUFJLENBQUMsTUFBTSxFQUNYLGdCQUFnQixDQUNqQjs2QkFDRjt5QkFDRjtxQkFDRixDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUFDO2FBQ0o7WUFFRCxNQUFNLHNCQUFzQixHQUFHO2dCQUM3QjtvQkFDRSxNQUFNLEVBQUUsUUFBUTtpQkFDakI7Z0JBQ0QsR0FBRyxxQkFBcUI7YUFDb0IsQ0FBQztZQUUvQyxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUM7Z0JBQ2xDLFNBQVMsRUFBRSxlQUFlLEVBQUUsU0FBUztnQkFDckMsU0FBUyxFQUFFLGNBQWMsQ0FBQyxNQUFNO2dCQUNoQyxNQUFNLEVBQUUsT0FBTztnQkFDZixVQUFVO2dCQUNWLFVBQVUsRUFBRSxJQUFJO2dCQUNoQixJQUFJLEVBQUUsc0JBQXNCO2FBQzdCLENBQUMsQ0FBQztZQUVILE9BQU8sc0JBQXNCLENBQUM7UUFDaEMsQ0FBQyxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgRW50aXR5VGFyZ2V0LFxuICBJTkRFWF9UWVBFLFxuICBRVUVSWV9PUkRFUixcbiAgUmVwbGFjZSxcbiAgUkVUVVJOX1ZBTFVFUyxcbiAgVGFibGUsXG4gIFRSQU5TRk9STV9UWVBFLFxuICBJbmRleE9wdGlvbnMsXG4gIFFVRVJZX1NFTEVDVF9UWVBFLFxuICBOb1N1Y2hJbmRleEZvdW5kRXJyb3IsXG4gIEludmFsaWRGaWx0ZXJJbnB1dEVycm9yLFxuICBJbnZhbGlkU2VsZWN0SW5wdXRFcnJvcixcbiAgSW52YWxpZFVuaXF1ZUF0dHJpYnV0ZVVwZGF0ZUVycm9yLFxuICBJbnZhbGlkRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZVZhbHVlRXJyb3IsXG59IGZyb20gJ0B0eXBlZG9ybS9jb21tb24nO1xuaW1wb3J0IHtkcm9wUHJvcH0gZnJvbSAnLi4vLi4vaGVscGVycy9kcm9wLXByb3AnO1xuaW1wb3J0IHtnZXRDb25zdHJ1Y3RvckZvckluc3RhbmNlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2dldC1jb25zdHJ1Y3Rvci1mb3ItaW5zdGFuY2UnO1xuaW1wb3J0IHtpc0VtcHR5T2JqZWN0fSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLWVtcHR5LW9iamVjdCc7XG5pbXBvcnQge3BhcnNlS2V5fSBmcm9tICcuLi8uLi9oZWxwZXJzL3BhcnNlLWtleSc7XG5pbXBvcnQge0tleUNvbmRpdGlvbn0gZnJvbSAnLi4vZXhwcmVzc2lvbi9rZXktY29uZGl0aW9uJztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbi9jb25uZWN0aW9uJztcbmltcG9ydCB7RXhwcmVzc2lvbkJ1aWxkZXJ9IGZyb20gJy4uL2V4cHJlc3Npb24vZXhwcmVzc2lvbi1idWlsZGVyJztcbmltcG9ydCB7QXR0cmlidXRlTWV0YWRhdGF9IGZyb20gJy4uL21ldGFkYXRhL2F0dHJpYnV0ZS1tZXRhZGF0YSc7XG5pbXBvcnQge0R5bmFtb0VudGl0eVNjaGVtYVByaW1hcnlLZXl9IGZyb20gJy4uL21ldGFkYXRhL2VudGl0eS1tZXRhZGF0YSc7XG5pbXBvcnQge0Jhc2VUcmFuc2Zvcm1lciwgTWV0YWRhdGFPcHRpb25zfSBmcm9tICcuL2Jhc2UtdHJhbnNmb3JtZXInO1xuaW1wb3J0IHtMYXp5VHJhbnNhY3Rpb25Xcml0ZUl0ZW1MaXN0TG9hZGVyfSBmcm9tICcuL2lzLWxhenktdHJhbnNhY3Rpb24td3JpdGUtaXRlbS1saXN0LWxvYWRlcic7XG5pbXBvcnQge0tleUNvbmRpdGlvbk9wdGlvbnN9IGZyb20gJy4uL2V4cHJlc3Npb24va2V5LWNvbmRpdGlvbi1vcHRpb25zLXR5cGUnO1xuaW1wb3J0IHtVcGRhdGVCb2R5fSBmcm9tICcuLi9leHByZXNzaW9uL3VwZGF0ZS1ib2R5LXR5cGUnO1xuaW1wb3J0IHtpc09iamVjdH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1vYmplY3QnO1xuaW1wb3J0IHtEb2N1bWVudENsaWVudFR5cGVzfSBmcm9tICdAdHlwZWRvcm0vZG9jdW1lbnQtY2xpZW50JztcbmltcG9ydCB7YXV0b0dlbmVyYXRlVmFsdWV9IGZyb20gJy4uLy4uL2hlbHBlcnMvYXV0by1nZW5lcmF0ZS1hdHRyaWJ1dGUtdmFsdWUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZXJUb0R5bmFtb1B1dEl0ZW1PcHRpb25zIHtcbiAgLyoqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBvdmVyd3JpdGVJZkV4aXN0cz86IGJvb2xlYW47XG5cbiAgd2hlcmU/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlclRvRHluYW1vVXBkYXRlSXRlbXNPcHRpb25zIHtcbiAgLyoqXG4gICAqIGtleSBzZXBhcmF0b3JcbiAgICogQGRlZmF1bHQgJy4nJ1xuICAgKi9cbiAgbmVzdGVkS2V5U2VwYXJhdG9yPzogc3RyaW5nO1xuXG4gIHdoZXJlPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZXJUb0R5bmFtb0RlbGV0ZUl0ZW1zT3B0aW9ucyB7XG4gIHdoZXJlPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZXJUb0R5bmFtb1F1ZXJ5SXRlbXNPcHRpb25zIHtcbiAgLyoqXG4gICAqIEluZGV4IHRvIHF1ZXJ5LCB3aGVuIG9taXR0ZWQsIHF1ZXJ5IHdpbGwgYmUgcnVuIGFnYWluc3QgbWFpbiB0YWJsZVxuICAgKi9cbiAgcXVlcnlJbmRleD86IHN0cmluZztcbiAgLyoqXG4gICAqIFNvcnQga2V5IGNvbmRpdGlvblxuICAgKiBAZGVmYXVsdCBub25lIC0gbm8gc29ydCBrZXkgY29uZGl0aW9uIGlzIGFwcGxpZWRcbiAgICovXG4gIGtleUNvbmRpdGlvbj86IEtleUNvbmRpdGlvbk9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIE1heCBudW1iZXIgb2YgcmVjb3JkcyB0byBxdWVyeVxuICAgKiBAZGVmYXVsdCAtIGltcGxpY2l0IGR5bmFtbyBkYiBxdWVyeSBsaW1pdCBpcyBhcHBsaWVkXG4gICAqL1xuICBsaW1pdD86IG51bWJlcjtcblxuICAvKipcbiAgICogT3JkZXIgdG8gcXVlcnkgaXRlbXMgaW5cbiAgICogQGRlZmF1bHQgQVNDXG4gICAqL1xuICBvcmRlckJ5PzogUVVFUllfT1JERVI7XG5cbiAgd2hlcmU/OiBhbnk7XG5cbiAgc2VsZWN0PzogYW55W107XG5cbiAgb25seUNvdW50PzogYm9vbGVhbjtcblxuICBjb25zaXN0ZW50UmVhZD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlclRvRHluYW1vR2V0SXRlbU9wdGlvbnMge1xuICBzZWxlY3Q/OiBhbnlbXTtcbiAgY29uc2lzdGVudFJlYWQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgRG9jdW1lbnRDbGllbnRSZXF1ZXN0VHJhbnNmb3JtZXIgZXh0ZW5kcyBCYXNlVHJhbnNmb3JtZXIge1xuICBwcm90ZWN0ZWQgX2V4cHJlc3Npb25CdWlsZGVyOiBFeHByZXNzaW9uQnVpbGRlcjtcblxuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uOiBDb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbik7XG4gICAgdGhpcy5fZXhwcmVzc2lvbkJ1aWxkZXIgPSBuZXcgRXhwcmVzc2lvbkJ1aWxkZXIoKTtcbiAgfVxuXG4gIGdldCBleHByZXNzaW9uQnVpbGRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZXhwcmVzc2lvbkJ1aWxkZXI7XG4gIH1cblxuICBnZXQgZXhwcmVzc2lvbklucHV0UGFyc2VyKCkge1xuICAgIHJldHVybiB0aGlzLl9leHByZXNzaW9uSW5wdXRQYXJzZXI7XG4gIH1cblxuICB0b0R5bmFtb1B1dEl0ZW08RW50aXR5PihcbiAgICBlbnRpdHk6IEVudGl0eSxcbiAgICBvcHRpb25zPzogTWFuYWdlclRvRHluYW1vUHV0SXRlbU9wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6XG4gICAgfCBEb2N1bWVudENsaWVudFR5cGVzLlB1dEl0ZW1JbnB1dFxuICAgIHwgRG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbUxpc3Qge1xuICAgIGNvbnN0IGVudGl0eUNsYXNzID0gZ2V0Q29uc3RydWN0b3JGb3JJbnN0YW5jZShlbnRpdHkpO1xuICAgIGNvbnN0IHt0YWJsZSwgaW50ZXJuYWxBdHRyaWJ1dGVzLCBuYW1lfSA9XG4gICAgICB0aGlzLmNvbm5lY3Rpb24uZ2V0RW50aXR5QnlUYXJnZXQoZW50aXR5Q2xhc3MpO1xuXG4gICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgIG9wZXJhdGlvbjogVFJBTlNGT1JNX1RZUEUuUFVULFxuICAgICAgcHJlZml4OiAnQmVmb3JlJyxcbiAgICAgIGVudGl0eU5hbWU6IG5hbWUsXG4gICAgICBwcmltYXJ5S2V5OiBudWxsLFxuICAgICAgYm9keTogZW50aXR5LFxuICAgICAgb3B0aW9ucyxcbiAgICB9KTtcblxuICAgIGNvbnN0IHVuaXF1ZUF0dHJpYnV0ZXMgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0VW5pcXVlQXR0cmlidXRlc0ZvckVudGl0eShcbiAgICAgIGVudGl0eUNsYXNzXG4gICAgKSBhcyBBdHRyaWJ1dGVNZXRhZGF0YVtdO1xuXG4gICAgLy8gaW5jbHVkZSBhdHRyaWJ1dGVzIHdpdGggZGVmYXVsdCB2YWx1ZXMgaW5cbiAgICBjb25zdCBkeW5hbW9FbnRpdHkgPSB0aGlzLnRvRHluYW1vRW50aXR5KGVudGl0eSk7XG5cbiAgICBjb25zdCBlbnRpdHlJbnRlcm5hbEF0dHJpYnV0ZXMgPSBpbnRlcm5hbEF0dHJpYnV0ZXMucmVkdWNlKChhY2MsIGF0dHIpID0+IHtcbiAgICAgIGFjY1thdHRyLm5hbWVdID0gYXR0ci52YWx1ZTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30gYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5BdHRyaWJ1dGVNYXApO1xuXG4gICAgbGV0IGR5bmFtb1B1dEl0ZW0gPSB7XG4gICAgICBJdGVtOiB7XG4gICAgICAgIC4uLmVudGl0eUludGVybmFsQXR0cmlidXRlcyxcbiAgICAgICAgLi4uZHluYW1vRW50aXR5LFxuICAgICAgfSxcbiAgICAgIFRhYmxlTmFtZTogdGFibGUubmFtZSxcbiAgICAgIFJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICB9IGFzIERvY3VtZW50Q2xpZW50VHlwZXMuUHV0SXRlbUlucHV0O1xuXG4gICAgLy8gYXBwbHkgYXR0cmlidXRlIG5vdCBleGlzdCBjb25kaXRpb24gd2hlbiBjcmVhdGluZyB1bmlxdWVcbiAgICBjb25zdCB1bmlxdWVSZWNvcmRDb25kaXRpb25FeHByZXNzaW9uID1cbiAgICAgIHRoaXMuZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGRVbmlxdWVSZWNvcmRDb25kaXRpb25FeHByZXNzaW9uKHRhYmxlKTtcblxuICAgIC8vIGFsd2F5cyBwcmV2ZW50IG92ZXJ3cml0aW5nIGRhdGEgdW50aWwgZXhwbGljaXRseSB0b2xkIHRvIGRvIG90aGVyd2lzZVxuICAgIGlmICghb3B0aW9ucz8ub3ZlcndyaXRlSWZFeGlzdHMpIHtcbiAgICAgIGR5bmFtb1B1dEl0ZW0gPSB7XG4gICAgICAgIC4uLmR5bmFtb1B1dEl0ZW0sXG4gICAgICAgIC4uLnVuaXF1ZVJlY29yZENvbmRpdGlvbkV4cHJlc3Npb24sXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIGB3aGVyZWAgY29uZGl0aW9uIG9wdGlvbnMgZXhpc3RzLCBidWlsZCBjb25kaXRpb24gZXhwcmVzc2lvblxuICAgIGlmIChvcHRpb25zPy53aGVyZSAmJiAhaXNFbXB0eU9iamVjdChvcHRpb25zPy53aGVyZSkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHRoaXMuZXhwcmVzc2lvbklucHV0UGFyc2VyLnBhcnNlVG9Db25kaXRpb24oXG4gICAgICAgIG9wdGlvbnM/LndoZXJlXG4gICAgICApO1xuXG4gICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYEZhaWxlZCB0byBidWlsZCBjb25kaXRpb24gZXhwcmVzc2lvbiBmb3IgaW5wdXQ6ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBvcHRpb25zPy53aGVyZVxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIENvbmRpdGlvbkV4cHJlc3Npb24sXG4gICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgIH0gPSB0aGlzLmV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkQ29uZGl0aW9uRXhwcmVzc2lvbihjb25kaXRpb24pO1xuXG4gICAgICAvLyBieSBkZWZhdWx0LCBlbnRpdHkgbWFuZ2VyIGFwcGVuZHMgdW5pcXVlIHJlY29yZCBjb25kaXRpb24gZXhwcmVzc2lvbiB0byBhdm9pZCBvdmVyd3JpdGluZyBpdGVtcyBpZiB0aGV5IGFscmVhZHkgZXhpc3RcbiAgICAgIC8vIHNvIGhhbmRsZSB0aGF0XG4gICAgICBjb25zdCBtZXJnZWRFeHAgPSB0aGlzLl9leHByZXNzaW9uQnVpbGRlci5hbmRNZXJnZUNvbmRpdGlvbkV4cHJlc3Npb25zKFxuICAgICAgICB7XG4gICAgICAgICAgQ29uZGl0aW9uRXhwcmVzc2lvbjogZHluYW1vUHV0SXRlbS5Db25kaXRpb25FeHByZXNzaW9uLFxuICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczogZHluYW1vUHV0SXRlbS5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczogZHluYW1vUHV0SXRlbS5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgQ29uZGl0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgICAgfVxuICAgICAgKTtcblxuICAgICAgZHluYW1vUHV0SXRlbS5Db25kaXRpb25FeHByZXNzaW9uID0gbWVyZ2VkRXhwLkNvbmRpdGlvbkV4cHJlc3Npb247XG4gICAgICBkeW5hbW9QdXRJdGVtLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyA9XG4gICAgICAgIG1lcmdlZEV4cC5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXM7XG4gICAgICBkeW5hbW9QdXRJdGVtLkV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMgPVxuICAgICAgICBtZXJnZWRFeHAuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcztcbiAgICB9XG5cbiAgICAvLyBubyB1bmlxdWUgYXR0cmlidXRlcyBleGlzdCwgc28gcmV0dXJuIGVhcmx5XG4gICAgaWYgKCF1bmlxdWVBdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLlBVVCxcbiAgICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgICBlbnRpdHlOYW1lOiBuYW1lLFxuICAgICAgICBwcmltYXJ5S2V5OiBudWxsLFxuICAgICAgICBib2R5OiBkeW5hbW9QdXRJdGVtLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBkeW5hbW9QdXRJdGVtO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGFyZSB1bmlxdWUgYXR0cmlidXRlcywgcmV0dXJuIHRyYW5zYWN0aW9uIGxpc3QgaXRlbVxuICAgIGxldCB1bmlxdWVBdHRyaWJ1dGVQdXRJdGVtczogRG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbUxpc3QgPSBbXTtcbiAgICBpZiAodW5pcXVlQXR0cmlidXRlcy5sZW5ndGgpIHtcbiAgICAgIHVuaXF1ZUF0dHJpYnV0ZVB1dEl0ZW1zID0gdW5pcXVlQXR0cmlidXRlcy5tYXAoYXR0ciA9PiB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZVZhbHVlID0gKGVudGl0eSBhcyBhbnkpW2F0dHIubmFtZV07XG5cbiAgICAgICAgaWYgKCFhdHRyaWJ1dGVWYWx1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBBbGwgdW5pcXVlIGF0dHJpYnV0ZXMgYXJlIHJlcXVpcmVkLCBDb3VsZCBub3QgcmVzb2x2ZSB2YWx1ZSBmb3IgdW5pcXVlIGF0dHJpYnV0ZSBcIiR7YXR0ci5uYW1lfS5cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFhdHRyLnVuaXF1ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdBbGwgdW5pcXVlIGF0dHJpYnV0ZXMgbWV0YWRhdGEgbXVzdCBiZSBtYXJrZWQgdW5pcXVlLidcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pcXVlSXRlbVByaW1hcnlLZXkgPSB0aGlzLmdldFBhcnNlZFByaW1hcnlLZXk8RW50aXR5PihcbiAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICBhdHRyLnVuaXF1ZSxcbiAgICAgICAgICBlbnRpdHlcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFB1dDoge1xuICAgICAgICAgICAgSXRlbTogdW5pcXVlSXRlbVByaW1hcnlLZXksXG4gICAgICAgICAgICBUYWJsZU5hbWU6IHRhYmxlLm5hbWUsXG4gICAgICAgICAgICAuLi51bmlxdWVSZWNvcmRDb25kaXRpb25FeHByZXNzaW9uLFxuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1bmlxdWVBdHRyaWJ1dGVzUHV0SXRlbXMgPSBbXG4gICAgICB7UHV0OiBkeW5hbW9QdXRJdGVtfSxcbiAgICAgIC4uLnVuaXF1ZUF0dHJpYnV0ZVB1dEl0ZW1zLFxuICAgIF07XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1RyYW5zZm9ybSh7XG4gICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5QVVQsXG4gICAgICBwcmVmaXg6ICdBZnRlcicsXG4gICAgICBlbnRpdHlOYW1lOiBuYW1lLFxuICAgICAgcHJpbWFyeUtleTogbnVsbCxcbiAgICAgIGJvZHk6IHVuaXF1ZUF0dHJpYnV0ZXNQdXRJdGVtcyxcbiAgICB9KTtcblxuICAgIHJldHVybiB1bmlxdWVBdHRyaWJ1dGVzUHV0SXRlbXM7XG4gIH1cblxuICB0b0R5bmFtb0dldEl0ZW08RW50aXR5LCBQcmltYXJ5S2V5PihcbiAgICBlbnRpdHlDbGFzczogRW50aXR5VGFyZ2V0PEVudGl0eT4sXG4gICAgcHJpbWFyeUtleTogUHJpbWFyeUtleSxcbiAgICBvcHRpb25zPzogTWFuYWdlclRvRHluYW1vR2V0SXRlbU9wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6IERvY3VtZW50Q2xpZW50VHlwZXMuR2V0SXRlbUlucHV0IHtcbiAgICBjb25zdCBtZXRhZGF0YSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1RyYW5zZm9ybSh7XG4gICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5HRVQsXG4gICAgICBwcmVmaXg6ICdCZWZvcmUnLFxuICAgICAgZW50aXR5TmFtZTogbWV0YWRhdGEubmFtZSxcbiAgICAgIHByaW1hcnlLZXksXG4gICAgfSk7XG5cbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLmdldFRhYmxlTmFtZUZvckVudGl0eShlbnRpdHlDbGFzcyk7XG5cbiAgICBjb25zdCBwYXJzZWRQcmltYXJ5S2V5ID0gdGhpcy5nZXRQYXJzZWRQcmltYXJ5S2V5PFByaW1hcnlLZXk+KFxuICAgICAgbWV0YWRhdGEudGFibGUsXG4gICAgICBtZXRhZGF0YS5zY2hlbWEucHJpbWFyeUtleSxcbiAgICAgIHByaW1hcnlLZXlcbiAgICApO1xuXG4gICAgaWYgKGlzRW1wdHlPYmplY3QocGFyc2VkUHJpbWFyeUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWFyeSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQnKTtcbiAgICB9XG5cbiAgICBsZXQgdHJhbnNmb3JtQm9keSA9IHtcbiAgICAgIFRhYmxlTmFtZTogdGFibGVOYW1lLFxuICAgICAgS2V5OiB7XG4gICAgICAgIC4uLnBhcnNlZFByaW1hcnlLZXksXG4gICAgICB9LFxuICAgICAgQ29uc2lzdGVudFJlYWQ6IG9wdGlvbnM/LmNvbnNpc3RlbnRSZWFkLFxuICAgICAgUmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgIH0gYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5HZXRJdGVtSW5wdXQ7XG5cbiAgICAvLyBpZiByZXN0cmljdGVkIGl0ZW0gcHJvamVjdGlvbiB3YXMgcmVxdWVzdGVkXG4gICAgaWYgKG9wdGlvbnM/LnNlbGVjdD8ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwcm9qZWN0aW9uID0gdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VUb1Byb2plY3Rpb24oXG4gICAgICAgIG9wdGlvbnMuc2VsZWN0XG4gICAgICApO1xuXG4gICAgICBpZiAoIXByb2plY3Rpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gYnVpbGQgcHJvamVjdGlvbiBleHByZXNzaW9uIGZvciBpbnB1dDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIG9wdGlvbnMuc2VsZWN0XG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtQcm9qZWN0aW9uRXhwcmVzc2lvbiwgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzfSA9XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGRQcm9qZWN0aW9uRXhwcmVzc2lvbihwcm9qZWN0aW9uKTtcblxuICAgICAgdHJhbnNmb3JtQm9keSA9IHtcbiAgICAgICAgLi4udHJhbnNmb3JtQm9keSxcbiAgICAgICAgUHJvamVjdGlvbkV4cHJlc3Npb24sXG4gICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczoge1xuICAgICAgICAgIC4uLnRyYW5zZm9ybUJvZHkuRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgIG9wZXJhdGlvbjogVFJBTlNGT1JNX1RZUEUuR0VULFxuICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgZW50aXR5TmFtZTogbWV0YWRhdGEubmFtZSxcbiAgICAgIHByaW1hcnlLZXk6IG51bGwsXG4gICAgICBib2R5OiB0cmFuc2Zvcm1Cb2R5LFxuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Cb2R5O1xuICB9XG5cbiAgdG9EeW5hbW9VcGRhdGVJdGVtPFxuICAgIEVudGl0eSxcbiAgICBQcmltYXJ5S2V5ID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgQWRkaXRpb25hbFByb3BlcnRpZXMgPSBFbnRpdHlcbiAgPihcbiAgICBlbnRpdHlDbGFzczogRW50aXR5VGFyZ2V0PEVudGl0eT4sXG4gICAgcHJpbWFyeUtleUF0dHJpYnV0ZXM6IFByaW1hcnlLZXksXG4gICAgYm9keTogVXBkYXRlQm9keTxFbnRpdHksIEFkZGl0aW9uYWxQcm9wZXJ0aWVzPixcbiAgICBvcHRpb25zOiBNYW5hZ2VyVG9EeW5hbW9VcGRhdGVJdGVtc09wdGlvbnMgPSB7fSxcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKTogRG9jdW1lbnRDbGllbnRUeXBlcy5VcGRhdGVJdGVtSW5wdXQgfCBMYXp5VHJhbnNhY3Rpb25Xcml0ZUl0ZW1MaXN0TG9hZGVyIHtcbiAgICAvLyBkZWZhdWx0IHZhbHVlc1xuICAgIGNvbnN0IHtuZXN0ZWRLZXlTZXBhcmF0b3IgPSAnLid9ID0gb3B0aW9ucztcblxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uLmhhc01ldGFkYXRhKGVudGl0eUNsYXNzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBtZXRhZGF0YSBmb3VuZCBmb3IgY2xhc3MgXCIke2VudGl0eUNsYXNzLm5hbWV9XCIuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0RW50aXR5QnlUYXJnZXQoZW50aXR5Q2xhc3MpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLlVQREFURSxcbiAgICAgIHByZWZpeDogJ0JlZm9yZScsXG4gICAgICBlbnRpdHlOYW1lOiBtZXRhZGF0YS5uYW1lLFxuICAgICAgcHJpbWFyeUtleTogcHJpbWFyeUtleUF0dHJpYnV0ZXMsXG4gICAgICBib2R5LFxuICAgICAgb3B0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSBtZXRhZGF0YS50YWJsZS5uYW1lO1xuXG4gICAgLy8gRklYTUU6IGNvcnJlY3RseSBhcHBseSBkZWNvcmF0ZWQgdHJhbnNmb3JtYXRpb25zIG9uIHRoZSBwcmltYXJ5IGtleSBhdHRyaWJ1dGVzXG4gICAgLy8gYXBwbHkgY2xhc3MgdHJhbnNmb3JtYXRpb24gb24gYXR0cmlidXRlcyBiZWZvcmUgZnVydGhlciBwcm9jZXNzaW5nXG4gICAgLy8gcHJpbWFyeUtleUF0dHJpYnV0ZXMgPSB0aGlzLmFwcGx5Q2xhc3NUcmFuc2Zvcm1lckZvcm1hdGlvbnMoXG4gICAgLy8gICBwcmltYXJ5S2V5QXR0cmlidXRlc1xuICAgIC8vICkgYXMgUHJpbWFyeUtleTtcblxuICAgIGNvbnN0IHBhcnNlZFByaW1hcnlLZXkgPSB0aGlzLmdldFBhcnNlZFByaW1hcnlLZXk8UHJpbWFyeUtleT4oXG4gICAgICBtZXRhZGF0YS50YWJsZSxcbiAgICAgIG1ldGFkYXRhLnNjaGVtYS5wcmltYXJ5S2V5LFxuICAgICAgcHJpbWFyeUtleUF0dHJpYnV0ZXNcbiAgICApO1xuXG4gICAgaWYgKGlzRW1wdHlPYmplY3QocGFyc2VkUHJpbWFyeUtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWFyeSBjb3VsZCBub3QgYmUgcmVzb2x2ZWQnKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgYWxsIHRoZSBhdHRyaWJ1dGVzIGZvciBlbnRpdHkgdGhhdCBhcmUgbWFya2VkIGFzIHRvIGJlIGF1dG8gdXBkYXRlXG4gICAgY29uc3QgYXV0b1VwZGF0ZUF0dHJpYnV0ZXMgPVxuICAgICAgdGhpcy5jb25uZWN0aW9uLmdldEF1dG9VcGRhdGVBdHRyaWJ1dGVzKGVudGl0eUNsYXNzKTtcblxuICAgIC8vIGNoZWNrIGlmIGF1dG8gdXBkYXRlIGF0dHJpYnV0ZXMgYXJlIG5vdCByZWZlcmVuY2VkIGJ5IHByaW1hcnkga2V5XG4gICAgY29uc3QgZm9ybWF0dGVkQXV0b1VwZGF0ZUF0dHJpYnV0ZXMgPSBhdXRvVXBkYXRlQXR0cmlidXRlcy5yZWR1Y2UoXG4gICAgICAoYWNjLCBhdHRyKSA9PiB7XG4gICAgICAgIGFjY1thdHRyLm5hbWVdID0gYXV0b0dlbmVyYXRlVmFsdWUoYXR0ci5zdHJhdGVneSk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgICB9LFxuICAgICAge30gYXMge1trZXk6IHN0cmluZ106IGFueX1cbiAgICApO1xuXG4gICAgY29uc3QgcmF3QXR0cmlidXRlc1RvVXBkYXRlID0ge1xuICAgICAgLi4uYm9keSxcbiAgICAgIC4uLmZvcm1hdHRlZEF1dG9VcGRhdGVBdHRyaWJ1dGVzLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAxLjAgLSBhbmFseXplIGF0dHJpYnV0ZXMnIHZhbHVlIHR5cGUgKHN0YXRpYy9keW5hbWljKVxuICAgICAqXG4gICAgICogSGVyZSB3ZSBwYXJzZSBhbGwgYXR0cmlidXRlcyB0byBpdCdzIHVwZGF0ZSB2YWx1ZSBhbmQgZGV0ZXJtaW5lXG4gICAgICogaWYgaXQncyB2YWx1ZSBjYW4gYmUgc3RhdGljYWxseSBpbmZlcnJlZFxuICAgICAqIGFuZCBhbHNvIG9taXQgYWxsIGF0dHJpYnV0ZXNcbiAgICAgKiBmcm9tIGJvZHkgdGhhdCBoYXMgdGhlIHNhbWUgZGVmaW5lZCBpbiBwcmltYXJ5IGtleVxuICAgICAqXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGljT3JEeW5hbWljVXBkYXRlQXR0cmlidXRlc1dpdGhNZXRhZGF0YSA9IE9iamVjdC5lbnRyaWVzKHtcbiAgICAgIC4uLnJhd0F0dHJpYnV0ZXNUb1VwZGF0ZSxcbiAgICB9KS5yZWR1Y2UoXG4gICAgICAoYWNjLCBbYXR0ck5hbWUsIGF0dHJWYWx1ZV0pID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWVXaXRoVHlwZSA9XG4gICAgICAgICAgdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VBdHRyaWJ1dGVUb1VwZGF0ZVZhbHVlKFxuICAgICAgICAgICAgYXR0ck5hbWUsXG4gICAgICAgICAgICBhdHRyVmFsdWVcbiAgICAgICAgICApIGFzIHt2YWx1ZTogYW55OyB0eXBlOiAnc3RhdGljJyB8ICdkeW5hbWljJ307XG5cbiAgICAgICAgYWNjLnRyYW5zZm9ybWVkW2F0dHJOYW1lXSA9IHZhbHVlV2l0aFR5cGUudmFsdWU7XG4gICAgICAgIGFjYy50eXBlTWV0YWRhdGFbYXR0ck5hbWVdID0gdmFsdWVXaXRoVHlwZS50eXBlO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt0cmFuc2Zvcm1lZDoge30sIHR5cGVNZXRhZGF0YToge319IGFzIHtcbiAgICAgICAgdHJhbnNmb3JtZWQ6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgICAgIHR5cGVNZXRhZGF0YTogUmVjb3JkPHN0cmluZywgJ2R5bmFtaWMnIHwgJ3N0YXRpYyc+O1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiAyLjAgLSBhcHBseSBjdXN0b20gY2xhc3MgdHJhbnNmb3JtYXRpb24gb24gc3RhdGljIGF0dHJpYnV0ZXNcbiAgICAgKlxuICAgICAqIHdlIG1hbnVhbGx5IG5lZWQgdG8gcmVwbGFjZSB0aGUgY29uc3RydWN0b3Igb2YgdGhlIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXG4gICAgICogd2l0aCB0aGUgZW50aXR5IGNsYXNzLCBzbyB0aGF0IHdlIGNhbiBwYXNzIGl0IHRocm91Z2ggdG8gY2xhc3MtdHJhbnNmb3JtZXJcbiAgICAgKiB0byBoYXZlIGFsbCB0cmFuc2Zvcm1lciBtZXRhZGF0YSBhcHBsaWVkLlxuICAgICAqL1xuXG4gICAgY29uc3Qgb25seVN0YXRpY0F0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhcbiAgICAgIHN0YXRpY09yRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZXNXaXRoTWV0YWRhdGEudHJhbnNmb3JtZWRcbiAgICApLnJlZHVjZSgoYWNjLCBbYXR0cktleSwgYXR0clZhbHVlXSkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnR5cGVNZXRhZGF0YVthdHRyS2V5XSA9PT1cbiAgICAgICAgJ3N0YXRpYydcbiAgICAgICkge1xuICAgICAgICBhY2NbYXR0cktleV0gPSBhdHRyVmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9IGFzIGFueSk7XG4gICAgb25seVN0YXRpY0F0dHJpYnV0ZXMuY29uc3RydWN0b3IgPSBlbnRpdHlDbGFzcztcbiAgICBjb25zdCBjbGFzc1RyYW5zZm9ybWVkU3RhdGljQXR0cmlidXRlcyA9XG4gICAgICB0aGlzLmFwcGx5Q2xhc3NUcmFuc2Zvcm1lckZvcm1hdGlvbnMob25seVN0YXRpY0F0dHJpYnV0ZXMpIGFzIEVudGl0eTtcbiAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnRyYW5zZm9ybWVkID0ge1xuICAgICAgLi4uc3RhdGljT3JEeW5hbWljVXBkYXRlQXR0cmlidXRlc1dpdGhNZXRhZGF0YS50cmFuc2Zvcm1lZCxcbiAgICAgIC4uLmNsYXNzVHJhbnNmb3JtZWRTdGF0aWNBdHRyaWJ1dGVzLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAzLjAgLSBHZXQgcmVmZXJlbmNlZCB1bmlxdWUgYXR0cmlidXRlcyBhbmQgdmFsaWRhdGUgdGhhdCBjdXJyZW50IHVwZGF0ZSBib2R5IGNhbiBiZSBzYWZlbHkgYXBwbGllZFxuICAgICAqL1xuICAgIGNvbnN0IHVuaXF1ZUF0dHJpYnV0ZXNUb1VwZGF0ZSA9IHRoaXMuY29ubmVjdGlvblxuICAgICAgLmdldFVuaXF1ZUF0dHJpYnV0ZXNGb3JFbnRpdHkoZW50aXR5Q2xhc3MpXG4gICAgICAuZmlsdGVyKGF0dHIgPT4gISEoYm9keSBhcyBhbnkpW2F0dHIubmFtZV0pXG4gICAgICAubWFwKGF0dHIgPT4ge1xuICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IHVwZGF0aW5nIHVuaXF1ZSBhdHRyaWJ1dGVzIHdpdGggZHluYW1pYyBleHBcbiAgICAgICAgLy8gd2UgY2FuJ3QgYWxsb3cgdXBkYXRpbmcgdW5pcXVlIGF0dHJpYnV0ZXMgd2hlbiB0aGV5IGNvbnRhaW4gZHluYW1pYyB1cGRhdGUgdmFsdWVcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRpY09yRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZXNXaXRoTWV0YWRhdGEudHlwZU1ldGFkYXRhW1xuICAgICAgICAgICAgYXR0ci5uYW1lXG4gICAgICAgICAgXSA9PT0gJ2R5bmFtaWMnXG4gICAgICAgICkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZVZhbHVlRXJyb3IoXG4gICAgICAgICAgICBhdHRyLm5hbWUsXG4gICAgICAgICAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnRyYW5zZm9ybWVkW2F0dHIubmFtZV1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdHRyO1xuICAgICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiAzLjEgLSBHZXQgcmVmZXJlbmNlZCBwcmltYXJ5IGtleSBhdHRyaWJ1dGVzIGFuZCB2YWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXBkYXRlIGJvZHkgY2FuIGJlIHNhZmVseSBhcHBsaWVkXG4gICAgICovXG4gICAgY29uc3QgZXhwbGljaXRBdHRyaWJ1dGVzVG9VcGRhdGUgPSBPYmplY3QuZW50cmllcyh7XG4gICAgICAuLi5zdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnRyYW5zZm9ybWVkLFxuICAgIH0pLnJlZHVjZSgoYWNjLCBbYXR0cktleSwgYXR0clZhbHVlXSkgPT4ge1xuICAgICAgLy8gQXR0cmlidXRlIGluIEJvZHkgdGhhdCBhcmUgaW4gcHJpbWFyeSBrZXkgYXR0cmlidXRlcyBhbmQgaGF2ZSB0aGUgZG8gbm90IHJlcXVpcmUgYW55IHVwZGF0ZXNcbiAgICAgIGlmIChcbiAgICAgICAgKHByaW1hcnlLZXlBdHRyaWJ1dGVzIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KVthdHRyS2V5XSAhPT0gYXR0clZhbHVlXG4gICAgICApIHtcbiAgICAgICAgYWNjW2F0dHJLZXldID0gYXR0clZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KTtcblxuICAgIGNvbnN0IGFmZmVjdGVkUHJpbWFyeUtleUF0dHJpYnV0ZXMgPVxuICAgICAgdGhpcy5nZXRBZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzPEVudGl0eT4oXG4gICAgICAgIGVudGl0eUNsYXNzLFxuICAgICAgICBleHBsaWNpdEF0dHJpYnV0ZXNUb1VwZGF0ZSxcbiAgICAgICAgc3RhdGljT3JEeW5hbWljVXBkYXRlQXR0cmlidXRlc1dpdGhNZXRhZGF0YS50eXBlTWV0YWRhdGEsXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRpdGlvbmFsQXR0cmlidXRlc0RpY3Q6XG4gICAgICAgICAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnRyYW5zZm9ybWVkLFxuICAgICAgICB9XG4gICAgICApO1xuXG4gICAgLy8gdmFsaWRhdGUgcHJpbWFyeSBrZXkgYXR0cmlidXRlc1xuICAgIGlmICghaXNFbXB0eU9iamVjdChhZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzKSkge1xuICAgICAgLy8gdXBkYXRlcyBhcmUgbm90IGFsbG93ZWQgZm9yIGF0dHJpYnV0ZXMgdGhhdCB1bmlxdWUgYW5kIGFsc28gcmVmZXJlbmNlcyBwcmltYXJ5IGtleS5cbiAgICAgIGlmICh1bmlxdWVBdHRyaWJ1dGVzVG9VcGRhdGUubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVW5pcXVlQXR0cmlidXRlVXBkYXRlRXJyb3IoXG4gICAgICAgICAgYWZmZWN0ZWRQcmltYXJ5S2V5QXR0cmlidXRlcyEsXG4gICAgICAgICAgdW5pcXVlQXR0cmlidXRlc1RvVXBkYXRlLm1hcChhdHRyID0+IGF0dHIubmFtZSlcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAzLjIgLSBHZXQgcmVmZXJlbmNlZCBpbmRleGVzJyBhdHRyaWJ1dGVzIGFuZCB2YWxpZGF0ZSB0aGF0IGN1cnJlbnQgdXBkYXRlIGJvZHkgY2FuIGJlIHNhZmVseSBhcHBsaWVkXG4gICAgICovXG4gICAgY29uc3QgYWZmZWN0ZWRJbmRleGVzID0gdGhpcy5nZXRBZmZlY3RlZEluZGV4ZXNGb3JBdHRyaWJ1dGVzPEVudGl0eT4oXG4gICAgICBlbnRpdHlDbGFzcyxcbiAgICAgIHN0YXRpY09yRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZXNXaXRoTWV0YWRhdGEudHJhbnNmb3JtZWQsXG4gICAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnR5cGVNZXRhZGF0YSxcbiAgICAgIHtcbiAgICAgICAgbmVzdGVkS2V5U2VwYXJhdG9yLFxuICAgICAgICBhZGRpdGlvbmFsQXR0cmlidXRlc0RpY3Q6IHtcbiAgICAgICAgICAuLi5wcmltYXJ5S2V5QXR0cmlidXRlcyxcbiAgICAgICAgfSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgICAgfVxuICAgICk7XG5cbiAgICAvKipcbiAgICAgKiA0LjAgLSBCdWlsZCB1cGRhdGUgSXRlbSBib2R5IHdpdGggZ2l2ZW4gY29uZGl0aW9uIGFuZCBvcHRpb25zXG4gICAgICovXG4gICAgY29uc3QgaXRlbVRvVXBkYXRlOlxuICAgICAgfCBEb2N1bWVudENsaWVudFR5cGVzLlVwZGF0ZUl0ZW1JbnB1dFxuICAgICAgfCBEb2N1bWVudENsaWVudFR5cGVzLlB1dEl0ZW1JbnB1dCA9IHtcbiAgICAgIFRhYmxlTmFtZTogdGFibGVOYW1lLFxuICAgICAgS2V5OiB7XG4gICAgICAgIC4uLnBhcnNlZFByaW1hcnlLZXksXG4gICAgICB9LFxuICAgICAgUmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogbWV0YWRhdGFPcHRpb25zPy5yZXR1cm5Db25zdW1lZENhcGFjaXR5LFxuICAgICAgLy8gcmVxdWVzdCBhbGwgbmV3IGF0dHJpYnV0ZXNcbiAgICAgIFJldHVyblZhbHVlczogUkVUVVJOX1ZBTFVFUy5BTExfTkVXLFxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiA0LjEgLSBpZiAnd2hlcmUnIHdhcyBwcm92aWRlZCwgYnVpbGQgY29uZGl0aW9uIGV4cHJlc3Npb25cbiAgICAgKi9cbiAgICBpZiAob3B0aW9ucy53aGVyZSAmJiAhaXNFbXB0eU9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VUb0NvbmRpdGlvbihcbiAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgKTtcblxuICAgICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBGYWlsZWQgdG8gYnVpbGQgY29uZGl0aW9uIGV4cHJlc3Npb24gZm9yIGlucHV0OiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgb3B0aW9ucy53aGVyZVxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIENvbmRpdGlvbkV4cHJlc3Npb24sXG4gICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgIH0gPSB0aGlzLmV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkQ29uZGl0aW9uRXhwcmVzc2lvbihjb25kaXRpb24pO1xuXG4gICAgICAvLyBhcHBlbmQgY29uZGl0aW9uIGV4cHJlc3Npb24gaWYgb25lIHdhcyBidWlsdFxuICAgICAgaXRlbVRvVXBkYXRlLkNvbmRpdGlvbkV4cHJlc3Npb24gPSBDb25kaXRpb25FeHByZXNzaW9uO1xuICAgICAgaXRlbVRvVXBkYXRlLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICAgICAgLi4uRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAuLi5pdGVtVG9VcGRhdGUuRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgfTtcbiAgICAgIGl0ZW1Ub1VwZGF0ZS5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzID0ge1xuICAgICAgICAuLi5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICAuLi5pdGVtVG9VcGRhdGUuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogNS4wIC0gdXBkYXRlIGNvbnRhaW5zIHByaW1hcnkga2V5IGF0dHJpYnV0ZXMgc28gaXQgbXVzdCBiZSBsYXppbHkgdXBkYXRlZFxuICAgICAqIFRoaXMgcmVxdWlyZXMgZGVsZXRpbmcgb2xkIGl0ZW0gYW5kIHdyaXRpbmcgbmV3IGl0ZW0gdG8gdGhlIHRhYmxlIGJvdGggaW4gYSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGlmIChcbiAgICAgIGlzT2JqZWN0KGFmZmVjdGVkUHJpbWFyeUtleUF0dHJpYnV0ZXMpICYmXG4gICAgICAhaXNFbXB0eU9iamVjdChhZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzKVxuICAgICkge1xuICAgICAgY29uc3QgbGF6eUxvYWRUcmFuc2FjdGlvbldyaXRlSXRlbXMgPVxuICAgICAgICB0aGlzLmxhenlUb0R5bmFtb1VwZGF0ZVByaW1hcnlLZXlGYWN0b3J5KFxuICAgICAgICAgIG1ldGFkYXRhLnRhYmxlLFxuICAgICAgICAgIG1ldGFkYXRhLm5hbWUsXG4gICAgICAgICAgbWV0YWRhdGEuc2NoZW1hLnByaW1hcnlLZXksXG4gICAgICAgICAge1xuICAgICAgICAgICAgSXRlbToge1xuICAgICAgICAgICAgICAuLi5hZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAuLi5hZmZlY3RlZEluZGV4ZXMsXG4gICAgICAgICAgICAgIC4uLnN0YXRpY09yRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZXNXaXRoTWV0YWRhdGEudHJhbnNmb3JtZWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgVGFibGVOYW1lOiBtZXRhZGF0YS50YWJsZS5uYW1lLFxuICAgICAgICAgICAgUmV0dXJuQ29uc3VtZWRDYXBhY2l0eTogaXRlbVRvVXBkYXRlLlJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgICAgICAgICBSZXR1cm5WYWx1ZXM6IGl0ZW1Ub1VwZGF0ZS5SZXR1cm5WYWx1ZXMsXG4gICAgICAgICAgICBDb25kaXRpb25FeHByZXNzaW9uOiBpdGVtVG9VcGRhdGUuQ29uZGl0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczogaXRlbVRvVXBkYXRlLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IGl0ZW1Ub1VwZGF0ZS5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgbWV0YWRhdGFPcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzLFxuICAgICAgICBlbnRpdHlDbGFzcyxcbiAgICAgICAgbGF6eUxvYWRUcmFuc2FjdGlvbldyaXRlSXRlbXMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIDUuMC4xIC0gYnVpbGQgdXBkYXRlIGV4cHJlc3Npb24gd2l0aCB1c2VyIHByb3ZpZGVkIGJvZHkgYW5kIGFsbCBvdGhlciBhdXRvIHRyYW5zZm9ybWF0aW9uXG4gICAgICovXG4gICAgY29uc3QgdXBkYXRlID0gdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VUb1VwZGF0ZShcbiAgICAgIHtcbiAgICAgICAgLi4ucmF3QXR0cmlidXRlc1RvVXBkYXRlLFxuICAgICAgICAuLi5hZmZlY3RlZEluZGV4ZXMsXG4gICAgICB9LFxuICAgICAgc3RhdGljT3JEeW5hbWljVXBkYXRlQXR0cmlidXRlc1dpdGhNZXRhZGF0YS50cmFuc2Zvcm1lZFxuICAgICk7XG5cbiAgICBjb25zdCB7XG4gICAgICBVcGRhdGVFeHByZXNzaW9uLFxuICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICB9ID0gdGhpcy5leHByZXNzaW9uQnVpbGRlci5idWlsZFVwZGF0ZUV4cHJlc3Npb24odXBkYXRlKTtcbiAgICBpdGVtVG9VcGRhdGUuVXBkYXRlRXhwcmVzc2lvbiA9IFVwZGF0ZUV4cHJlc3Npb247XG4gICAgaXRlbVRvVXBkYXRlLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgIC4uLml0ZW1Ub1VwZGF0ZS5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgfTtcbiAgICBpdGVtVG9VcGRhdGUuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMsXG4gICAgICAuLi5pdGVtVG9VcGRhdGUuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogNS4xIC0gVXBkYXRlIGNvbnRhaW5zIHVuaXF1ZSBhdHRyaWJ1dGVzLCBidWlsZCBhIGxhenkgdW5pcXVlIGF0dHJpYnV0ZXMgbG9hZGVyIGFuZCByZXR1cm5cbiAgICAgKi9cbiAgICBpZiAodW5pcXVlQXR0cmlidXRlc1RvVXBkYXRlLmxlbmd0aCkge1xuICAgICAgLy8gaWYgdGhlcmUgYXJlIHVuaXF1ZSBhdHRyaWJ1dGVzLCByZXR1cm4gYSBsYXp5IGxvYWRlciwgd2hpY2ggd2lsbCByZXR1cm4gd3JpdGUgaXRlbSBsaXN0XG4gICAgICBjb25zdCBsYXp5TG9hZFRyYW5zYWN0aW9uV3JpdGVJdGVtcyA9XG4gICAgICAgIHRoaXMubGF6eVRvRHluYW1vVXBkYXRlVW5pcXVlSXRlbUZhY3Rvcnk8RW50aXR5PihcbiAgICAgICAgICBtZXRhZGF0YS50YWJsZSxcbiAgICAgICAgICBtZXRhZGF0YS5uYW1lLFxuICAgICAgICAgIHVuaXF1ZUF0dHJpYnV0ZXNUb1VwZGF0ZSxcbiAgICAgICAgICBkcm9wUHJvcChpdGVtVG9VcGRhdGUsICdSZXR1cm5WYWx1ZXMnKSxcbiAgICAgICAgICBzdGF0aWNPckR5bmFtaWNVcGRhdGVBdHRyaWJ1dGVzV2l0aE1ldGFkYXRhLnRyYW5zZm9ybWVkLFxuICAgICAgICAgIG1ldGFkYXRhT3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcmltYXJ5S2V5QXR0cmlidXRlcyxcbiAgICAgICAgZW50aXR5Q2xhc3MsXG4gICAgICAgIGxhenlMb2FkVHJhbnNhY3Rpb25Xcml0ZUl0ZW1zLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiA1LjIgLSByZXR1cm4gc2ltcGxlIHVwZGF0ZSBib2R5XG4gICAgICovXG4gICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgIG9wZXJhdGlvbjogVFJBTlNGT1JNX1RZUEUuVVBEQVRFLFxuICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgZW50aXR5TmFtZTogbWV0YWRhdGEubmFtZSxcbiAgICAgIHByaW1hcnlLZXk6IG51bGwsXG4gICAgICBib2R5OiBpdGVtVG9VcGRhdGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZW1Ub1VwZGF0ZTtcbiAgfVxuXG4gIHRvRHluYW1vRGVsZXRlSXRlbTxFbnRpdHksIFByaW1hcnlLZXk+KFxuICAgIGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5PixcbiAgICBwcmltYXJ5S2V5OiBQcmltYXJ5S2V5LFxuICAgIG9wdGlvbnM/OiBNYW5hZ2VyVG9EeW5hbW9EZWxldGVJdGVtc09wdGlvbnMsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICk6IERvY3VtZW50Q2xpZW50VHlwZXMuRGVsZXRlSXRlbUlucHV0IHwgTGF6eVRyYW5zYWN0aW9uV3JpdGVJdGVtTGlzdExvYWRlciB7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmNvbm5lY3Rpb24uZ2V0RW50aXR5QnlUYXJnZXQoZW50aXR5Q2xhc3MpO1xuICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgIHJlcXVlc3RJZDogbWV0YWRhdGFPcHRpb25zPy5yZXF1ZXN0SWQsXG4gICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLkRFTEVURSxcbiAgICAgIHByZWZpeDogJ0JlZm9yZScsXG4gICAgICBlbnRpdHlOYW1lOiBtZXRhZGF0YS5uYW1lLFxuICAgICAgcHJpbWFyeUtleSxcbiAgICB9KTtcbiAgICBjb25zdCB0YWJsZU5hbWUgPSBtZXRhZGF0YS50YWJsZS5uYW1lO1xuXG4gICAgY29uc3QgcGFyc2VkUHJpbWFyeUtleSA9IHRoaXMuZ2V0UGFyc2VkUHJpbWFyeUtleTxQcmltYXJ5S2V5PihcbiAgICAgIG1ldGFkYXRhLnRhYmxlLFxuICAgICAgbWV0YWRhdGEuc2NoZW1hLnByaW1hcnlLZXksXG4gICAgICBwcmltYXJ5S2V5XG4gICAgKTtcblxuICAgIGlmIChpc0VtcHR5T2JqZWN0KHBhcnNlZFByaW1hcnlLZXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1hcnkgY291bGQgbm90IGJlIHJlc29sdmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdW5pcXVlQXR0cmlidXRlc1RvUmVtb3ZlID1cbiAgICAgIHRoaXMuY29ubmVjdGlvbi5nZXRVbmlxdWVBdHRyaWJ1dGVzRm9yRW50aXR5KGVudGl0eUNsYXNzKTtcblxuICAgIGNvbnN0IG1haW5JdGVtVG9SZW1vdmU6IERvY3VtZW50Q2xpZW50VHlwZXMuRGVsZXRlSXRlbUlucHV0ID0ge1xuICAgICAgVGFibGVOYW1lOiB0YWJsZU5hbWUsXG4gICAgICBLZXk6IHtcbiAgICAgICAgLi4ucGFyc2VkUHJpbWFyeUtleSxcbiAgICAgIH0sXG4gICAgICBSZXR1cm5Db25zdW1lZENhcGFjaXR5OiBtZXRhZGF0YU9wdGlvbnM/LnJldHVybkNvbnN1bWVkQ2FwYWNpdHksXG4gICAgfTtcblxuICAgIGlmIChvcHRpb25zPy53aGVyZSAmJiAhaXNFbXB0eU9iamVjdChvcHRpb25zLndoZXJlKSkge1xuICAgICAgY29uc3QgY29uZGl0aW9uID0gdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VUb0NvbmRpdGlvbihcbiAgICAgICAgb3B0aW9ucz8ud2hlcmVcbiAgICAgICk7XG5cbiAgICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRmFpbGVkIHRvIGJ1aWxkIGNvbmRpdGlvbiBleHByZXNzaW9uIGZvciBpbnB1dDogJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIG9wdGlvbnM/LndoZXJlXG4gICAgICAgICAgKX1gXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgQ29uZGl0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgfSA9IHRoaXMuZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGRDb25kaXRpb25FeHByZXNzaW9uKGNvbmRpdGlvbik7XG5cbiAgICAgIG1haW5JdGVtVG9SZW1vdmUuQ29uZGl0aW9uRXhwcmVzc2lvbiA9IENvbmRpdGlvbkV4cHJlc3Npb247XG4gICAgICBtYWluSXRlbVRvUmVtb3ZlLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyA9IHtcbiAgICAgICAgLi4ubWFpbkl0ZW1Ub1JlbW92ZS5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgIH07XG5cbiAgICAgIG1haW5JdGVtVG9SZW1vdmUuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyA9IHtcbiAgICAgICAgLi4ubWFpbkl0ZW1Ub1JlbW92ZS5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICAuLi5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXVuaXF1ZUF0dHJpYnV0ZXNUb1JlbW92ZT8ubGVuZ3RoKSB7XG4gICAgICAvLyBpZiBpdGVtIGRvZXMgbm90IGhhdmUgYW55IHVuaXF1ZSBhdHRyaWJ1dGVzIHJldHVybiBpdCBhcyBpc1xuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLkRFTEVURSxcbiAgICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgICBlbnRpdHlOYW1lOiBtZXRhZGF0YS5uYW1lLFxuICAgICAgICBwcmltYXJ5S2V5LFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFpbkl0ZW1Ub1JlbW92ZTtcbiAgICB9XG5cbiAgICAvLyBvciByZXR1cm4gbGF6eSByZXNvbHZlclxuICAgIGNvbnN0IGxhenlMb2FkVHJhbnNhY3Rpb25Xcml0ZUl0ZW1zID0gdGhpcy5sYXp5VG9EeW5hbW9SZW1vdmVJdGVtRmFjdG9yeShcbiAgICAgIG1ldGFkYXRhLnRhYmxlLFxuICAgICAgbWV0YWRhdGEubmFtZSxcbiAgICAgIHVuaXF1ZUF0dHJpYnV0ZXNUb1JlbW92ZSxcbiAgICAgIG1haW5JdGVtVG9SZW1vdmUsXG4gICAgICBtZXRhZGF0YU9wdGlvbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByaW1hcnlLZXlBdHRyaWJ1dGVzOiBwcmltYXJ5S2V5LFxuICAgICAgZW50aXR5Q2xhc3MsXG4gICAgICBsYXp5TG9hZFRyYW5zYWN0aW9uV3JpdGVJdGVtcyxcbiAgICB9O1xuICB9XG5cbiAgdG9EeW5hbW9RdWVyeUl0ZW08RW50aXR5LCBQYXJ0aXRpb25LZXlBdHRyaWJ1dGVzPihcbiAgICBlbnRpdHlDbGFzczogRW50aXR5VGFyZ2V0PEVudGl0eT4sXG4gICAgcGFydGl0aW9uS2V5QXR0cmlidXRlczogUGFydGl0aW9uS2V5QXR0cmlidXRlcyB8IHN0cmluZyxcbiAgICBxdWVyeU9wdGlvbnM/OiBNYW5hZ2VyVG9EeW5hbW9RdWVyeUl0ZW1zT3B0aW9ucyxcbiAgICBtZXRhZGF0YU9wdGlvbnM/OiBNZXRhZGF0YU9wdGlvbnNcbiAgKTogRG9jdW1lbnRDbGllbnRUeXBlcy5RdWVyeUlucHV0IHtcbiAgICBjb25zdCB7dGFibGUsIHNjaGVtYSwgbmFtZX0gPVxuICAgICAgdGhpcy5jb25uZWN0aW9uLmdldEVudGl0eUJ5VGFyZ2V0KGVudGl0eUNsYXNzKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1RyYW5zZm9ybSh7XG4gICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5RVUVSWSxcbiAgICAgIHByZWZpeDogJ0JlZm9yZScsXG4gICAgICBlbnRpdHlOYW1lOiBuYW1lLFxuICAgICAgcHJpbWFyeUtleTogcGFydGl0aW9uS2V5QXR0cmlidXRlcyxcbiAgICAgIG9wdGlvbnM6IHF1ZXJ5T3B0aW9ucyxcbiAgICB9KTtcbiAgICBjb25zdCBxdWVyeUluZGV4TmFtZSA9IHF1ZXJ5T3B0aW9ucz8ucXVlcnlJbmRleDtcbiAgICBsZXQgaW5kZXhUb1F1ZXJ5OiBJbmRleE9wdGlvbnMgfCB1bmRlZmluZWQ7XG4gICAgaWYgKHF1ZXJ5SW5kZXhOYW1lKSB7XG4gICAgICBjb25zdCBtYXRjaGluZ0luZGV4ID0gdGFibGUuZ2V0SW5kZXhCeUtleShxdWVyeUluZGV4TmFtZSk7XG4gICAgICBpZiAoIW1hdGNoaW5nSW5kZXgpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vU3VjaEluZGV4Rm91bmRFcnJvcih0YWJsZS5uYW1lLCBxdWVyeUluZGV4TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoaW5nSW5kZXhPbkVudGl0eSA9XG4gICAgICAgIHNjaGVtYS5pbmRleGVzICYmIHNjaGVtYS5pbmRleGVzW3F1ZXJ5SW5kZXhOYW1lXTtcblxuICAgICAgaWYgKCFtYXRjaGluZ0luZGV4T25FbnRpdHkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBSZXF1ZXN0ZWQgdG8gcXVlcnkgaXRlbXMgZnJvbSBpbmRleCBcIiR7cXVlcnlJbmRleE5hbWV9XCIsIGJ1dCBubyBzdWNoIGluZGV4IGV4aXN0cyBvbiBlbnRpdHkuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaW5kZXhUb1F1ZXJ5ID0gbWF0Y2hpbmdJbmRleDtcbiAgICB9XG5cbiAgICAvLyBxdWVyeSB3aWxsIGJlIGV4ZWN1dGVkIGFnYWluc3QgbWFpbiB0YWJsZSBvclxuICAgIC8vIGlmIHF1ZXJ5aW5nIGxvY2FsICBpbmRleCwgdGhlbiBwYXJ0aXRpb24ga2V5IHdpbGwgYmUgc2FtZSBhcyBtYWluIHRhYmxlXG4gICAgY29uc3QgcGFyc2VkUGFydGl0aW9uS2V5ID0ge30gYXMge25hbWU6IHN0cmluZzsgdmFsdWU6IGFueX07XG4gICAgaWYgKFxuICAgICAgIXF1ZXJ5SW5kZXhOYW1lIHx8XG4gICAgICAhaW5kZXhUb1F1ZXJ5IHx8XG4gICAgICBpbmRleFRvUXVlcnk/LnR5cGUgPT09IElOREVYX1RZUEUuTFNJXG4gICAgKSB7XG4gICAgICBwYXJzZWRQYXJ0aXRpb25LZXkubmFtZSA9IHRhYmxlLnBhcnRpdGlvbktleTtcbiAgICAgIHBhcnNlZFBhcnRpdGlvbktleS52YWx1ZSA9XG4gICAgICAgIHR5cGVvZiBwYXJ0aXRpb25LZXlBdHRyaWJ1dGVzID09PSAnc3RyaW5nJ1xuICAgICAgICAgID8gcGFydGl0aW9uS2V5QXR0cmlidXRlc1xuICAgICAgICAgIDogcGFyc2VLZXkoXG4gICAgICAgICAgICAgIHNjaGVtYS5wcmltYXJ5S2V5LmF0dHJpYnV0ZXNbdGFibGUucGFydGl0aW9uS2V5XSxcbiAgICAgICAgICAgICAgcGFydGl0aW9uS2V5QXR0cmlidXRlc1xuICAgICAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcXVlcnkgaXMgdG8gYmUgZXhlY3V0ZWQgYWdhaW5zdCBnbG9iYWwgc2Vjb25kYXJ5IGluZGV4XG4gICAgICBwYXJzZWRQYXJ0aXRpb25LZXkubmFtZSA9IGluZGV4VG9RdWVyeS5wYXJ0aXRpb25LZXk7XG4gICAgICBjb25zdCBzY2hlbWFGb3JJbmRleFRvUXVlcnkgPSAoc2NoZW1hLmluZGV4ZXMgPz8ge30pW3F1ZXJ5SW5kZXhOYW1lXTtcblxuICAgICAgcGFyc2VkUGFydGl0aW9uS2V5LnZhbHVlID1cbiAgICAgICAgdHlwZW9mIHBhcnRpdGlvbktleUF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgPyBwYXJ0aXRpb25LZXlBdHRyaWJ1dGVzXG4gICAgICAgICAgOiBwYXJzZUtleShcbiAgICAgICAgICAgICAgc2NoZW1hRm9ySW5kZXhUb1F1ZXJ5LmF0dHJpYnV0ZXNbaW5kZXhUb1F1ZXJ5LnBhcnRpdGlvbktleV0sXG4gICAgICAgICAgICAgIHBhcnRpdGlvbktleUF0dHJpYnV0ZXNcbiAgICAgICAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFydGl0aW9uS2V5Q29uZGl0aW9uID0gbmV3IEtleUNvbmRpdGlvbigpLmVxdWFscyhcbiAgICAgIHBhcnNlZFBhcnRpdGlvbktleS5uYW1lLFxuICAgICAgcGFyc2VkUGFydGl0aW9uS2V5LnZhbHVlXG4gICAgKTtcblxuICAgIGNvbnN0IHBhcnRpdGlvbktleUNvbmRpdGlvbkV4cHJlc3Npb24gPVxuICAgICAgdGhpcy5leHByZXNzaW9uQnVpbGRlci5idWlsZEtleUNvbmRpdGlvbkV4cHJlc3Npb24ocGFydGl0aW9uS2V5Q29uZGl0aW9uKTtcblxuICAgIGNvbnN0IHBhcnNlZFNvcnRLZXkgPSB7fSBhcyB7bmFtZTogc3RyaW5nfTtcbiAgICAvLyBpZiBubyB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGFnYWluc3QgaW5kZXgsIHZhbGlkYXRlIGlmIHRhYmxlIGlzIHVzaW5nIGNvbXBvc2l0ZSBrZXlcbiAgICBpZiAoIWluZGV4VG9RdWVyeSkge1xuICAgICAgaWYgKCF0YWJsZS51c2VzQ29tcG9zaXRlS2V5KCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBUYWJsZSAke3RhYmxlLm5hbWV9IGRvZXMgbm90IHVzZSBjb21wb3NpdGUga2V5LCB0aHVzIHF1ZXJ5aW5nIGEgc29ydCBrZXkgaXMgbm90IGFsbG93ZWRgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlZFNvcnRLZXkubmFtZSA9IHRhYmxlLnNvcnRLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZFNvcnRLZXkubmFtZSA9IGluZGV4VG9RdWVyeS5zb3J0S2V5O1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgd2UgaGF2ZSByZXNvbHZlZCBwYXJ0aXRpb24ga2V5IGFuZCB0YWJsZSB0byBxdWVyeVxuICAgIGxldCBxdWVyeUlucHV0UGFyYW1zID0ge1xuICAgICAgVGFibGVOYW1lOiB0YWJsZS5uYW1lLFxuICAgICAgSW5kZXhOYW1lOiBxdWVyeUluZGV4TmFtZSxcbiAgICAgIFJldHVybkNvbnN1bWVkQ2FwYWNpdHk6IG1ldGFkYXRhT3B0aW9ucz8ucmV0dXJuQ29uc3VtZWRDYXBhY2l0eSxcbiAgICAgIC4uLnBhcnRpdGlvbktleUNvbmRpdGlvbkV4cHJlc3Npb24sXG4gICAgfSBhcyBEb2N1bWVudENsaWVudFR5cGVzLlF1ZXJ5SW5wdXQ7XG5cbiAgICBpZiAocXVlcnlPcHRpb25zICYmICFpc0VtcHR5T2JqZWN0KHF1ZXJ5T3B0aW9ucykpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb3JkZXJCeTogb3JkZXIsXG4gICAgICAgIGxpbWl0LFxuICAgICAgICBrZXlDb25kaXRpb24sXG4gICAgICAgIHdoZXJlLFxuICAgICAgICBzZWxlY3QsXG4gICAgICAgIG9ubHlDb3VudCxcbiAgICAgICAgY29uc2lzdGVudFJlYWQsXG4gICAgICB9ID0gcXVlcnlPcHRpb25zO1xuXG4gICAgICBxdWVyeUlucHV0UGFyYW1zID0ge1xuICAgICAgICAuLi5xdWVyeUlucHV0UGFyYW1zLFxuICAgICAgICBMaW1pdDogbGltaXQsXG4gICAgICAgIENvbnNpc3RlbnRSZWFkOiBjb25zaXN0ZW50UmVhZCxcbiAgICAgIH07XG5cbiAgICAgIGlmIChvcmRlcikge1xuICAgICAgICBxdWVyeUlucHV0UGFyYW1zLlNjYW5JbmRleEZvcndhcmQgPSBvcmRlciA9PT0gUVVFUllfT1JERVIuQVNDO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBrZXkgY29uZGl0aW9uIHdhcyBwcm92aWRlZFxuICAgICAgaWYgKGtleUNvbmRpdGlvbiAmJiAhaXNFbXB0eU9iamVjdChrZXlDb25kaXRpb24pKSB7XG4gICAgICAgIC8vIGJ1aWxkIHNvcnQga2V5IGNvbmRpdGlvblxuICAgICAgICBjb25zdCBzb3J0S2V5Q29uZGl0aW9uID0gdGhpcy5leHByZXNzaW9uSW5wdXRQYXJzZXIucGFyc2VUb0tleUNvbmRpdGlvbihcbiAgICAgICAgICBwYXJzZWRTb3J0S2V5Lm5hbWUsXG4gICAgICAgICAga2V5Q29uZGl0aW9uXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gaWYgY29uZGl0aW9uIHJlc29sdXRpb24gd2FzIHN1Y2Nlc3NmdWwsIHdlIGNhbiBtZXJnZSBib3RoIHBhcnRpdGlvbiBhbmQgc29ydCBrZXkgY29uZGl0aW9ucyBub3dcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb24sXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMsXG4gICAgICAgIH0gPSB0aGlzLmV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkS2V5Q29uZGl0aW9uRXhwcmVzc2lvbihcbiAgICAgICAgICBwYXJ0aXRpb25LZXlDb25kaXRpb24ubWVyZ2Uoc29ydEtleUNvbmRpdGlvbilcbiAgICAgICAgKTtcblxuICAgICAgICBxdWVyeUlucHV0UGFyYW1zID0ge1xuICAgICAgICAgIC4uLnF1ZXJ5SW5wdXRQYXJhbXMsXG4gICAgICAgICAgS2V5Q29uZGl0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXM6IHtcbiAgICAgICAgICAgIC4uLnF1ZXJ5SW5wdXRQYXJhbXMuRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAgICAgLi4uRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlczoge1xuICAgICAgICAgICAgLi4ucXVlcnlJbnB1dFBhcmFtcy5FeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzLFxuICAgICAgICAgICAgLi4uRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIGZpbHRlciBjb25kaXRpb25zIGFyZSBnaXZlbiBnZW5lcmF0ZSBmaWx0ZXIgZXhwcmVzc2lvblxuICAgICAgaWYgKHdoZXJlICYmICFpc0VtcHR5T2JqZWN0KHdoZXJlKSkge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLmV4cHJlc3Npb25JbnB1dFBhcnNlci5wYXJzZVRvRmlsdGVyKHdoZXJlKTtcblxuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRmlsdGVySW5wdXRFcnJvcih3aGVyZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgRmlsdGVyRXhwcmVzc2lvbixcbiAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgICAgfSA9IHRoaXMuZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGRGaWx0ZXJFeHByZXNzaW9uKGZpbHRlcik7XG5cbiAgICAgICAgcXVlcnlJbnB1dFBhcmFtcyA9IHtcbiAgICAgICAgICAuLi5xdWVyeUlucHV0UGFyYW1zLFxuICAgICAgICAgIEZpbHRlckV4cHJlc3Npb24sXG4gICAgICAgICAgRXhwcmVzc2lvbkF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgICAgICAgICAuLi5xdWVyeUlucHV0UGFyYW1zLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lcyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXM6IHtcbiAgICAgICAgICAgIC4uLnF1ZXJ5SW5wdXRQYXJhbXMuRXhwcmVzc2lvbkF0dHJpYnV0ZVZhbHVlcyxcbiAgICAgICAgICAgIC4uLkV4cHJlc3Npb25BdHRyaWJ1dGVWYWx1ZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgb25seSB0aGUgY291bnQgd2FzIHJlcXVlc3RlZFxuICAgICAgaWYgKG9ubHlDb3VudCkge1xuICAgICAgICBpZiAoc2VsZWN0Py5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnQXR0cmlidXRlcyBwcm9qZWN0aW9uIGFuZCBjb3VudCBjYW4gbm90IGJlIHVzZWQgdG9nZXRoZXInXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb3VudCBhbmQgcHJvamVjdGlvbiBzZWxlY3Rpb24gY2FuIG5vdCBiZSB1c2VkIHRvZ2V0aGVyXG4gICAgICAgIHF1ZXJ5SW5wdXRQYXJhbXMuU2VsZWN0ID0gUVVFUllfU0VMRUNUX1RZUEUuQ09VTlQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHdoZW4gcHJvamVjdGlvbiBrZXlzIGFyZSBwcm92aWRlZFxuICAgICAgaWYgKHNlbGVjdCAmJiBzZWxlY3QubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLmV4cHJlc3Npb25JbnB1dFBhcnNlci5wYXJzZVRvUHJvamVjdGlvbihzZWxlY3QpO1xuXG4gICAgICAgIGlmICghcHJvamVjdGlvbikge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2VsZWN0SW5wdXRFcnJvcihzZWxlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qge1Byb2plY3Rpb25FeHByZXNzaW9uLCBFeHByZXNzaW9uQXR0cmlidXRlTmFtZXN9ID1cbiAgICAgICAgICB0aGlzLmV4cHJlc3Npb25CdWlsZGVyLmJ1aWxkUHJvamVjdGlvbkV4cHJlc3Npb24ocHJvamVjdGlvbik7XG5cbiAgICAgICAgcXVlcnlJbnB1dFBhcmFtcyA9IHtcbiAgICAgICAgICAuLi5xdWVyeUlucHV0UGFyYW1zLFxuICAgICAgICAgIFByb2plY3Rpb25FeHByZXNzaW9uLFxuICAgICAgICAgIEV4cHJlc3Npb25BdHRyaWJ1dGVOYW1lczoge1xuICAgICAgICAgICAgLi4ucXVlcnlJbnB1dFBhcmFtcy5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgICAuLi5FeHByZXNzaW9uQXR0cmlidXRlTmFtZXMsXG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24ubG9nZ2VyLmxvZ1RyYW5zZm9ybSh7XG4gICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5RVUVSWSxcbiAgICAgIHByZWZpeDogJ0FmdGVyJyxcbiAgICAgIGVudGl0eU5hbWU6IG5hbWUsXG4gICAgICBwcmltYXJ5S2V5OiBwYXJ0aXRpb25LZXlBdHRyaWJ1dGVzLFxuICAgICAgYm9keTogcXVlcnlJbnB1dFBhcmFtcyxcbiAgICB9KTtcblxuICAgIHJldHVybiBxdWVyeUlucHV0UGFyYW1zO1xuICB9XG5cbiAgcHJpdmF0ZSBsYXp5VG9EeW5hbW9VcGRhdGVQcmltYXJ5S2V5RmFjdG9yeShcbiAgICB0YWJsZTogVGFibGUsXG4gICAgZW50aXR5TmFtZTogc3RyaW5nLFxuICAgIHByaW1hcnlLZXlTY2hlbWE6IER5bmFtb0VudGl0eVNjaGVtYVByaW1hcnlLZXksXG4gICAgbmV3SXRlbUJvZHk6IERvY3VtZW50Q2xpZW50VHlwZXMuUHV0SXRlbUlucHV0LFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApIHtcbiAgICByZXR1cm4gKHByZXZpb3VzSXRlbUJvZHk6IGFueSkgPT4ge1xuICAgICAgY29uc3QgdXBkYXRlVHJhbnNhY3Rpb25JdGVtczogRG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbUxpc3QgPVxuICAgICAgICBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgUHV0OiB7XG4gICAgICAgICAgICAgIC4uLm5ld0l0ZW1Cb2R5LFxuICAgICAgICAgICAgICAvLyBpbXBvcnQgZXhpc3RpbmcgY3VycmVudCBpdGVtXG4gICAgICAgICAgICAgIEl0ZW06IHsuLi5wcmV2aW91c0l0ZW1Cb2R5LCAuLi5uZXdJdGVtQm9keS5JdGVtfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSBhcyBEb2N1bWVudENsaWVudFR5cGVzLlRyYW5zYWN0V3JpdGVJdGVtTGlzdDtcblxuICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcHJldmlvdXMgZXhpc3RpbmcgaXRlbSwgYmFzaWNhbGx5IHJlbW92ZSBpdCBhcyBwYXJ0IG9mIHRoaXMgdHJhbnNhY3Rpb25cbiAgICAgIGlmIChwcmV2aW91c0l0ZW1Cb2R5ICYmICFpc0VtcHR5T2JqZWN0KHByZXZpb3VzSXRlbUJvZHkpKSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uSXRlbXMucHVzaCh7XG4gICAgICAgICAgRGVsZXRlOiB7XG4gICAgICAgICAgICBUYWJsZU5hbWU6IHRhYmxlLm5hbWUsXG4gICAgICAgICAgICBLZXk6IHtcbiAgICAgICAgICAgICAgLi4udGhpcy5nZXRQYXJzZWRQcmltYXJ5S2V5KFxuICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgIHByaW1hcnlLZXlTY2hlbWEsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNJdGVtQm9keVxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb25uZWN0aW9uLmxvZ2dlci5sb2dUcmFuc2Zvcm0oe1xuICAgICAgICByZXF1ZXN0SWQ6IG1ldGFkYXRhT3B0aW9ucz8ucmVxdWVzdElkLFxuICAgICAgICBvcGVyYXRpb246IFRSQU5TRk9STV9UWVBFLlVQREFURSxcbiAgICAgICAgcHJlZml4OiAnQWZ0ZXInLFxuICAgICAgICBlbnRpdHlOYW1lLFxuICAgICAgICBwcmltYXJ5S2V5OiBudWxsLFxuICAgICAgICBib2R5OiB1cGRhdGVUcmFuc2FjdGlvbkl0ZW1zLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB1cGRhdGVUcmFuc2FjdGlvbkl0ZW1zO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTGF6eSBidWlsZCB1cGRhdGUgaXRlbSBpbnB1dFxuICAgKiBUaGlzIGlzIGhlbHBmdWwgaW4gY2FzZXMgd2hlcmUgd2UgZG9uJ3QgeW91IGhhdmUgYWxsIHRoZSBhdHRyaWJ1dGVzIHRvIGJ1aWxkIGl0ZW0gaW5wdXQsIGFuZCB0aGUgY2FsbGVyIHdpbGwgbmVlZCB0b1xuICAgKiB0byBwZXJmb3JtIHNvbWUgc29ydCBvZiBhc3luYyBjYWxsIGluIG9yZGVyIHRvIGZldGNoIGF0dHJpYnV0ZXMgYW5kIHByb2NlZWQgd2l0aCBidWlsZFxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBsYXp5VG9EeW5hbW9VcGRhdGVVbmlxdWVJdGVtRmFjdG9yeTxFbnRpdHk+KFxuICAgIHRhYmxlOiBUYWJsZSxcbiAgICBlbnRpdHlOYW1lOiBzdHJpbmcsXG4gICAgdW5pcXVlQXR0cmlidXRlc1RvVXBkYXRlOiBSZXBsYWNlPFxuICAgICAgQXR0cmlidXRlTWV0YWRhdGEsXG4gICAgICAndW5pcXVlJyxcbiAgICAgIHtcbiAgICAgICAgdW5pcXVlOiBEeW5hbW9FbnRpdHlTY2hlbWFQcmltYXJ5S2V5O1xuICAgICAgfVxuICAgID5bXSxcbiAgICBtYWluSXRlbTogRG9jdW1lbnRDbGllbnRUeXBlcy5VcGRhdGVJdGVtSW5wdXQsXG4gICAgbmV3Qm9keTogYW55LFxuICAgIG1ldGFkYXRhT3B0aW9ucz86IE1ldGFkYXRhT3B0aW9uc1xuICApIHtcbiAgICAvLyByZXR1cm5zIHRyYW5zYWN0IHdyaXRlIGl0ZW0gbGlzdFxuICAgIHJldHVybiAocHJldmlvdXNJdGVtQm9keTogYW55KSA9PiB7XG4gICAgICAvLyB1cGRhdGluZyB1bmlxdWUgYXR0cmlidXRlcyBhbHNvIHJlcXVpcmUgY2hlY2tpbmcgaWYgbmV3IHZhbHVlIGV4aXN0c1xuICAgICAgY29uc3QgdW5pcXVlUmVjb3JkQ29uZGl0aW9uRXhwcmVzc2lvbiA9XG4gICAgICAgIHRoaXMuZXhwcmVzc2lvbkJ1aWxkZXIuYnVpbGRVbmlxdWVSZWNvcmRDb25kaXRpb25FeHByZXNzaW9uKHRhYmxlKTtcblxuICAgICAgLy8gbWFwIGFsbCB1bmlxdWUgYXR0cmlidXRlcyB0byBbcHV0LCBkZWxldGVdIGl0ZW0gdHVwbGVcbiAgICAgIGNvbnN0IHVuaXF1ZUF0dHJpYnV0ZUlucHV0czogRG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbUxpc3QgPVxuICAgICAgICB1bmlxdWVBdHRyaWJ1dGVzVG9VcGRhdGUuZmxhdE1hcChhdHRyID0+IHtcbiAgICAgICAgICBjb25zdCB1bmlxdWVBdHRyaWJ1dGVXcml0ZUl0ZW1zOiBEb2N1bWVudENsaWVudFR5cGVzLlRyYW5zYWN0V3JpdGVJdGVtTGlzdCA9XG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBQdXQ6IHtcbiAgICAgICAgICAgICAgICAgIFRhYmxlTmFtZTogdGFibGUubmFtZSxcbiAgICAgICAgICAgICAgICAgIEl0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRQYXJzZWRQcmltYXJ5S2V5KFxuICAgICAgICAgICAgICAgICAgICAgIHRhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgIGF0dHIudW5pcXVlLFxuICAgICAgICAgICAgICAgICAgICAgIG5ld0JvZHkgYXMgUGFydGlhbDxFbnRpdHk+XG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4udW5pcXVlUmVjb3JkQ29uZGl0aW9uRXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgIC8vIGlmIHVuaXF1ZSBhdHRyaWJ1dGUgcHJldmlvdXNseSBleGlzdGVkLCByZW1vdmUgaXQgYXMgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2FjdGlvblxuICAgICAgICAgIGlmIChwcmV2aW91c0l0ZW1Cb2R5ICYmIHByZXZpb3VzSXRlbUJvZHlbYXR0ci5uYW1lXSkge1xuICAgICAgICAgICAgdW5pcXVlQXR0cmlidXRlV3JpdGVJdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgRGVsZXRlOiB7XG4gICAgICAgICAgICAgICAgVGFibGVOYW1lOiB0YWJsZS5uYW1lLFxuICAgICAgICAgICAgICAgIEtleToge1xuICAgICAgICAgICAgICAgICAgLi4udGhpcy5nZXRQYXJzZWRQcmltYXJ5S2V5KFxuICAgICAgICAgICAgICAgICAgICB0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgYXR0ci51bmlxdWUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzSXRlbUJvZHlcbiAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB1bmlxdWVBdHRyaWJ1dGVXcml0ZUl0ZW1zO1xuICAgICAgICB9KTtcblxuICAgICAgLy8gaW4gb3JkZXIgZm9yIHVwZGF0ZSBleHByZXNzIHRvIHN1Y2NlZWQsIGFsbCBsaXN0ZWQgbXVzdCBzdWNjZWVkIGluIGEgdHJhbnNhY3Rpb25cbiAgICAgIGNvbnN0IHVwZGF0ZVRyYW5zYWN0aW9uSXRlbXMgPSBbXG4gICAgICAgIHtVcGRhdGU6IG1haW5JdGVtfSxcbiAgICAgICAgLi4udW5pcXVlQXR0cmlidXRlSW5wdXRzLFxuICAgICAgXSBhcyBEb2N1bWVudENsaWVudFR5cGVzLlRyYW5zYWN0V3JpdGVJdGVtTGlzdDtcbiAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5VUERBVEUsXG4gICAgICAgIHByZWZpeDogJ0FmdGVyJyxcbiAgICAgICAgZW50aXR5TmFtZSxcbiAgICAgICAgcHJpbWFyeUtleTogbnVsbCxcbiAgICAgICAgYm9keTogdXBkYXRlVHJhbnNhY3Rpb25JdGVtcyxcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zYWN0aW9uSXRlbXM7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBsYXppbHkgcmVzb2x2ZSBhbGwgdW5pcXVlIGF0dHJpYnV0ZSBpdGVtcyB0byByZW1vdmVcbiAgICogQHBhcmFtIHRhYmxlXG4gICAqIEBwYXJhbSB1bmlxdWVBdHRyaWJ1dGVzVG9SZW1vdmVcbiAgICogQHBhcmFtIG1haW5JdGVtXG4gICAqL1xuICBwcml2YXRlIGxhenlUb0R5bmFtb1JlbW92ZUl0ZW1GYWN0b3J5KFxuICAgIHRhYmxlOiBUYWJsZSxcbiAgICBlbnRpdHlOYW1lOiBzdHJpbmcsXG4gICAgdW5pcXVlQXR0cmlidXRlc1RvUmVtb3ZlOiBSZXBsYWNlPFxuICAgICAgQXR0cmlidXRlTWV0YWRhdGEsXG4gICAgICAndW5pcXVlJyxcbiAgICAgIHtcbiAgICAgICAgdW5pcXVlOiBEeW5hbW9FbnRpdHlTY2hlbWFQcmltYXJ5S2V5O1xuICAgICAgfVxuICAgID5bXSxcbiAgICBtYWluSXRlbTogRG9jdW1lbnRDbGllbnRUeXBlcy5EZWxldGVJdGVtSW5wdXQsXG4gICAgbWV0YWRhdGFPcHRpb25zPzogTWV0YWRhdGFPcHRpb25zXG4gICkge1xuICAgIHJldHVybiAoZXhpc3RpbmdJdGVtQm9keTogYW55KSA9PiB7XG4gICAgICBsZXQgdW5pcXVlQXR0cmlidXRlSW5wdXRzOiBEb2N1bWVudENsaWVudFR5cGVzLlRyYW5zYWN0V3JpdGVJdGVtTGlzdCA9IFtdO1xuICAgICAgaWYgKGV4aXN0aW5nSXRlbUJvZHkpIHtcbiAgICAgICAgdW5pcXVlQXR0cmlidXRlSW5wdXRzID0gdW5pcXVlQXR0cmlidXRlc1RvUmVtb3ZlLm1hcChhdHRyID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRGVsZXRlOiB7XG4gICAgICAgICAgICAgIFRhYmxlTmFtZTogdGFibGUubmFtZSxcbiAgICAgICAgICAgICAgS2V5OiB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5nZXRQYXJzZWRQcmltYXJ5S2V5KFxuICAgICAgICAgICAgICAgICAgdGFibGUsXG4gICAgICAgICAgICAgICAgICBhdHRyLnVuaXF1ZSxcbiAgICAgICAgICAgICAgICAgIGV4aXN0aW5nSXRlbUJvZHlcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsZXRlVHJhbnNhY3Rpb25JdGVtcyA9IFtcbiAgICAgICAge1xuICAgICAgICAgIERlbGV0ZTogbWFpbkl0ZW0sXG4gICAgICAgIH0sXG4gICAgICAgIC4uLnVuaXF1ZUF0dHJpYnV0ZUlucHV0cyxcbiAgICAgIF0gYXMgRG9jdW1lbnRDbGllbnRUeXBlcy5UcmFuc2FjdFdyaXRlSXRlbUxpc3Q7XG5cbiAgICAgIHRoaXMuY29ubmVjdGlvbi5sb2dnZXIubG9nVHJhbnNmb3JtKHtcbiAgICAgICAgcmVxdWVzdElkOiBtZXRhZGF0YU9wdGlvbnM/LnJlcXVlc3RJZCxcbiAgICAgICAgb3BlcmF0aW9uOiBUUkFOU0ZPUk1fVFlQRS5ERUxFVEUsXG4gICAgICAgIHByZWZpeDogJ0FmdGVyJyxcbiAgICAgICAgZW50aXR5TmFtZSxcbiAgICAgICAgcHJpbWFyeUtleTogbnVsbCxcbiAgICAgICAgYm9keTogZGVsZXRlVHJhbnNhY3Rpb25JdGVtcyxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZGVsZXRlVHJhbnNhY3Rpb25JdGVtcztcbiAgICB9O1xuICB9XG59XG4iXX0=