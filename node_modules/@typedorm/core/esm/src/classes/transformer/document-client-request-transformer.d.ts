import { EntityTarget, QUERY_ORDER } from '@typedorm/common';
import { Connection } from '../connection/connection';
import { ExpressionBuilder } from '../expression/expression-builder';
import { BaseTransformer, MetadataOptions } from './base-transformer';
import { LazyTransactionWriteItemListLoader } from './is-lazy-transaction-write-item-list-loader';
import { KeyConditionOptions } from '../expression/key-condition-options-type';
import { UpdateBody } from '../expression/update-body-type';
import { DocumentClientTypes } from '@typedorm/document-client';
export interface ManagerToDynamoPutItemOptions {
    /**
     * @default false
     */
    overwriteIfExists?: boolean;
    where?: any;
}
export interface ManagerToDynamoUpdateItemsOptions {
    /**
     * key separator
     * @default '.''
     */
    nestedKeySeparator?: string;
    where?: any;
}
export interface ManagerToDynamoDeleteItemsOptions {
    where?: any;
}
export interface ManagerToDynamoQueryItemsOptions {
    /**
     * Index to query, when omitted, query will be run against main table
     */
    queryIndex?: string;
    /**
     * Sort key condition
     * @default none - no sort key condition is applied
     */
    keyCondition?: KeyConditionOptions;
    /**
     * Max number of records to query
     * @default - implicit dynamo db query limit is applied
     */
    limit?: number;
    /**
     * Order to query items in
     * @default ASC
     */
    orderBy?: QUERY_ORDER;
    where?: any;
    select?: any[];
    onlyCount?: boolean;
    consistentRead?: boolean;
}
export interface ManagerToDynamoGetItemOptions {
    select?: any[];
    consistentRead?: boolean;
}
export declare class DocumentClientRequestTransformer extends BaseTransformer {
    protected _expressionBuilder: ExpressionBuilder;
    constructor(connection: Connection);
    get expressionBuilder(): ExpressionBuilder;
    get expressionInputParser(): import("../expression/expression-input-parser").ExpressionInputParser;
    toDynamoPutItem<Entity>(entity: Entity, options?: ManagerToDynamoPutItemOptions, metadataOptions?: MetadataOptions): DocumentClientTypes.PutItemInput | DocumentClientTypes.TransactWriteItemList;
    toDynamoGetItem<Entity, PrimaryKey>(entityClass: EntityTarget<Entity>, primaryKey: PrimaryKey, options?: ManagerToDynamoGetItemOptions, metadataOptions?: MetadataOptions): DocumentClientTypes.GetItemInput;
    toDynamoUpdateItem<Entity, PrimaryKey = Record<string, unknown>, AdditionalProperties = Entity>(entityClass: EntityTarget<Entity>, primaryKeyAttributes: PrimaryKey, body: UpdateBody<Entity, AdditionalProperties>, options?: ManagerToDynamoUpdateItemsOptions, metadataOptions?: MetadataOptions): DocumentClientTypes.UpdateItemInput | LazyTransactionWriteItemListLoader;
    toDynamoDeleteItem<Entity, PrimaryKey>(entityClass: EntityTarget<Entity>, primaryKey: PrimaryKey, options?: ManagerToDynamoDeleteItemsOptions, metadataOptions?: MetadataOptions): DocumentClientTypes.DeleteItemInput | LazyTransactionWriteItemListLoader;
    toDynamoQueryItem<Entity, PartitionKeyAttributes>(entityClass: EntityTarget<Entity>, partitionKeyAttributes: PartitionKeyAttributes | string, queryOptions?: ManagerToDynamoQueryItemsOptions, metadataOptions?: MetadataOptions): DocumentClientTypes.QueryInput;
    private lazyToDynamoUpdatePrimaryKeyFactory;
    /**
     * Lazy build update item input
     * This is helpful in cases where we don't you have all the attributes to build item input, and the caller will need to
     * to perform some sort of async call in order to fetch attributes and proceed with build
     *
     */
    private lazyToDynamoUpdateUniqueItemFactory;
    /**
     * lazily resolve all unique attribute items to remove
     * @param table
     * @param uniqueAttributesToRemove
     * @param mainItem
     */
    private lazyToDynamoRemoveItemFactory;
}
