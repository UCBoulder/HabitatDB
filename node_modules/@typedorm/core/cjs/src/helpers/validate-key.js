"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateKey = void 0;
const common_1 = require("@typedorm/common");
const constants_1 = require("./constants");
const is_key_of_type_alias_schema_1 = require("./is-key-of-type-alias-schema");
/**
 *
 * @param key key to validate
 * @param dict dictionary to validate key against, dictionary of attribute { name: type }
 */
function validateKey(key, dict, entityName) {
    // validate aliases
    if ((0, is_key_of_type_alias_schema_1.isKeyOfTypeAliasSchema)(key)) {
        if (typeof key.alias !== 'string') {
            throw new common_1.InvalidAttributeAliasSchemaError(key.alias);
        }
        const aliasType = dict[key.alias];
        if (!aliasType) {
            throw new common_1.NoSuchAttributeExistsError(key.alias, entityName);
        }
        // return when successfully validated
        return;
    }
    const matchIterator = key.matchAll(constants_1.regexInterpolatedWord);
    validateMatch(key, matchIterator, dict);
    return;
}
exports.validateKey = validateKey;
function validateMatch(key, iterator, dict) {
    const next = iterator.next();
    if (next.done) {
        return;
    }
    const variable = next.value[1];
    const variableType = dict[variable];
    if (!variableType) {
        throw new Error(`key "${key}" references variable "${variable}" but it could not be resolved`);
    }
    if (variableType !== 'String' &&
        variableType !== 'Number' &&
        variableType !== 'Boolean') {
        throw new Error(`"${variable}" is used in key ${key}, thus it's type must be or scalar type, if attribute type is Enum, please set "isEnum" to true in attribute decorator.`);
    }
    validateMatch(key, iterator, dict);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGUta2V5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvaGVscGVycy92YWxpZGF0ZS1rZXkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsNkNBSTBCO0FBQzFCLDJDQUFrRDtBQUNsRCwrRUFBcUU7QUFFckU7Ozs7R0FJRztBQUNILFNBQWdCLFdBQVcsQ0FDekIsR0FBNkIsRUFDN0IsSUFBNkIsRUFDN0IsVUFBbUI7SUFFbkIsbUJBQW1CO0lBQ25CLElBQUksSUFBQSxvREFBc0IsRUFBQyxHQUFHLENBQUMsRUFBRTtRQUMvQixJQUFJLE9BQU8sR0FBRyxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDakMsTUFBTSxJQUFJLHlDQUFnQyxDQUFDLEdBQUcsQ0FBQyxLQUFZLENBQUMsQ0FBQztTQUM5RDtRQUVELE1BQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFbEMsSUFBSSxDQUFDLFNBQVMsRUFBRTtZQUNkLE1BQU0sSUFBSSxtQ0FBMEIsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1NBQzdEO1FBQ0QscUNBQXFDO1FBQ3JDLE9BQU87S0FDUjtJQUNELE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsaUNBQXFCLENBQUMsQ0FBQztJQUMxRCxhQUFhLENBQUMsR0FBRyxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN4QyxPQUFPO0FBQ1QsQ0FBQztBQXRCRCxrQ0FzQkM7QUFFRCxTQUFTLGFBQWEsQ0FDcEIsR0FBVyxFQUNYLFFBQTRDLEVBQzVDLElBQTZCO0lBRTdCLE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUM3QixJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDYixPQUFPO0tBQ1I7SUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQy9CLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUVwQyxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQ2IsUUFBUSxHQUFHLDBCQUEwQixRQUFRLGdDQUFnQyxDQUM5RSxDQUFDO0tBQ0g7SUFFRCxJQUNFLFlBQVksS0FBSyxRQUFRO1FBQ3pCLFlBQVksS0FBSyxRQUFRO1FBQ3pCLFlBQVksS0FBSyxTQUFTLEVBQzFCO1FBQ0EsTUFBTSxJQUFJLEtBQUssQ0FDYixJQUFJLFFBQVEsb0JBQW9CLEdBQUcseUhBQXlILENBQzdKLENBQUM7S0FDSDtJQUVELGFBQWEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3JDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBFbnRpdHlBbGlhc09yU3RyaW5nLFxuICBJbnZhbGlkQXR0cmlidXRlQWxpYXNTY2hlbWFFcnJvcixcbiAgTm9TdWNoQXR0cmlidXRlRXhpc3RzRXJyb3IsXG59IGZyb20gJ0B0eXBlZG9ybS9jb21tb24nO1xuaW1wb3J0IHtyZWdleEludGVycG9sYXRlZFdvcmR9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7aXNLZXlPZlR5cGVBbGlhc1NjaGVtYX0gZnJvbSAnLi9pcy1rZXktb2YtdHlwZS1hbGlhcy1zY2hlbWEnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ga2V5IGtleSB0byB2YWxpZGF0ZVxuICogQHBhcmFtIGRpY3QgZGljdGlvbmFyeSB0byB2YWxpZGF0ZSBrZXkgYWdhaW5zdCwgZGljdGlvbmFyeSBvZiBhdHRyaWJ1dGUgeyBuYW1lOiB0eXBlIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlS2V5KFxuICBrZXk6IEVudGl0eUFsaWFzT3JTdHJpbmc8YW55PixcbiAgZGljdDoge1trZXk6IHN0cmluZ106IHN0cmluZ30sXG4gIGVudGl0eU5hbWU/OiBzdHJpbmdcbikge1xuICAvLyB2YWxpZGF0ZSBhbGlhc2VzXG4gIGlmIChpc0tleU9mVHlwZUFsaWFzU2NoZW1hKGtleSkpIHtcbiAgICBpZiAodHlwZW9mIGtleS5hbGlhcyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXR0cmlidXRlQWxpYXNTY2hlbWFFcnJvcihrZXkuYWxpYXMgYXMgYW55KTtcbiAgICB9XG5cbiAgICBjb25zdCBhbGlhc1R5cGUgPSBkaWN0W2tleS5hbGlhc107XG5cbiAgICBpZiAoIWFsaWFzVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IE5vU3VjaEF0dHJpYnV0ZUV4aXN0c0Vycm9yKGtleS5hbGlhcywgZW50aXR5TmFtZSk7XG4gICAgfVxuICAgIC8vIHJldHVybiB3aGVuIHN1Y2Nlc3NmdWxseSB2YWxpZGF0ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWF0Y2hJdGVyYXRvciA9IGtleS5tYXRjaEFsbChyZWdleEludGVycG9sYXRlZFdvcmQpO1xuICB2YWxpZGF0ZU1hdGNoKGtleSwgbWF0Y2hJdGVyYXRvciwgZGljdCk7XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVNYXRjaChcbiAga2V5OiBzdHJpbmcsXG4gIGl0ZXJhdG9yOiBJdGVyYWJsZUl0ZXJhdG9yPFJlZ0V4cE1hdGNoQXJyYXk+LFxuICBkaWN0OiB7W2tleTogc3RyaW5nXTogc3RyaW5nfVxuKSB7XG4gIGNvbnN0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gIGlmIChuZXh0LmRvbmUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCB2YXJpYWJsZSA9IG5leHQudmFsdWVbMV07XG4gIGNvbnN0IHZhcmlhYmxlVHlwZSA9IGRpY3RbdmFyaWFibGVdO1xuXG4gIGlmICghdmFyaWFibGVUeXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGtleSBcIiR7a2V5fVwiIHJlZmVyZW5jZXMgdmFyaWFibGUgXCIke3ZhcmlhYmxlfVwiIGJ1dCBpdCBjb3VsZCBub3QgYmUgcmVzb2x2ZWRgXG4gICAgKTtcbiAgfVxuXG4gIGlmIChcbiAgICB2YXJpYWJsZVR5cGUgIT09ICdTdHJpbmcnICYmXG4gICAgdmFyaWFibGVUeXBlICE9PSAnTnVtYmVyJyAmJlxuICAgIHZhcmlhYmxlVHlwZSAhPT0gJ0Jvb2xlYW4nXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBcIiR7dmFyaWFibGV9XCIgaXMgdXNlZCBpbiBrZXkgJHtrZXl9LCB0aHVzIGl0J3MgdHlwZSBtdXN0IGJlIG9yIHNjYWxhciB0eXBlLCBpZiBhdHRyaWJ1dGUgdHlwZSBpcyBFbnVtLCBwbGVhc2Ugc2V0IFwiaXNFbnVtXCIgdG8gdHJ1ZSBpbiBhdHRyaWJ1dGUgZGVjb3JhdG9yLmBcbiAgICApO1xuICB9XG5cbiAgdmFsaWRhdGVNYXRjaChrZXksIGl0ZXJhdG9yLCBkaWN0KTtcbn1cbiJdfQ==