"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransformer = void 0;
const common_1 = require("@typedorm/common");
const get_constructor_for_instance_1 = require("../../helpers/get-constructor-for-instance");
const is_empty_object_1 = require("../../helpers/is-empty-object");
const is_scalar_type_1 = require("../../helpers/is-scalar-type");
const parse_key_1 = require("../../helpers/parse-key");
const auto_generated_attribute_metadata_1 = require("../metadata/auto-generated-attribute-metadata");
const is_dynamo_entity_key_schema_1 = require("../../helpers/is-dynamo-entity-key-schema");
const is_key_of_type_alias_schema_1 = require("../../helpers/is-key-of-type-alias-schema");
const class_transformer_1 = require("class-transformer");
const expression_input_parser_1 = require("../expression/expression-input-parser");
class BaseTransformer {
    constructor(connection) {
        this.connection = connection;
        this._expressionInputParser = new expression_input_parser_1.ExpressionInputParser();
    }
    /**
     * Returns table name decorated for given entity class
     * @param entityClass Entity Class
     */
    getTableNameForEntity(entityClass) {
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        return entityMetadata.table.name;
    }
    applyClassTransformerFormations(entity) {
        const transformedPlainEntity = (0, class_transformer_1.classToPlain)(entity, {
            enableImplicitConversion: true,
            excludePrefixes: ['__'], // exclude internal attributes
        });
        return transformedPlainEntity;
    }
    /**
     * Transforms entity to dynamo db entity schema
     * @param entity Entity to transform to DynamoDB entity type
     */
    toDynamoEntity(entity) {
        var _a;
        const entityClass = (0, get_constructor_for_instance_1.getConstructorForInstance)(entity);
        // retrieve metadata and parse it to schema
        const entityMetadata = this.connection.getEntityByTarget(entityClass);
        this.connection.getAttributesForEntity(entityClass).forEach(attr => {
            // if no explicit value was provided, look for default/autoGenerate values
            if (!Object.keys(entity).includes(attr.name)) {
                //  auto populate generated values
                if ((0, auto_generated_attribute_metadata_1.IsAutoGeneratedAttributeMetadata)(attr)) {
                    entity = Object.assign(entity, {
                        [attr.name]: attr.value,
                    });
                }
                const attributeDefaultValue = attr === null || attr === void 0 ? void 0 : attr.default;
                // include attribute with default value
                if (attributeDefaultValue &&
                    typeof attributeDefaultValue === 'function') {
                    const attrDefaultValue = attributeDefaultValue(entity);
                    entity = Object.assign(entity, {
                        [attr.name]: attrDefaultValue,
                    });
                }
            }
        });
        // pass through entity to class transformer to have all the metadata applied
        const parsedEntity = this.applyClassTransformerFormations(entity);
        const parsedPrimaryKey = this.recursiveParseEntity(entityMetadata.schema.primaryKey.attributes, parsedEntity);
        const indexesToParse = (_a = entityMetadata.schema.indexes) !== null && _a !== void 0 ? _a : {};
        const rawParsedIndexes = this.recursiveParseEntity(indexesToParse, parsedEntity);
        const parsedIndexes = Object.keys(rawParsedIndexes).reduce((acc, currIndexKey) => {
            const { metadata, attributes } = indexesToParse[currIndexKey];
            const currentParsedIndex = rawParsedIndexes[currIndexKey];
            // validate if there are any duplicated attribute names
            Object.keys(currentParsedIndex).forEach(attr => {
                if (acc[attr]) {
                    throw new Error(`Failed to parse entity "${entityMetadata.name}", duplicate attribute "${attr}".`);
                }
            });
            // if current index marked as sparse and one or more attribute is missing value, do not add it to schema
            if (metadata.isSparse) {
                const doesAllAttributesHaveValue = Object.keys(attributes).every(attr => {
                    if (!currentParsedIndex[attr]) {
                        return false;
                    }
                    return true;
                });
                if (!doesAllAttributesHaveValue) {
                    return acc;
                }
            }
            acc = Object.assign(Object.assign({}, acc), currentParsedIndex);
            return acc;
        }, {});
        // clone and cleanup any redundant keys
        const formattedSchema = Object.assign(Object.assign({}, parsedPrimaryKey), parsedIndexes);
        return Object.assign(Object.assign({}, parsedEntity), formattedSchema);
    }
    getAffectedPrimaryKeyAttributes(entityClass, attributes, attributesTypeMetadata, options) {
        const { schema: { primaryKey }, } = this.connection.getEntityByTarget(entityClass);
        const interpolations = primaryKey.metadata._interpolations;
        // if none of partition or sort key has any referenced attributes, return
        if (!interpolations || (0, is_empty_object_1.isEmptyObject)(interpolations)) {
            return;
        }
        const affectedKeyAttributes = Object.entries(attributes).reduce((acc, [attrKey, attrValue]) => {
            // bail early if current attribute type is not of type scalar
            if (!(0, is_scalar_type_1.isScalarType)(attrValue)) {
                return acc;
            }
            // resolve all interpolations
            Object.entries(interpolations).forEach(([primaryKeyAttrName, primaryKeyAttrRefs]) => {
                // if no attributes are referenced for current primary key attribute, return
                if (!primaryKeyAttrRefs.includes(attrKey)) {
                    return;
                }
                // if parsed value was of type we can not auto resolve indexes
                // this must be resolved by the dev
                if (attributesTypeMetadata[attrKey] === 'dynamic') {
                    throw new common_1.InvalidDynamicUpdateAttributeValueError(attrKey, attrValue);
                }
                const parsedKey = (0, parse_key_1.parseKey)(primaryKey.attributes[primaryKeyAttrName], Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.additionalAttributesDict), attributes));
                acc[primaryKeyAttrName] = parsedKey;
            });
            return acc;
        }, {});
        return affectedKeyAttributes;
    }
    /**
     * Returns all affected indexes for given attributes
     * @param entityClass Entity class
     * @param attributes Attributes to check affected indexes for
     * @param options
     */
    getAffectedIndexesForAttributes(entityClass, attributes, attributesTypeMetadata, options) {
        var _a;
        const nestedKeySeparator = (_a = options === null || options === void 0 ? void 0 : options.nestedKeySeparator) !== null && _a !== void 0 ? _a : '.';
        const { schema: { indexes }, } = this.connection.getEntityByTarget(entityClass);
        const affectedIndexes = Object.entries(attributes).reduce((acc, [attrKey, currAttrValue]) => {
            // if current value is not of scalar type skip checking index
            if (attrKey.includes(nestedKeySeparator) ||
                !(0, is_scalar_type_1.isScalarType)(currAttrValue)) {
                return acc;
            }
            if (!indexes) {
                return acc;
            }
            Object.keys(indexes).forEach(key => {
                var _a;
                const currIndex = indexes[key];
                const interpolationsForCurrIndex = (_a = currIndex.metadata._interpolations) !== null && _a !== void 0 ? _a : {};
                // if current index does not have any interpolations to resolve, move onto next one
                if ((0, is_empty_object_1.isEmptyObject)(interpolationsForCurrIndex)) {
                    return acc;
                }
                // check if attribute we are looking to update is referenced by any index
                Object.keys(interpolationsForCurrIndex).forEach(interpolationKey => {
                    const currentInterpolation = interpolationsForCurrIndex[interpolationKey];
                    if (currentInterpolation.includes(attrKey)) {
                        // if parsed value was of type we can not auto resolve indexes
                        // this must be resolved by the dev
                        if (attributesTypeMetadata[attrKey] === 'dynamic') {
                            throw new common_1.InvalidDynamicUpdateAttributeValueError(attrKey, currAttrValue);
                        }
                        try {
                            const parsedIndex = (0, parse_key_1.parseKey)(currIndex.attributes[interpolationKey], Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.additionalAttributesDict), attributes));
                            acc[interpolationKey] = parsedIndex;
                        }
                        catch (err) {
                            // if there was an error parsing sparse index, ignore
                            if (!(err instanceof common_1.SparseIndexParseError)) {
                                throw err;
                            }
                        }
                    }
                });
            });
            return acc;
        }, {});
        return affectedIndexes;
    }
    /**
     * Returns a primary key of an entity
     * @param entityClass Class of entity
     * @param attributes Attributes to parse into primary key
     */
    getParsedPrimaryKey(table, primaryKey, attributes) {
        return this.recursiveParseEntity(primaryKey.attributes, attributes);
    }
    /**
     * Recursively parses all keys of given object and replaces placeholders with matching values
     * @private
     * @param schema schema to resolve
     * @param entity entity to resolve schema against
     */
    recursiveParseEntity(schema, entity, isSparse = false) {
        const parsedSchema = Object.keys(schema).reduce((acc, key) => {
            var _a;
            const currentValue = schema[key];
            if (typeof currentValue === 'string' ||
                (0, is_key_of_type_alias_schema_1.isKeyOfTypeAliasSchema)(currentValue)) {
                try {
                    acc[key] = (0, parse_key_1.parseKey)(currentValue, entity, {
                        isSparseIndex: isSparse,
                    });
                }
                catch (err) {
                    // if there was an error parsing sparse index, ignore
                    if (!(err instanceof common_1.SparseIndexParseError)) {
                        throw err;
                    }
                }
            }
            else if ((0, is_dynamo_entity_key_schema_1.isDynamoEntityKeySchema)(currentValue)) {
                acc[key] = this.recursiveParseEntity(currentValue.attributes, entity, !!((_a = currentValue.metadata) === null || _a === void 0 ? void 0 : _a.isSparse));
            }
            else {
                acc[key] = this.recursiveParseEntity(currentValue, entity);
            }
            return acc;
        }, {});
        return parsedSchema;
    }
}
exports.BaseTransformer = BaseTransformer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS10cmFuc2Zvcm1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2NsYXNzZXMvdHJhbnNmb3JtZXIvYmFzZS10cmFuc2Zvcm1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFLQSw2Q0FNMEI7QUFDMUIsNkZBQXFGO0FBQ3JGLG1FQUE0RDtBQUM1RCxpRUFBMEQ7QUFDMUQsdURBQWlEO0FBRWpELHFHQUErRjtBQUUvRiwyRkFBa0Y7QUFDbEYsMkZBQWlGO0FBQ2pGLHlEQUErQztBQUMvQyxtRkFBNEU7QUFZNUUsTUFBc0IsZUFBZTtJQUduQyxZQUFzQixVQUFzQjtRQUF0QixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQzFDLElBQUksQ0FBQyxzQkFBc0IsR0FBRyxJQUFJLCtDQUFxQixFQUFFLENBQUM7SUFDNUQsQ0FBQztJQUNEOzs7T0FHRztJQUNILHFCQUFxQixDQUFTLFdBQWlDO1FBQzdELE1BQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsaUJBQWlCLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFdEUsT0FBTyxjQUFjLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQztJQUNuQyxDQUFDO0lBRUQsK0JBQStCLENBQVMsTUFBYztRQUNwRCxNQUFNLHNCQUFzQixHQUFHLElBQUEsZ0NBQVksRUFBUyxNQUFNLEVBQUU7WUFDMUQsd0JBQXdCLEVBQUUsSUFBSTtZQUM5QixlQUFlLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSw4QkFBOEI7U0FDeEQsQ0FBQyxDQUFDO1FBRUgsT0FBTyxzQkFBZ0MsQ0FBQztJQUMxQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsY0FBYyxDQUFTLE1BQWM7O1FBQ25DLE1BQU0sV0FBVyxHQUFHLElBQUEsd0RBQXlCLEVBQUMsTUFBTSxDQUFDLENBQUM7UUFFdEQsMkNBQTJDO1FBQzNDLE1BQU0sY0FBYyxHQUFHLElBQUks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QUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUNsQyxZQUFZLENBQUMsVUFBVSxFQUN2QixNQUFNLEVBQ04sQ0FBQyxDQUFDLENBQUEsTUFBQyxZQUFZLENBQUMsUUFBb0MsMENBQUUsUUFBUSxDQUFBLENBQy9ELENBQUM7YUFDSDtpQkFBTTtnQkFDTCxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFlBQVksRUFBRSxNQUFNLENBQUMsQ0FBQzthQUM1RDtZQUNELE9BQU8sR0FBRyxDQUFDO1FBQ2IsQ0FBQyxFQUFFLEVBQVMsQ0FBQyxDQUFDO1FBRWQsT0FBTyxZQUFZLENBQUM7SUFDdEIsQ0FBQztDQUNGO0FBM1RELDBDQTJUQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7QXR0cmlidXRlTWV0YWRhdGF9IGZyb20gJy4vLi4vbWV0YWRhdGEvYXR0cmlidXRlLW1ldGFkYXRhJztcbmltcG9ydCB7XG4gIER5bmFtb0VudGl0eUluZGV4ZXNTY2hlbWEsXG4gIER5bmFtb0VudGl0eUluZGV4U2NoZW1hLFxufSBmcm9tICcuLy4uL21ldGFkYXRhL2VudGl0eS1tZXRhZGF0YSc7XG5pbXBvcnQge1xuICBFbnRpdHlUYXJnZXQsXG4gIFRhYmxlLFxuICBTcGFyc2VJbmRleFBhcnNlRXJyb3IsXG4gIENPTlNVTUVEX0NBUEFDSVRZX1RZUEUsXG4gIEludmFsaWREeW5hbWljVXBkYXRlQXR0cmlidXRlVmFsdWVFcnJvcixcbn0gZnJvbSAnQHR5cGVkb3JtL2NvbW1vbic7XG5pbXBvcnQge2dldENvbnN0cnVjdG9yRm9ySW5zdGFuY2V9IGZyb20gJy4uLy4uL2hlbHBlcnMvZ2V0LWNvbnN0cnVjdG9yLWZvci1pbnN0YW5jZSc7XG5pbXBvcnQge2lzRW1wdHlPYmplY3R9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMtZW1wdHktb2JqZWN0JztcbmltcG9ydCB7aXNTY2FsYXJUeXBlfSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLXNjYWxhci10eXBlJztcbmltcG9ydCB7cGFyc2VLZXl9IGZyb20gJy4uLy4uL2hlbHBlcnMvcGFyc2Uta2V5JztcbmltcG9ydCB7Q29ubmVjdGlvbn0gZnJvbSAnLi4vY29ubmVjdGlvbi9jb25uZWN0aW9uJztcbmltcG9ydCB7SXNBdXRvR2VuZXJhdGVkQXR0cmlidXRlTWV0YWRhdGF9IGZyb20gJy4uL21ldGFkYXRhL2F1dG8tZ2VuZXJhdGVkLWF0dHJpYnV0ZS1tZXRhZGF0YSc7XG5pbXBvcnQge0R5bmFtb0VudGl0eVNjaGVtYVByaW1hcnlLZXl9IGZyb20gJy4uL21ldGFkYXRhL2VudGl0eS1tZXRhZGF0YSc7XG5pbXBvcnQge2lzRHluYW1vRW50aXR5S2V5U2NoZW1hfSBmcm9tICcuLi8uLi9oZWxwZXJzL2lzLWR5bmFtby1lbnRpdHkta2V5LXNjaGVtYSc7XG5pbXBvcnQge2lzS2V5T2ZUeXBlQWxpYXNTY2hlbWF9IGZyb20gJy4uLy4uL2hlbHBlcnMvaXMta2V5LW9mLXR5cGUtYWxpYXMtc2NoZW1hJztcbmltcG9ydCB7Y2xhc3NUb1BsYWlufSBmcm9tICdjbGFzcy10cmFuc2Zvcm1lcic7XG5pbXBvcnQge0V4cHJlc3Npb25JbnB1dFBhcnNlcn0gZnJvbSAnLi4vZXhwcmVzc2lvbi9leHByZXNzaW9uLWlucHV0LXBhcnNlcic7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWV0YWRhdGFPcHRpb25zIHtcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xuICByZXR1cm5Db25zdW1lZENhcGFjaXR5PzogQ09OU1VNRURfQ0FQQUNJVFlfVFlQRTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRhZGF0YU9wdGlvbnMge1xuICByZXF1ZXN0SWQ/OiBzdHJpbmc7XG4gIHJldHVybkNvbnN1bWVkQ2FwYWNpdHk/OiBDT05TVU1FRF9DQVBBQ0lUWV9UWVBFO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVRyYW5zZm9ybWVyIHtcbiAgcHJvdGVjdGVkIF9leHByZXNzaW9uSW5wdXRQYXJzZXI6IEV4cHJlc3Npb25JbnB1dFBhcnNlcjtcblxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgY29ubmVjdGlvbjogQ29ubmVjdGlvbikge1xuICAgIHRoaXMuX2V4cHJlc3Npb25JbnB1dFBhcnNlciA9IG5ldyBFeHByZXNzaW9uSW5wdXRQYXJzZXIoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0YWJsZSBuYW1lIGRlY29yYXRlZCBmb3IgZ2l2ZW4gZW50aXR5IGNsYXNzXG4gICAqIEBwYXJhbSBlbnRpdHlDbGFzcyBFbnRpdHkgQ2xhc3NcbiAgICovXG4gIGdldFRhYmxlTmFtZUZvckVudGl0eTxFbnRpdHk+KGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5Pikge1xuICAgIGNvbnN0IGVudGl0eU1ldGFkYXRhID0gdGhpcy5jb25uZWN0aW9uLmdldEVudGl0eUJ5VGFyZ2V0KGVudGl0eUNsYXNzKTtcblxuICAgIHJldHVybiBlbnRpdHlNZXRhZGF0YS50YWJsZS5uYW1lO1xuICB9XG5cbiAgYXBwbHlDbGFzc1RyYW5zZm9ybWVyRm9ybWF0aW9uczxFbnRpdHk+KGVudGl0eTogRW50aXR5KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRQbGFpbkVudGl0eSA9IGNsYXNzVG9QbGFpbjxFbnRpdHk+KGVudGl0eSwge1xuICAgICAgZW5hYmxlSW1wbGljaXRDb252ZXJzaW9uOiB0cnVlLFxuICAgICAgZXhjbHVkZVByZWZpeGVzOiBbJ19fJ10sIC8vIGV4Y2x1ZGUgaW50ZXJuYWwgYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybWVkUGxhaW5FbnRpdHkgYXMgRW50aXR5O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgZW50aXR5IHRvIGR5bmFtbyBkYiBlbnRpdHkgc2NoZW1hXG4gICAqIEBwYXJhbSBlbnRpdHkgRW50aXR5IHRvIHRyYW5zZm9ybSB0byBEeW5hbW9EQiBlbnRpdHkgdHlwZVxuICAgKi9cbiAgdG9EeW5hbW9FbnRpdHk8RW50aXR5PihlbnRpdHk6IEVudGl0eSkge1xuICAgIGNvbnN0IGVudGl0eUNsYXNzID0gZ2V0Q29uc3RydWN0b3JGb3JJbnN0YW5jZShlbnRpdHkpO1xuXG4gICAgLy8gcmV0cmlldmUgbWV0YWRhdGEgYW5kIHBhcnNlIGl0IHRvIHNjaGVtYVxuICAgIGNvbnN0IGVudGl0eU1ldGFkYXRhID0gdGhpcy5jb25uZWN0aW9uLmdldEVudGl0eUJ5VGFyZ2V0KGVudGl0eUNsYXNzKTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5nZXRBdHRyaWJ1dGVzRm9yRW50aXR5KGVudGl0eUNsYXNzKS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgLy8gaWYgbm8gZXhwbGljaXQgdmFsdWUgd2FzIHByb3ZpZGVkLCBsb29rIGZvciBkZWZhdWx0L2F1dG9HZW5lcmF0ZSB2YWx1ZXNcbiAgICAgIGlmICghT2JqZWN0LmtleXMoZW50aXR5IGFzIG9iamVjdCkuaW5jbHVkZXMoYXR0ci5uYW1lKSkge1xuICAgICAgICAvLyAgYXV0byBwb3B1bGF0ZSBnZW5lcmF0ZWQgdmFsdWVzXG4gICAgICAgIGlmIChJc0F1dG9HZW5lcmF0ZWRBdHRyaWJ1dGVNZXRhZGF0YShhdHRyKSkge1xuICAgICAgICAgIGVudGl0eSA9IE9iamVjdC5hc3NpZ24oZW50aXR5IGFzIG9iamVjdCwge1xuICAgICAgICAgICAgW2F0dHIubmFtZV06IGF0dHIudmFsdWUsXG4gICAgICAgICAgfSkgYXMgRW50aXR5O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXR0cmlidXRlRGVmYXVsdFZhbHVlID0gKGF0dHIgYXMgQXR0cmlidXRlTWV0YWRhdGEpPy5kZWZhdWx0O1xuXG4gICAgICAgIC8vIGluY2x1ZGUgYXR0cmlidXRlIHdpdGggZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0cmlidXRlRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgdHlwZW9mIGF0dHJpYnV0ZURlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBhdHRyRGVmYXVsdFZhbHVlID0gYXR0cmlidXRlRGVmYXVsdFZhbHVlKGVudGl0eSk7XG4gICAgICAgICAgZW50aXR5ID0gT2JqZWN0LmFzc2lnbihlbnRpdHkgYXMgb2JqZWN0LCB7XG4gICAgICAgICAgICBbYXR0ci5uYW1lXTogYXR0ckRlZmF1bHRWYWx1ZSxcbiAgICAgICAgICB9KSBhcyBFbnRpdHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHBhc3MgdGhyb3VnaCBlbnRpdHkgdG8gY2xhc3MgdHJhbnNmb3JtZXIgdG8gaGF2ZSBhbGwgdGhlIG1ldGFkYXRhIGFwcGxpZWRcbiAgICBjb25zdCBwYXJzZWRFbnRpdHkgPSB0aGlzLmFwcGx5Q2xhc3NUcmFuc2Zvcm1lckZvcm1hdGlvbnMoZW50aXR5KTtcblxuICAgIGNvbnN0IHBhcnNlZFByaW1hcnlLZXkgPSB0aGlzLnJlY3Vyc2l2ZVBhcnNlRW50aXR5KFxuICAgICAgZW50aXR5TWV0YWRhdGEuc2NoZW1hLnByaW1hcnlLZXkuYXR0cmlidXRlcyxcbiAgICAgIHBhcnNlZEVudGl0eVxuICAgICk7XG5cbiAgICBjb25zdCBpbmRleGVzVG9QYXJzZSA9IGVudGl0eU1ldGFkYXRhLnNjaGVtYS5pbmRleGVzID8/IHt9O1xuICAgIGNvbnN0IHJhd1BhcnNlZEluZGV4ZXMgPSB0aGlzLnJlY3Vyc2l2ZVBhcnNlRW50aXR5KFxuICAgICAgaW5kZXhlc1RvUGFyc2UsXG4gICAgICBwYXJzZWRFbnRpdHlcbiAgICApO1xuXG4gICAgY29uc3QgcGFyc2VkSW5kZXhlcyA9IE9iamVjdC5rZXlzKHJhd1BhcnNlZEluZGV4ZXMpLnJlZHVjZShcbiAgICAgIChhY2MsIGN1cnJJbmRleEtleSkgPT4ge1xuICAgICAgICBjb25zdCB7bWV0YWRhdGEsIGF0dHJpYnV0ZXN9ID0gaW5kZXhlc1RvUGFyc2VbY3VyckluZGV4S2V5XTtcbiAgICAgICAgY29uc3QgY3VycmVudFBhcnNlZEluZGV4ID0gcmF3UGFyc2VkSW5kZXhlc1tjdXJySW5kZXhLZXldO1xuXG4gICAgICAgIC8vIHZhbGlkYXRlIGlmIHRoZXJlIGFyZSBhbnkgZHVwbGljYXRlZCBhdHRyaWJ1dGUgbmFtZXNcbiAgICAgICAgT2JqZWN0LmtleXMoY3VycmVudFBhcnNlZEluZGV4KS5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgICAgIGlmIChhY2NbYXR0cl0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEZhaWxlZCB0byBwYXJzZSBlbnRpdHkgXCIke2VudGl0eU1ldGFkYXRhLm5hbWV9XCIsIGR1cGxpY2F0ZSBhdHRyaWJ1dGUgXCIke2F0dHJ9XCIuYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGN1cnJlbnQgaW5kZXggbWFya2VkIGFzIHNwYXJzZSBhbmQgb25lIG9yIG1vcmUgYXR0cmlidXRlIGlzIG1pc3NpbmcgdmFsdWUsIGRvIG5vdCBhZGQgaXQgdG8gc2NoZW1hXG4gICAgICAgIGlmIChtZXRhZGF0YS5pc1NwYXJzZSkge1xuICAgICAgICAgIGNvbnN0IGRvZXNBbGxBdHRyaWJ1dGVzSGF2ZVZhbHVlID0gT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZXZlcnkoXG4gICAgICAgICAgICBhdHRyID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFjdXJyZW50UGFyc2VkSW5kZXhbYXR0cl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmICghZG9lc0FsbEF0dHJpYnV0ZXNIYXZlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYWNjID0gey4uLmFjYywgLi4uY3VycmVudFBhcnNlZEluZGV4fTtcbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyB7W2tleTogc3RyaW5nXTogc3RyaW5nfVxuICAgICk7XG5cbiAgICAvLyBjbG9uZSBhbmQgY2xlYW51cCBhbnkgcmVkdW5kYW50IGtleXNcbiAgICBjb25zdCBmb3JtYXR0ZWRTY2hlbWEgPSB7XG4gICAgICAuLi5wYXJzZWRQcmltYXJ5S2V5LFxuICAgICAgLi4ucGFyc2VkSW5kZXhlcyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsuLi5wYXJzZWRFbnRpdHksIC4uLmZvcm1hdHRlZFNjaGVtYX07XG4gIH1cblxuICBnZXRBZmZlY3RlZFByaW1hcnlLZXlBdHRyaWJ1dGVzPEVudGl0eT4oXG4gICAgZW50aXR5Q2xhc3M6IEVudGl0eVRhcmdldDxFbnRpdHk+LFxuICAgIGF0dHJpYnV0ZXM6IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgYXR0cmlidXRlc1R5cGVNZXRhZGF0YTogUmVjb3JkPHN0cmluZywgJ3N0YXRpYycgfCAnZHluYW1pYyc+LFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICBhZGRpdGlvbmFsQXR0cmlidXRlc0RpY3Q/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICAgIH1cbiAgKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2NoZW1hOiB7cHJpbWFyeUtleX0sXG4gICAgfSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0aW9ucyA9IHByaW1hcnlLZXkubWV0YWRhdGEuX2ludGVycG9sYXRpb25zO1xuXG4gICAgLy8gaWYgbm9uZSBvZiBwYXJ0aXRpb24gb3Igc29ydCBrZXkgaGFzIGFueSByZWZlcmVuY2VkIGF0dHJpYnV0ZXMsIHJldHVyblxuICAgIGlmICghaW50ZXJwb2xhdGlvbnMgfHwgaXNFbXB0eU9iamVjdChpbnRlcnBvbGF0aW9ucykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhZmZlY3RlZEtleUF0dHJpYnV0ZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBbYXR0cktleSwgYXR0clZhbHVlXTogW3N0cmluZywgYW55XSkgPT4ge1xuICAgICAgICAvLyBiYWlsIGVhcmx5IGlmIGN1cnJlbnQgYXR0cmlidXRlIHR5cGUgaXMgbm90IG9mIHR5cGUgc2NhbGFyXG4gICAgICAgIGlmICghaXNTY2FsYXJUeXBlKGF0dHJWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbGwgaW50ZXJwb2xhdGlvbnNcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoaW50ZXJwb2xhdGlvbnMpLmZvckVhY2goXG4gICAgICAgICAgKFtwcmltYXJ5S2V5QXR0ck5hbWUsIHByaW1hcnlLZXlBdHRyUmVmc10pID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vIGF0dHJpYnV0ZXMgYXJlIHJlZmVyZW5jZWQgZm9yIGN1cnJlbnQgcHJpbWFyeSBrZXkgYXR0cmlidXRlLCByZXR1cm5cbiAgICAgICAgICAgIGlmICghcHJpbWFyeUtleUF0dHJSZWZzLmluY2x1ZGVzKGF0dHJLZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgcGFyc2VkIHZhbHVlIHdhcyBvZiB0eXBlIHdlIGNhbiBub3QgYXV0byByZXNvbHZlIGluZGV4ZXNcbiAgICAgICAgICAgIC8vIHRoaXMgbXVzdCBiZSByZXNvbHZlZCBieSB0aGUgZGV2XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1R5cGVNZXRhZGF0YVthdHRyS2V5XSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRHluYW1pY1VwZGF0ZUF0dHJpYnV0ZVZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICAgYXR0cktleSxcbiAgICAgICAgICAgICAgICBhdHRyVmFsdWVcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcGFyc2VkS2V5ID0gcGFyc2VLZXkoXG4gICAgICAgICAgICAgIHByaW1hcnlLZXkuYXR0cmlidXRlc1twcmltYXJ5S2V5QXR0ck5hbWVdLFxuICAgICAgICAgICAgICB7Li4ub3B0aW9ucz8uYWRkaXRpb25hbEF0dHJpYnV0ZXNEaWN0LCAuLi5hdHRyaWJ1dGVzfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFjY1twcmltYXJ5S2V5QXR0ck5hbWVdID0gcGFyc2VkS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfSxcbiAgICAgIHt9IGFzIFJlY29yZDxzdHJpbmcsIHN0cmluZz5cbiAgICApO1xuXG4gICAgcmV0dXJuIGFmZmVjdGVkS2V5QXR0cmlidXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBhZmZlY3RlZCBpbmRleGVzIGZvciBnaXZlbiBhdHRyaWJ1dGVzXG4gICAqIEBwYXJhbSBlbnRpdHlDbGFzcyBFbnRpdHkgY2xhc3NcbiAgICogQHBhcmFtIGF0dHJpYnV0ZXMgQXR0cmlidXRlcyB0byBjaGVjayBhZmZlY3RlZCBpbmRleGVzIGZvclxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgZ2V0QWZmZWN0ZWRJbmRleGVzRm9yQXR0cmlidXRlczxFbnRpdHk+KFxuICAgIGVudGl0eUNsYXNzOiBFbnRpdHlUYXJnZXQ8RW50aXR5PixcbiAgICBhdHRyaWJ1dGVzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIGF0dHJpYnV0ZXNUeXBlTWV0YWRhdGE6IFJlY29yZDxzdHJpbmcsICdzdGF0aWMnIHwgJ2R5bmFtaWMnPixcbiAgICBvcHRpb25zPzoge1xuICAgICAgbmVzdGVkS2V5U2VwYXJhdG9yPzogc3RyaW5nO1xuICAgICAgYWRkaXRpb25hbEF0dHJpYnV0ZXNEaWN0PzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgICB9XG4gICkge1xuICAgIGNvbnN0IG5lc3RlZEtleVNlcGFyYXRvciA9IG9wdGlvbnM/Lm5lc3RlZEtleVNlcGFyYXRvciA/PyAnLic7XG4gICAgY29uc3Qge1xuICAgICAgc2NoZW1hOiB7aW5kZXhlc30sXG4gICAgfSA9IHRoaXMuY29ubmVjdGlvbi5nZXRFbnRpdHlCeVRhcmdldChlbnRpdHlDbGFzcyk7XG5cbiAgICBjb25zdCBhZmZlY3RlZEluZGV4ZXMgPSBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoXG4gICAgICAoYWNjLCBbYXR0cktleSwgY3VyckF0dHJWYWx1ZV0pID0+IHtcbiAgICAgICAgLy8gaWYgY3VycmVudCB2YWx1ZSBpcyBub3Qgb2Ygc2NhbGFyIHR5cGUgc2tpcCBjaGVja2luZyBpbmRleFxuICAgICAgICBpZiAoXG4gICAgICAgICAgYXR0cktleS5pbmNsdWRlcyhuZXN0ZWRLZXlTZXBhcmF0b3IpIHx8XG4gICAgICAgICAgIWlzU2NhbGFyVHlwZShjdXJyQXR0clZhbHVlKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmRleGVzKSB7XG4gICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5rZXlzKGluZGV4ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICBjb25zdCBjdXJySW5kZXggPSBpbmRleGVzW2tleV07XG4gICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXggPVxuICAgICAgICAgICAgY3VyckluZGV4Lm1ldGFkYXRhLl9pbnRlcnBvbGF0aW9ucyA/PyB7fTtcblxuICAgICAgICAgIC8vIGlmIGN1cnJlbnQgaW5kZXggZG9lcyBub3QgaGF2ZSBhbnkgaW50ZXJwb2xhdGlvbnMgdG8gcmVzb2x2ZSwgbW92ZSBvbnRvIG5leHQgb25lXG4gICAgICAgICAgaWYgKGlzRW1wdHlPYmplY3QoaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNoZWNrIGlmIGF0dHJpYnV0ZSB3ZSBhcmUgbG9va2luZyB0byB1cGRhdGUgaXMgcmVmZXJlbmNlZCBieSBhbnkgaW5kZXhcbiAgICAgICAgICBPYmplY3Qua2V5cyhpbnRlcnBvbGF0aW9uc0ZvckN1cnJJbmRleCkuZm9yRWFjaChpbnRlcnBvbGF0aW9uS2V5ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnBvbGF0aW9uID1cbiAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbnNGb3JDdXJySW5kZXhbaW50ZXJwb2xhdGlvbktleV07XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJwb2xhdGlvbi5pbmNsdWRlcyhhdHRyS2V5KSkge1xuICAgICAgICAgICAgICAvLyBpZiBwYXJzZWQgdmFsdWUgd2FzIG9mIHR5cGUgd2UgY2FuIG5vdCBhdXRvIHJlc29sdmUgaW5kZXhlc1xuICAgICAgICAgICAgICAvLyB0aGlzIG11c3QgYmUgcmVzb2x2ZWQgYnkgdGhlIGRldlxuICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1R5cGVNZXRhZGF0YVthdHRyS2V5XSA9PT0gJ2R5bmFtaWMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWREeW5hbWljVXBkYXRlQXR0cmlidXRlVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgICAgIGF0dHJLZXksXG4gICAgICAgICAgICAgICAgICBjdXJyQXR0clZhbHVlXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSW5kZXggPSBwYXJzZUtleShcbiAgICAgICAgICAgICAgICAgIGN1cnJJbmRleC5hdHRyaWJ1dGVzW2ludGVycG9sYXRpb25LZXldLFxuICAgICAgICAgICAgICAgICAgey4uLm9wdGlvbnM/LmFkZGl0aW9uYWxBdHRyaWJ1dGVzRGljdCwgLi4uYXR0cmlidXRlc31cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIGFjY1tpbnRlcnBvbGF0aW9uS2V5XSA9IHBhcnNlZEluZGV4O1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgcGFyc2luZyBzcGFyc2UgaW5kZXgsIGlnbm9yZVxuICAgICAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIFNwYXJzZUluZGV4UGFyc2VFcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sXG4gICAgICB7fSBhcyBhbnlcbiAgICApO1xuICAgIHJldHVybiBhZmZlY3RlZEluZGV4ZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHByaW1hcnkga2V5IG9mIGFuIGVudGl0eVxuICAgKiBAcGFyYW0gZW50aXR5Q2xhc3MgQ2xhc3Mgb2YgZW50aXR5XG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIEF0dHJpYnV0ZXMgdG8gcGFyc2UgaW50byBwcmltYXJ5IGtleVxuICAgKi9cbiAgZ2V0UGFyc2VkUHJpbWFyeUtleTxFbnRpdHk+KFxuICAgIHRhYmxlOiBUYWJsZSxcbiAgICBwcmltYXJ5S2V5OiBEeW5hbW9FbnRpdHlTY2hlbWFQcmltYXJ5S2V5LFxuICAgIGF0dHJpYnV0ZXM6IFBhcnRpYWw8RW50aXR5PlxuICApIHtcbiAgICByZXR1cm4gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShwcmltYXJ5S2V5LmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlY3Vyc2l2ZWx5IHBhcnNlcyBhbGwga2V5cyBvZiBnaXZlbiBvYmplY3QgYW5kIHJlcGxhY2VzIHBsYWNlaG9sZGVycyB3aXRoIG1hdGNoaW5nIHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0gc2NoZW1hIHNjaGVtYSB0byByZXNvbHZlXG4gICAqIEBwYXJhbSBlbnRpdHkgZW50aXR5IHRvIHJlc29sdmUgc2NoZW1hIGFnYWluc3RcbiAgICovXG4gIHByb3RlY3RlZCByZWN1cnNpdmVQYXJzZUVudGl0eTxFbnRpdHkgPSBhbnk+KFxuICAgIHNjaGVtYTogRHluYW1vRW50aXR5U2NoZW1hUHJpbWFyeUtleSB8IER5bmFtb0VudGl0eUluZGV4ZXNTY2hlbWEsXG4gICAgZW50aXR5OiBFbnRpdHksXG4gICAgaXNTcGFyc2UgPSBmYWxzZVxuICApIHtcbiAgICBjb25zdCBwYXJzZWRTY2hlbWEgPSBPYmplY3Qua2V5cyhzY2hlbWEpLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IChzY2hlbWEgYXMgYW55KVtrZXldO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBjdXJyZW50VmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIGlzS2V5T2ZUeXBlQWxpYXNTY2hlbWEoY3VycmVudFZhbHVlKVxuICAgICAgKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYWNjW2tleV0gPSBwYXJzZUtleShjdXJyZW50VmFsdWUsIGVudGl0eSwge1xuICAgICAgICAgICAgaXNTcGFyc2VJbmRleDogaXNTcGFyc2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHNwYXJzZSBpbmRleCwgaWdub3JlXG4gICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgU3BhcnNlSW5kZXhQYXJzZUVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0R5bmFtb0VudGl0eUtleVNjaGVtYShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgIGFjY1trZXldID0gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShcbiAgICAgICAgICBjdXJyZW50VmFsdWUuYXR0cmlidXRlcyxcbiAgICAgICAgICBlbnRpdHksXG4gICAgICAgICAgISEoY3VycmVudFZhbHVlLm1ldGFkYXRhIGFzIER5bmFtb0VudGl0eUluZGV4U2NoZW1hKT8uaXNTcGFyc2VcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjY1trZXldID0gdGhpcy5yZWN1cnNpdmVQYXJzZUVudGl0eShjdXJyZW50VmFsdWUsIGVudGl0eSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9IGFzIGFueSk7XG5cbiAgICByZXR1cm4gcGFyc2VkU2NoZW1hO1xuICB9XG59XG4iXX0=