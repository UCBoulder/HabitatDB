import { WriteBatch } from '../batch/write-batch';
import { Connection } from '../connection/connection';
import { ReadBatch } from '../batch/read-batch';
import { MetadataOptions } from '../transformer/base-transformer';
export declare enum REQUEST_TYPE {
    TRANSACT_WRITE = "TRANSACT_WRITE",
    BATCH_WRITE = "BATCH_WRITE",
    BATCH_READ = "BATCH_READ"
}
/**
 * Batch manager write options
 */
export type BatchManagerWriteOptions = BatchManageBaseOptions;
/**
 * Batch manager read options
 */
export type BatchManagerReadOptions = BatchManageBaseOptions;
export interface BatchManageBaseOptions {
    /**
     * Max number of retries to perform before returning to client
     * @default BATCH_WRITE_MAX_ALLOWED_ATTEMPTS
     */
    maxRetryAttempts?: number;
    /**
     * Max number of requests to run in parallel
     * @default BATCH_WRITE_CONCURRENCY_LIMIT
     */
    requestsConcurrencyLimit?: number;
    /**
     * Exponential backoff multiplication factor to apply on back off algorithm
     * @default 1
     */
    backoffMultiplicationFactor?: number;
}
export declare class BatchManager {
    private connection;
    private _dcBatchTransformer;
    private _errorQueue;
    private limit;
    constructor(connection: Connection);
    /**
     * Writes all given items to dynamodb using either batch or transaction api.
     * _Note_: Transaction api is always used when item being written is using a unique attribute
     * @param batch
     */
    write(batch: WriteBatch, options?: BatchManagerWriteOptions, metadataOptions?: MetadataOptions): Promise<{
        unprocessedItems: import("../batch/write-batch").WriteBatchItem<any, any>[];
        failedItems: any[];
    }>;
    /**
     * Reads all items given in batch with default eventually consistent read type
     * _Note_: Returned items are not guaranteed to be in the same sequence as requested
     */
    read(batch: ReadBatch, options?: BatchManagerReadOptions, metadataOptions?: MetadataOptions): Promise<{
        items: unknown[];
        unprocessedItems: import("../batch/read-batch").ReadBatchItem<any, any>[];
        failedItems: import("../batch/read-batch").ReadBatchItem<any, any>[];
    }>;
    /**
     * Recursively parse batch requests until either all items are in or has reached retry limit
     * @param batchWriteItemOutputItems
     */
    private recursiveHandleBatchWriteItemsResponse;
    private recursiveHandleBatchReadItemsResponse;
    private resetErrorQueue;
    private mapBatchGetResponseToItemList;
    /**
     * Returns promise that is Promise.all safe and also can be managed by p-limit
     * @param anyPromiseFactory
     * @param requestItem // request item input
     * @param requestType // request type
     */
    private toLimited;
    private waitForExponentialBackoff;
    /**
     * @param attempts
     */
    private exponentialBackoff;
}
