"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Update = void 0;
const base_expression_input_1 = require("../base-expression-input");
class Update extends base_expression_input_1.BaseExpressionInput {
    constructor() {
        super(...arguments);
        // empty prefix for base update type
        this.prefix = '';
    }
    getExpNameKey(key) {
        return `#UE_${key}`;
    }
    getExpValueKey(key) {
        return `:UE_${key}`;
    }
    /**
     * @override and
     */
    and() {
        this.expression += ', ';
        return this;
    }
    /**
     * @override or
     */
    or() {
        throw new Error('"or" operation is not supported with update expression.');
    }
    /**
     * Support merging multiple update expressions with same keyword
     * @override merge
     */
    merge(update) {
        const { expression, names, values, prefix } = update;
        if (!prefix) {
            throw new Error('Can not merge with Base `Update` type, merging expression must have a valid prefix.');
        }
        // if merging condition does not have anything to merge return
        if (!expression) {
            return this;
        }
        if (update.constructor === this.constructor) {
            this.expression += this.expression ? ',' : '';
            this.appendToExpression(expression);
        }
        else {
            this.appendToExpression(`${prefix} ${expression}`);
        }
        this.names = Object.assign(Object.assign({}, this.names), names);
        this.values = Object.assign(Object.assign({}, this.values), values);
        return this;
    }
    /**
     * Support merging multiple update expressions with same or different keywords
     * @override  mergeMany
     */
    mergeMany(inputs) {
        const merged = inputs.reduce((acc, upd) => {
            acc.merge(upd);
            return acc;
        }, this);
        return merged;
    }
    getSymbolForArithmeticOperator(operator) {
        const symbolMap = {
            INCREMENT_BY: '+',
            DECREMENT_BY: '-',
        };
        return symbolMap[operator];
    }
}
exports.Update = Update;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBkYXRlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcGFja2FnZXMvY29yZS9zcmMvY2xhc3Nlcy9leHByZXNzaW9uL3VwZGF0ZS91cGRhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0Esb0VBQTZEO0FBRTdELE1BQWEsTUFBTyxTQUFRLDJDQUFtQjtJQUEvQzs7UUFDRSxvQ0FBb0M7UUFDMUIsV0FBTSxHQUFHLEVBQUUsQ0FBQztJQTZFeEIsQ0FBQztJQTNFVyxhQUFhLENBQUMsR0FBVztRQUNqQyxPQUFPLE9BQU8sR0FBRyxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUNTLGNBQWMsQ0FBQyxHQUFXO1FBQ2xDLE9BQU8sT0FBTyxHQUFHLEVBQUUsQ0FBQztJQUN0QixDQUFDO0lBRUQ7O09BRUc7SUFDSCxHQUFHO1FBQ0QsSUFBSSxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUM7UUFDeEIsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxFQUFFO1FBQ0EsTUFBTSxJQUFJLEtBQUssQ0FBQyx5REFBeUQsQ0FBQyxDQUFDO0lBQzdFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxLQUFLLENBQUMsTUFBYztRQUNsQixNQUFNLEVBQUMsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFDLEdBQUcsTUFBTSxDQUFDO1FBRW5ELElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDWCxNQUFNLElBQUksS0FBSyxDQUNiLHFGQUFxRixDQUN0RixDQUFDO1NBQ0g7UUFFRCw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDLFVBQVUsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxJQUFJLE1BQU0sQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUMzQyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUNyQzthQUFNO1lBQ0wsSUFBSSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsTUFBTSxJQUFJLFVBQVUsRUFBRSxDQUFDLENBQUM7U0FDcEQ7UUFFRCxJQUFJLENBQUMsS0FBSyxtQ0FBTyxJQUFJLENBQUMsS0FBSyxHQUFLLEtBQUssQ0FBQyxDQUFDO1FBQ3ZDLElBQUksQ0FBQyxNQUFNLG1DQUFPLElBQUksQ0FBQyxNQUFNLEdBQUssTUFBTSxDQUFDLENBQUM7UUFFMUMsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsU0FBUyxDQUFXLE1BQVc7UUFDN0IsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsRUFBRTtZQUN4QyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQXNCLENBQUMsQ0FBQztZQUNsQyxPQUFPLEdBQUcsQ0FBQztRQUNiLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUVULE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFUyw4QkFBOEIsQ0FDdEMsUUFBdUM7UUFFdkMsTUFBTSxTQUFTLEdBQUc7WUFDaEIsWUFBWSxFQUFFLEdBQUc7WUFDakIsWUFBWSxFQUFFLEdBQUc7U0FDbEIsQ0FBQztRQUNGLE9BQU8sU0FBUyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLENBQUM7Q0FDRjtBQS9FRCx3QkErRUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1VwZGF0ZVR5cGV9IGZyb20gJ0B0eXBlZG9ybS9jb21tb24nO1xuaW1wb3J0IHtCYXNlRXhwcmVzc2lvbklucHV0fSBmcm9tICcuLi9iYXNlLWV4cHJlc3Npb24taW5wdXQnO1xuXG5leHBvcnQgY2xhc3MgVXBkYXRlIGV4dGVuZHMgQmFzZUV4cHJlc3Npb25JbnB1dCB7XG4gIC8vIGVtcHR5IHByZWZpeCBmb3IgYmFzZSB1cGRhdGUgdHlwZVxuICBwcm90ZWN0ZWQgcHJlZml4ID0gJyc7XG5cbiAgcHJvdGVjdGVkIGdldEV4cE5hbWVLZXkoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBgI1VFXyR7a2V5fWA7XG4gIH1cbiAgcHJvdGVjdGVkIGdldEV4cFZhbHVlS2V5KGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYDpVRV8ke2tleX1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZSBhbmRcbiAgICovXG4gIGFuZCgpOiB0aGlzIHtcbiAgICB0aGlzLmV4cHJlc3Npb24gKz0gJywgJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGUgb3JcbiAgICovXG4gIG9yKCk6IHRoaXMge1xuICAgIHRocm93IG5ldyBFcnJvcignXCJvclwiIG9wZXJhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIHdpdGggdXBkYXRlIGV4cHJlc3Npb24uJyk7XG4gIH1cblxuICAvKipcbiAgICogU3VwcG9ydCBtZXJnaW5nIG11bHRpcGxlIHVwZGF0ZSBleHByZXNzaW9ucyB3aXRoIHNhbWUga2V5d29yZFxuICAgKiBAb3ZlcnJpZGUgbWVyZ2VcbiAgICovXG4gIG1lcmdlKHVwZGF0ZTogVXBkYXRlKSB7XG4gICAgY29uc3Qge2V4cHJlc3Npb24sIG5hbWVzLCB2YWx1ZXMsIHByZWZpeH0gPSB1cGRhdGU7XG5cbiAgICBpZiAoIXByZWZpeCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2FuIG5vdCBtZXJnZSB3aXRoIEJhc2UgYFVwZGF0ZWAgdHlwZSwgbWVyZ2luZyBleHByZXNzaW9uIG11c3QgaGF2ZSBhIHZhbGlkIHByZWZpeC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIGlmIG1lcmdpbmcgY29uZGl0aW9uIGRvZXMgbm90IGhhdmUgYW55dGhpbmcgdG8gbWVyZ2UgcmV0dXJuXG4gICAgaWYgKCFleHByZXNzaW9uKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodXBkYXRlLmNvbnN0cnVjdG9yID09PSB0aGlzLmNvbnN0cnVjdG9yKSB7XG4gICAgICB0aGlzLmV4cHJlc3Npb24gKz0gdGhpcy5leHByZXNzaW9uID8gJywnIDogJyc7XG4gICAgICB0aGlzLmFwcGVuZFRvRXhwcmVzc2lvbihleHByZXNzaW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBlbmRUb0V4cHJlc3Npb24oYCR7cHJlZml4fSAke2V4cHJlc3Npb259YCk7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lcyA9IHsuLi50aGlzLm5hbWVzLCAuLi5uYW1lc307XG4gICAgdGhpcy52YWx1ZXMgPSB7Li4udGhpcy52YWx1ZXMsIC4uLnZhbHVlc307XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdXBwb3J0IG1lcmdpbmcgbXVsdGlwbGUgdXBkYXRlIGV4cHJlc3Npb25zIHdpdGggc2FtZSBvciBkaWZmZXJlbnQga2V5d29yZHNcbiAgICogQG92ZXJyaWRlICBtZXJnZU1hbnlcbiAgICovXG4gIG1lcmdlTWFueTxUID0gdGhpcz4oaW5wdXRzOiBUW10pOiBhbnkge1xuICAgIGNvbnN0IG1lcmdlZCA9IGlucHV0cy5yZWR1Y2UoKGFjYywgdXBkKSA9PiB7XG4gICAgICBhY2MubWVyZ2UodXBkIGFzIHVua25vd24gYXMgdGhpcyk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuXG4gIHByb3RlY3RlZCBnZXRTeW1ib2xGb3JBcml0aG1ldGljT3BlcmF0b3IoXG4gICAgb3BlcmF0b3I6IFVwZGF0ZVR5cGUuQXJpdGhtZXRpY09wZXJhdG9yXG4gICkge1xuICAgIGNvbnN0IHN5bWJvbE1hcCA9IHtcbiAgICAgIElOQ1JFTUVOVF9CWTogJysnLFxuICAgICAgREVDUkVNRU5UX0JZOiAnLScsXG4gICAgfTtcbiAgICByZXR1cm4gc3ltYm9sTWFwW29wZXJhdG9yXTtcbiAgfVxufVxuIl19