import { Table } from '@typedorm/common';
import { Condition } from './condition';
import { Filter } from './filter';
import { KeyCondition } from './key-condition';
import { Projection } from './projection';
import { Update } from './update/update';
export declare class ExpressionBuilder {
    andMergeConditionExpressions(existingExp: {
        ConditionExpression?: string;
        ExpressionAttributeNames?: any;
        ExpressionAttributeValues?: any;
    }, newExp: {
        ConditionExpression?: string;
        ExpressionAttributeNames?: any;
        ExpressionAttributeValues?: any;
    }): {
        [key: string]: any;
        ExpressionAttributeNames?: Record<string, any> | undefined;
        ExpressionAttributeValues?: Record<string, any> | undefined;
    };
    /**
     * Higher level function to build unique record condition expression
     * @param table table to build unique record expression for
     */
    buildUniqueRecordConditionExpression(table: Table): {
        [key: string]: any;
        ExpressionAttributeNames?: Record<string, any> | undefined;
        ExpressionAttributeValues?: Record<string, any> | undefined;
    };
    buildConditionExpression(condition: Condition): {
        ConditionExpression?: string;
        ExpressionAttributeNames?: Record<string, any>;
        ExpressionAttributeValues?: Record<string, any>;
    };
    buildProjectionExpression(projection: Projection): {
        ProjectionExpression?: string;
        ExpressionAttributeNames?: Record<string, any>;
    };
    buildUpdateExpression(update: Update): {
        [key: string]: any;
        ExpressionAttributeNames?: Record<string, any> | undefined;
        ExpressionAttributeValues?: Record<string, any> | undefined;
    };
    buildKeyConditionExpression(condition: KeyCondition): {
        KeyConditionExpression?: string;
        ExpressionAttributeNames?: Record<string, any>;
        ExpressionAttributeValues?: Record<string, any>;
    };
    buildFilterExpression(filter: Filter): {
        FilterExpression?: string;
        ExpressionAttributeNames?: Record<string, any>;
        ExpressionAttributeValues?: Record<string, any>;
    };
    private removeEmptyFieldsAndReturn;
}
